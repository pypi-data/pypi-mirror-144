# This file was generated by exp2python.  You probably don't want to edit
# it since your modifications will be lost if exp2python is used to
# regenerate it.
import sys

from scl.SCLBase import *
from scl.SimpleDataTypes import *
from scl.ConstructedDataTypes import *
from scl.AggregationDataTypes import *
from scl.TypeChecker import check_type
from scl.Builtin import *
from scl.Rules import *

schema_name = 'ifc4x2'

schema_scope = sys.modules[__name__]


# Defined datatype ifcmomentofinertiameasure
class ifcmomentofinertiameasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcionconcentrationmeasure
class ifcionconcentrationmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcfontvariant
class ifcfontvariant(String):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = (self == ['normal', 'small-caps'])
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifctemperaturerateofchangemeasure
class ifctemperaturerateofchangemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifctimestamp
class ifctimestamp(Integer):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcaccelerationmeasure
class ifcaccelerationmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcdoseequivalentmeasure
class ifcdoseequivalentmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcnumericmeasure
class ifcnumericmeasure(Number):
    def __init__(self, *kargs):
        pass


# Defined datatype ifclinearforcemeasure
class ifclinearforcemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifctextdecoration
class ifctextdecoration(String):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = (self == ['none', 'underline', 'overline', 'line-through', 'blink'])
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifcfrequencymeasure
class ifcfrequencymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcmassdensitymeasure
class ifcmassdensitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcdate
class ifcdate(String):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcluminousintensitydistributionmeasure
class ifcluminousintensitydistributionmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcrotationalfrequencymeasure
class ifcrotationalfrequencymeasure(Real):
    def __init__(self, *kargs):
        pass


ifcboolean = bool


# Defined datatype ifcmolecularweightmeasure
class ifcmolecularweightmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcspecularexponent
class ifcspecularexponent(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifctorquemeasure
class ifctorquemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcsectionmodulusmeasure
class ifcsectionmodulusmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifclinearmomentmeasure
class ifclinearmomentmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcvolumemeasure
class ifcvolumemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcluminousintensitymeasure
class ifcluminousintensitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifccurvaturemeasure
class ifccurvaturemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifclinearvelocitymeasure
class ifclinearvelocitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcmonetarymeasure
class ifcmonetarymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcdynamicviscositymeasure
class ifcdynamicviscositymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcbinary
class ifcbinary(Binary):
    def __init__(self, *kargs):
        pass


# Defined datatype ifctexttransformation
class ifctexttransformation(String):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = (self == ['capitalize', 'uppercase', 'lowercase', 'none'])
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifctimemeasure
class ifctimemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcelectricchargemeasure
class ifcelectricchargemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcthermaltransmittancemeasure
class ifcthermaltransmittancemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcparametervalue
class ifcparametervalue(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcisothermalmoisturecapacitymeasure
class ifcisothermalmoisturecapacitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcratiomeasure
class ifcratiomeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcdatetime
class ifcdatetime(String):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcpowermeasure
class ifcpowermeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcsoundpressurelevelmeasure
class ifcsoundpressurelevelmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcsectionalareaintegralmeasure
class ifcsectionalareaintegralmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcthermalconductivitymeasure
class ifcthermalconductivitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcdayinmonthnumber
class ifcdayinmonthnumber(Integer):
    def __init__(self, *kargs):
        pass
        self.validrange()

    def validrange(self):
        eval_validrange_wr = ((1 <= self) and (self <= 31))
        if not eval_validrange_wr:
            raise AssertionError('Rule validrange violated')
        else:
            return eval_validrange_wr


# Defined datatype ifcsolidanglemeasure
class ifcsolidanglemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcfontweight
class ifcfontweight(String):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = (self == ['normal', 'small-caps', '100', '200', '300', '400', '500', '600', '700', '800', '900'])
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifcshearmodulusmeasure
class ifcshearmodulusmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcdayinweeknumber
class ifcdayinweeknumber(Integer):
    def __init__(self, *kargs):
        pass
        self.validrange()

    def validrange(self):
        eval_validrange_wr = ((1 <= self) and (self <= 7))
        if not eval_validrange_wr:
            raise AssertionError('Rule validrange violated')
        else:
            return eval_validrange_wr


# Defined datatype ifcabsorbeddosemeasure
class ifcabsorbeddosemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcforcemeasure
class ifcforcemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcthermalexpansioncoefficientmeasure
class ifcthermalexpansioncoefficientmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcsoundpowerlevelmeasure
class ifcsoundpowerlevelmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifclabel
class ifclabel(String):
    def __init__(self, *kargs):
        pass


# Defined datatype ifccardinalpointreference
class ifccardinalpointreference(Integer):
    def __init__(self, *kargs):
        pass
        self.greaterthanzero()

    def greaterthanzero(self):
        eval_greaterthanzero_wr = (self > 0)
        if not eval_greaterthanzero_wr:
            raise AssertionError('Rule greaterthanzero violated')
        else:
            return eval_greaterthanzero_wr


# Defined datatype ifcthermalresistancemeasure
class ifcthermalresistancemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcdimensioncount
class ifcdimensioncount(Integer):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = ((0 < self) and (self <= 3))
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifcmassflowratemeasure
class ifcmassflowratemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcelectricconductancemeasure
class ifcelectricconductancemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcidentifier
class ifcidentifier(String):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcilluminancemeasure
class ifcilluminancemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcpressuremeasure
class ifcpressuremeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcmonthinyearnumber
class ifcmonthinyearnumber(Integer):
    def __init__(self, *kargs):
        pass
        self.validrange()

    def validrange(self):
        eval_validrange_wr = ((1 <= self) and (self <= 12))
        if not eval_validrange_wr:
            raise AssertionError('Rule validrange violated')
        else:
            return eval_validrange_wr


# Defined datatype ifcinductancemeasure
class ifcinductancemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcphmeasure
class ifcphmeasure(Real):
    def __init__(self, *kargs):
        pass
        self.wr21()

    def wr21(self):
        eval_wr21_wr = ((0 <= self) and (self <= 14))
        if not eval_wr21_wr:
            raise AssertionError('Rule wr21 violated')
        else:
            return eval_wr21_wr


# Defined datatype ifcintegercountratemeasure
class ifcintegercountratemeasure(Integer):
    def __init__(self, *kargs):
        pass


# Defined datatype ifclinearstiffnessmeasure
class ifclinearstiffnessmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcwarpingconstantmeasure
class ifcwarpingconstantmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifckinematicviscositymeasure
class ifckinematicviscositymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifctextfontname
class ifctextfontname(String):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcmodulusofelasticitymeasure
class ifcmodulusofelasticitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcelectricvoltagemeasure
class ifcelectricvoltagemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcenergymeasure
class ifcenergymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifccontextdependentmeasure
class ifccontextdependentmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcvolumetricflowratemeasure
class ifcvolumetricflowratemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcsoundpressuremeasure
class ifcsoundpressuremeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifctime
class ifctime(String):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcplanarforcemeasure
class ifcplanarforcemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcrotationalmassmeasure
class ifcrotationalmassmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcspecificheatcapacitymeasure
class ifcspecificheatcapacitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcduration
class ifcduration(String):
    def __init__(self, *kargs):
        pass


# Defined datatype ifctext
class ifctext(String):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcdescriptivemeasure
class ifcdescriptivemeasure(String):
    def __init__(self, *kargs):
        pass


# Defined datatype ifclengthmeasure
class ifclengthmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcmodulusofrotationalsubgradereactionmeasure
class ifcmodulusofrotationalsubgradereactionmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcgloballyuniqueid
class ifcgloballyuniqueid(String):
    def __init__(self, *kargs):
        pass


# Defined datatype ifctemperaturegradientmeasure
class ifctemperaturegradientmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifctextalignment
class ifctextalignment(String):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = (self == ['left', 'right', 'center', 'justify'])
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifcvaporpermeabilitymeasure
class ifcvaporpermeabilitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcheatingvaluemeasure
class ifcheatingvaluemeasure(Real):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = (self > 0)
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifcmassperlengthmeasure
class ifcmassperlengthmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcspecularroughness
class ifcspecularroughness(Real):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = ((0 <= self) and (self <= 1))
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifccountmeasure
class ifccountmeasure(Number):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcelectriccurrentmeasure
class ifcelectriccurrentmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcmassmeasure
class ifcmassmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcpresentabletext
class ifcpresentabletext(String):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcluminousfluxmeasure
class ifcluminousfluxmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcreal
class ifcreal(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcfontstyle
class ifcfontstyle(String):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = (self == ['normal', 'italic', 'oblique'])
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifcplaneanglemeasure
class ifcplaneanglemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcelectriccapacitancemeasure
class ifcelectriccapacitancemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcamountofsubstancemeasure
class ifcamountofsubstancemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcwarpingmomentmeasure
class ifcwarpingmomentmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcmoisturediffusivitymeasure
class ifcmoisturediffusivitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifclogical
class ifclogical(Logical):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcmodulusofsubgradereactionmeasure
class ifcmodulusofsubgradereactionmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcsoundpowermeasure
class ifcsoundpowermeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcmagneticfluxmeasure
class ifcmagneticfluxmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcareadensitymeasure
class ifcareadensitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcurireference
class ifcurireference(String):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcangularvelocitymeasure
class ifcangularvelocitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcrotationalstiffnessmeasure
class ifcrotationalstiffnessmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcmodulusoflinearsubgradereactionmeasure
class ifcmodulusoflinearsubgradereactionmeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcthermaladmittancemeasure
class ifcthermaladmittancemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcelectricresistancemeasure
class ifcelectricresistancemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcareameasure
class ifcareameasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcinteger
class ifcinteger(Integer):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcheatfluxdensitymeasure
class ifcheatfluxdensitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcradioactivitymeasure
class ifcradioactivitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcmagneticfluxdensitymeasure
class ifcmagneticfluxdensitymeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcthermodynamictemperaturemeasure
class ifcthermodynamictemperaturemeasure(Real):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcpositiveplaneanglemeasure
class ifcpositiveplaneanglemeasure(ifcplaneanglemeasure):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = (self > 0)
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifcnonnegativelengthmeasure
class ifcnonnegativelengthmeasure(ifclengthmeasure):
    def __init__(self, *kargs):
        pass
        self.notnegative()

    def notnegative(self):
        eval_notnegative_wr = (self >= 0)
        if not eval_notnegative_wr:
            raise AssertionError('Rule notnegative violated')
        else:
            return eval_notnegative_wr


# Defined datatype ifcpositivelengthmeasure
class ifcpositivelengthmeasure(ifclengthmeasure):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = (self > 0)
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifcpositiveratiomeasure
class ifcpositiveratiomeasure(ifcratiomeasure):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = (self > 0)
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifcnormalisedratiomeasure
class ifcnormalisedratiomeasure(ifcratiomeasure):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = ((0 <= self) and (self <= 1))
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifcboxalignment
class ifcboxalignment(ifclabel):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = (self == ['top-left', 'top-middle', 'top-right', 'middle-left', 'center', 'middle-right',
                                'bottom-left', 'bottom-middle', 'bottom-right'])
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# Defined datatype ifclanguageid
class ifclanguageid(ifcidentifier):
    def __init__(self, *kargs):
        pass


# Defined datatype ifcpositiveinteger
class ifcpositiveinteger(ifcinteger):
    def __init__(self, *kargs):
        pass
        self.wr1()

    def wr1(self):
        eval_wr1_wr = (self > 0)
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


# ENUMERATION TYPE ifcsiprefix
ifcsiprefix = ENUMERATION('ifcsiprefix',
                          'exa pico mega femto atto centi nano hecto micro tera giga milli peta deci kilo deca ')

# ENUMERATION TYPE ifcstructuralsurfacemembertypeenum
ifcstructuralsurfacemembertypeenum = ENUMERATION('ifcstructuralsurfacemembertypeenum',
                                                 'bending_element notdefined userdefined membrane_element shell ')
# SELECT TYPE ifcmeasurevalue
ifcmeasurevalue = SELECT(
    'ifcamountofsubstancemeasure',
    'ifcareameasure',
    'ifccomplexnumber',
    'ifccontextdependentmeasure',
    'ifccountmeasure',
    'ifcdescriptivemeasure',
    'ifcelectriccurrentmeasure',
    'ifclengthmeasure',
    'ifcluminousintensitymeasure',
    'ifcmassmeasure',
    'ifcnonnegativelengthmeasure',
    'ifcnormalisedratiomeasure',
    'ifcnumericmeasure',
    'ifcparametervalue',
    'ifcplaneanglemeasure',
    'ifcpositivelengthmeasure',
    'ifcpositiveplaneanglemeasure',
    'ifcpositiveratiomeasure',
    'ifcratiomeasure',
    'ifcsolidanglemeasure',
    'ifcthermodynamictemperaturemeasure',
    'ifctimemeasure',
    'ifcvolumemeasure',
    scope=schema_scope)
# SELECT TYPE ifcsurfacestyleelementselect
ifcsurfacestyleelementselect = SELECT(
    'ifcexternallydefinedsurfacestyle',
    'ifcsurfacestylelighting',
    'ifcsurfacestylerefraction',
    'ifcsurfacestyleshading',
    'ifcsurfacestylewithtextures',
    scope=schema_scope)

# ENUMERATION TYPE ifcvoidingfeaturetypeenum
ifcvoidingfeaturetypeenum = ENUMERATION('ifcvoidingfeaturetypeenum',
                                        'notdefined userdefined miter edge notch hole cutout chamfer ')
# SELECT TYPE ifccoordinatereferencesystemselect
ifccoordinatereferencesystemselect = SELECT(
    'ifccoordinatereferencesystem',
    'ifcgeometricrepresentationcontext',
    scope=schema_scope)

# ENUMERATION TYPE ifclogicaloperatorenum
ifclogicaloperatorenum = ENUMERATION('ifclogicaloperatorenum',
                                     'logicaland logicalor logicalnotor logicalxor logicalnotand ')

# ENUMERATION TYPE ifcramptypeenum
ifcramptypeenum = ENUMERATION('ifcramptypeenum',
                              'quarter_turn_ramp notdefined userdefined two_quarter_turn_ramp half_turn_ramp two_straight_run_ramp spiral_ramp straight_run_ramp ')
# SELECT TYPE ifccolourorfactor
ifccolourorfactor = SELECT(
    'ifccolourrgb',
    'ifcnormalisedratiomeasure',
    scope=schema_scope)
ifcarcindex = LIST(3, 3, 'INTEGER', scope=schema_scope)

# ENUMERATION TYPE ifcprojectionelementtypeenum
ifcprojectionelementtypeenum = ENUMERATION('ifcprojectionelementtypeenum', 'deviator notdefined userdefined blister ')

# ENUMERATION TYPE ifcdoortypeoperationenum
ifcdoortypeoperationenum = ENUMERATION('ifcdoortypeoperationenum',
                                       'double_door_folding double_door_single_swing notdefined userdefined double_door_single_swing_opposite_left sliding_to_right double_swing_left sliding_to_left folding_to_left revolving single_swing_left rollingup swing_fixed_right double_door_single_swing_opposite_right single_swing_right double_door_double_swing double_door_sliding swing_fixed_left double_swing_right folding_to_right ')

# ENUMERATION TYPE ifccommunicationsappliancetypeenum
ifccommunicationsappliancetypeenum = ENUMERATION('ifccommunicationsappliancetypeenum',
                                                 'router notdefined userdefined networkbridge networkappliance printer modem gateway antenna fax computer networkhub repeater scanner ')

# ENUMERATION TYPE ifcprotectivedevicetypeenum
ifcprotectivedevicetypeenum = ENUMERATION('ifcprotectivedevicetypeenum',
                                          'earthleakagecircuitbreaker notdefined userdefined varistor residualcurrentcircuitbreaker earthingswitch fusedisconnector residualcurrentswitch circuitbreaker ')

# ENUMERATION TYPE ifcreinforcingbarsurfaceenum
ifcreinforcingbarsurfaceenum = ENUMERATION('ifcreinforcingbarsurfaceenum', 'plain textured ')
ifclineindex = LIST(2, None, 'INTEGER', scope=schema_scope)

# ENUMERATION TYPE ifcsimplepropertytemplatetypeenum
ifcsimplepropertytemplatetypeenum = ENUMERATION('ifcsimplepropertytemplatetypeenum',
                                                'p_boundedvalue p_tablevalue q_volume q_area p_singlevalue p_listvalue q_time q_length p_enumeratedvalue q_count p_referencevalue q_weight ')

# ENUMERATION TYPE ifcdampertypeenum
ifcdampertypeenum = ENUMERATION('ifcdampertypeenum',
                                'smokedamper notdefined firedamper userdefined balancingdamper firesmokedamper fumehoodexhaust backdraftdamper gravitydamper controldamper blastdamper reliefdamper gravityreliefdamper ')
# SELECT TYPE ifcresourceobjectselect
ifcresourceobjectselect = SELECT(
    'ifcactorrole',
    'ifcappliedvalue',
    'ifcapproval',
    'ifcconstraint',
    'ifccontextdependentunit',
    'ifcconversionbasedunit',
    'ifcexternalinformation',
    'ifcexternalreference',
    'ifcmaterialdefinition',
    'ifcorganization',
    'ifcperson',
    'ifcpersonandorganization',
    'ifcphysicalquantity',
    'ifcprofiledef',
    'ifcpropertyabstraction',
    'ifcshapeaspect',
    'ifctimeseries',
    scope=schema_scope)

# ENUMERATION TYPE ifcshadingdevicetypeenum
ifcshadingdevicetypeenum = ENUMERATION('ifcshadingdevicetypeenum', 'notdefined userdefined shutter awning jalousie ')

# ENUMERATION TYPE ifcbearingtypedisplacementenum
ifcbearingtypedisplacementenum = ENUMERATION('ifcbearingtypedisplacementenum',
                                             'notdefined fixed_movement free_movement guided_longitudinal guided_transversal ')

# ENUMERATION TYPE ifcelectricgeneratortypeenum
ifcelectricgeneratortypeenum = ENUMERATION('ifcelectricgeneratortypeenum',
                                           'notdefined userdefined enginegenerator chp standalone ')

# ENUMERATION TYPE ifcboilertypeenum
ifcboilertypeenum = ENUMERATION('ifcboilertypeenum', 'notdefined userdefined steam water ')

# ENUMERATION TYPE ifcsubcontractresourcetypeenum
ifcsubcontractresourcetypeenum = ENUMERATION('ifcsubcontractresourcetypeenum', 'notdefined userdefined work purchase ')

# ENUMERATION TYPE ifcbsplinesurfaceform
ifcbsplinesurfaceform = ENUMERATION('ifcbsplinesurfaceform',
                                    'ruled_surf quadric_surf conical_surf surf_of_revolution plane_surf spherical_surf surf_of_linear_extrusion cylindrical_surf generalised_cone unspecified toroidal_surf ')

# ENUMERATION TYPE ifcconstructionproductresourcetypeenum
ifcconstructionproductresourcetypeenum = ENUMERATION('ifcconstructionproductresourcetypeenum',
                                                     'notdefined userdefined formwork assembly ')

# ENUMERATION TYPE ifccablefittingtypeenum
ifccablefittingtypeenum = ENUMERATION('ifccablefittingtypeenum',
                                      'junction notdefined userdefined entry transition connector exit ')
# SELECT TYPE ifcmetricvalueselect
ifcmetricvalueselect = SELECT(
    'ifcappliedvalue',
    'ifcmeasurewithunit',
    'ifcreference',
    'ifctable',
    'ifctimeseries',
    'ifcvalue',
    scope=schema_scope)

# ENUMERATION TYPE ifcreferenttypeenum
ifcreferenttypeenum = ENUMERATION('ifcreferenttypeenum', 'notdefined userdefined kilopoint milepoint station ')

# ENUMERATION TYPE ifcreinforcingmeshtypeenum
ifcreinforcingmeshtypeenum = ENUMERATION('ifcreinforcingmeshtypeenum', 'notdefined userdefined ')

# ENUMERATION TYPE ifctransitioncurvetype
ifctransitioncurvetype = ENUMERATION('ifctransitioncurvetype',
                                     'cosinecurve sinecurve biquadraticparabola blosscurve clothoidcurve cubicparabola ')

# ENUMERATION TYPE ifcwindowtypeenum
ifcwindowtypeenum = ENUMERATION('ifcwindowtypeenum', 'notdefined userdefined skylight lightdome window ')
# SELECT TYPE ifcproductselect
ifcproductselect = SELECT(
    'ifcproduct',
    'ifctypeproduct',
    scope=schema_scope)

# ENUMERATION TYPE ifcbenchmarkenum
ifcbenchmarkenum = ENUMERATION('ifcbenchmarkenum',
                               'lessthanorequalto greaterthanorequalto includedin includes greaterthan lessthan notincludedin equalto notincludes notequalto ')

# ENUMERATION TYPE ifcductfittingtypeenum
ifcductfittingtypeenum = ENUMERATION('ifcductfittingtypeenum',
                                     'junction notdefined userdefined entry transition bend connector exit obstruction ')

# ENUMERATION TYPE ifctaskdurationenum
ifctaskdurationenum = ENUMERATION('ifctaskdurationenum', 'notdefined elapsedtime worktime ')

# ENUMERATION TYPE ifccontrollertypeenum
ifccontrollertypeenum = ENUMERATION('ifccontrollertypeenum',
                                    'notdefined userdefined twoposition floating proportional multiposition programmable ')

# ENUMERATION TYPE ifcpermeablecoveringoperationenum
ifcpermeablecoveringoperationenum = ENUMERATION('ifcpermeablecoveringoperationenum',
                                                'notdefined userdefined grill louver screen ')

# ENUMERATION TYPE ifcductsilencertypeenum
ifcductsilencertypeenum = ENUMERATION('ifcductsilencertypeenum', 'notdefined userdefined rectangular flatoval round ')

# ENUMERATION TYPE ifclightfixturetypeenum
ifclightfixturetypeenum = ENUMERATION('ifclightfixturetypeenum',
                                      'notdefined userdefined directionsource securitylighting pointsource ')

# ENUMERATION TYPE ifcrampflighttypeenum
ifcrampflighttypeenum = ENUMERATION('ifcrampflighttypeenum', 'notdefined userdefined spiral straight ')

# ENUMERATION TYPE ifcairtoairheatrecoverytypeenum
ifcairtoairheatrecoverytypeenum = ENUMERATION('ifcairtoairheatrecoverytypeenum',
                                              'notdefined userdefined fixedplateparallelflowexchanger twintowerenthalpyrecoveryloops fixedplatecrossflowexchanger heatpipe runaroundcoilloop thermosiphonsealedtubeheatexchangers fixedplatecounterflowexchanger rotarywheel thermosiphoncoiltypeheatexchangers ')

# ENUMERATION TYPE ifcarithmeticoperatorenum
ifcarithmeticoperatorenum = ENUMERATION('ifcarithmeticoperatorenum', 'subtract multiply add divide ')

# ENUMERATION TYPE ifcbsplinecurveform
ifcbsplinecurveform = ENUMERATION('ifcbsplinecurveform',
                                  'hyperbolic_arc elliptic_arc polyline_form unspecified circular_arc parabolic_arc ')

# ENUMERATION TYPE ifclightdistributioncurveenum
ifclightdistributioncurveenum = ENUMERATION('ifclightdistributioncurveenum', 'notdefined type_c type_b type_a ')

# ENUMERATION TYPE ifcdataoriginenum
ifcdataoriginenum = ENUMERATION('ifcdataoriginenum', 'notdefined userdefined simulated predicted measured ')

# ENUMERATION TYPE ifcspacetypeenum
ifcspacetypeenum = ENUMERATION('ifcspacetypeenum', 'notdefined userdefined internal space external parking gfa ')
# SELECT TYPE ifcresourceselect
ifcresourceselect = SELECT(
    'ifcresource',
    'ifctyperesource',
    scope=schema_scope)

# ENUMERATION TYPE ifcwasteterminaltypeenum
ifcwasteterminaltypeenum = ENUMERATION('ifcwasteterminaltypeenum',
                                       'floorwaste floortrap notdefined userdefined roofdrain gullytrap wastedisposalunit gullysump wastetrap ')

# ENUMERATION TYPE ifcworkplantypeenum
ifcworkplantypeenum = ENUMERATION('ifcworkplantypeenum', 'notdefined userdefined actual planned baseline ')

# ENUMERATION TYPE ifcdoortypeenum
ifcdoortypeenum = ENUMERATION('ifcdoortypeenum', 'notdefined userdefined trapdoor door gate ')
# SELECT TYPE ifcstructuralactivityassignmentselect
ifcstructuralactivityassignmentselect = SELECT(
    'ifcelement',
    'ifcstructuralitem',
    scope=schema_scope)
# SELECT TYPE ifcvectorordirection
ifcvectorordirection = SELECT(
    'ifcdirection',
    'ifcvector',
    scope=schema_scope)

# ENUMERATION TYPE ifcdirectionsenseenum
ifcdirectionsenseenum = ENUMERATION('ifcdirectionsenseenum', 'negative positive ')
# SELECT TYPE ifcrotationalstiffnessselect
ifcrotationalstiffnessselect = SELECT(
    'ifcboolean',
    'ifcrotationalstiffnessmeasure',
    scope=schema_scope)

# ENUMERATION TYPE ifcfurnituretypeenum
ifcfurnituretypeenum = ENUMERATION('ifcfurnituretypeenum',
                                   'notdefined userdefined sofa table chair shelf desk bed filecabinet ')
# SELECT TYPE ifcpropertysetdefinitionselect
ifcpropertysetdefinitionselect = SELECT(
    'ifcpropertysetdefinition',
    'ifcpropertysetdefinitionset',
    scope=schema_scope)
# SELECT TYPE ifcshell
ifcshell = SELECT(
    'ifcclosedshell',
    'ifcopenshell',
    scope=schema_scope)

# ENUMERATION TYPE ifcevaporatortypeenum
ifcevaporatortypeenum = ENUMERATION('ifcevaporatortypeenum',
                                    'notdefined userdefined directexpansiontubeintube directexpansionbrazedplate directexpansion floodedshellandtube shellandcoil directexpansionshellandtube ')

# ENUMERATION TYPE ifctendonanchortypeenum
ifctendonanchortypeenum = ENUMERATION('ifctendonanchortypeenum',
                                      'tensioning_end notdefined userdefined fixed_end coupler ')

# ENUMERATION TYPE ifcfiresuppressionterminaltypeenum
ifcfiresuppressionterminaltypeenum = ENUMERATION('ifcfiresuppressionterminaltypeenum',
                                                 'notdefined userdefined breechinginlet firehydrant hosereel sprinklerdeflector sprinkler ')

# ENUMERATION TYPE ifccolumntypeenum
ifccolumntypeenum = ENUMERATION('ifccolumntypeenum',
                                'notdefined userdefined pierstem pierstem_segment standcolumn column pilaster ')

# ENUMERATION TYPE ifcpileconstructionenum
ifcpileconstructionenum = ENUMERATION('ifcpileconstructionenum',
                                      'notdefined userdefined precast_concrete composite prefab_steel cast_in_place ')
# SELECT TYPE ifcobjectreferenceselect
ifcobjectreferenceselect = SELECT(
    'ifcaddress',
    'ifcappliedvalue',
    'ifcexternalreference',
    'ifcmaterialdefinition',
    'ifcorganization',
    'ifcperson',
    'ifcpersonandorganization',
    'ifctable',
    'ifctimeseries',
    scope=schema_scope)

# ENUMERATION TYPE ifcelectricappliancetypeenum
ifcelectricappliancetypeenum = ENUMERATION('ifcelectricappliancetypeenum',
                                           'microwave notdefined userdefined washingmachine refrigerator dishwasher kitchenmachine freestandingfan freezer handdryer freestandingelectricheater fridge_freezer freestandingwaterheater freestandingwatercooler photocopier vendingmachine tumbledryer electriccooker ')

# ENUMERATION TYPE ifcinventorytypeenum
ifcinventorytypeenum = ENUMERATION('ifcinventorytypeenum',
                                   'notdefined userdefined furnitureinventory spaceinventory assetinventory ')

# ENUMERATION TYPE ifclamptypeenum
ifclamptypeenum = ENUMERATION('ifclamptypeenum',
                              'metalhalide notdefined userdefined highpressuresodium fluorescent oled compactfluorescent tungstenfilament halogen highpressuremercury led ')

# ENUMERATION TYPE ifcactionrequesttypeenum
ifcactionrequesttypeenum = ENUMERATION('ifcactionrequesttypeenum',
                                       'notdefined userdefined verbal post phone fax email ')
# SELECT TYPE ifcpresentationstyleselect
ifcpresentationstyleselect = SELECT(
    'ifccurvestyle',
    'ifcfillareastyle',
    'ifcnullstyle',
    'ifcsurfacestyle',
    'ifctextstyle',
    scope=schema_scope)

# ENUMERATION TYPE ifcsystemfurnitureelementtypeenum
ifcsystemfurnitureelementtypeenum = ENUMERATION('ifcsystemfurnitureelementtypeenum',
                                                'notdefined userdefined worksurface panel ')
# SELECT TYPE ifcunit
ifcunit = SELECT(
    'ifcderivedunit',
    'ifcmonetaryunit',
    'ifcnamedunit',
    scope=schema_scope)

# ENUMERATION TYPE ifcalignmenttypeenum
ifcalignmenttypeenum = ENUMERATION('ifcalignmenttypeenum', 'notdefined userdefined ')
# SELECT TYPE ifcsegmentindexselect
ifcsegmentindexselect = SELECT(
    'ifcarcindex',
    'ifclineindex',
    scope=schema_scope)
# SELECT TYPE ifctimeorratioselect
ifctimeorratioselect = SELECT(
    'ifcduration',
    'ifcratiomeasure',
    scope=schema_scope)

# ENUMERATION TYPE ifctendonconduittypeenum
ifctendonconduittypeenum = ENUMERATION('ifctendonconduittypeenum',
                                       'notdefined userdefined grouting_duct trumpet duct diabolo coupler ')
# SELECT TYPE ifccurvefontorscaledcurvefontselect
ifccurvefontorscaledcurvefontselect = SELECT(
    'ifccurvestylefontandscaling',
    'ifccurvestylefontselect',
    scope=schema_scope)

# ENUMERATION TYPE ifcdiscreteaccessorytypeenum
ifcdiscreteaccessorytypeenum = ENUMERATION('ifcdiscreteaccessorytypeenum',
                                           'notdefined userdefined expansion_joint_device bracket shoe anchorplate ')

# ENUMERATION TYPE ifcflowdirectionenum
ifcflowdirectionenum = ENUMERATION('ifcflowdirectionenum', 'notdefined sink source sourceandsink ')

# ENUMERATION TYPE ifcobjectiveenum
ifcobjectiveenum = ENUMERATION('ifcobjectiveenum',
                               'designintent parameter notdefined userdefined requirement mergeconflict codewaiver modelview codecompliance triggercondition specification external healthandsafety ')

# ENUMERATION TYPE ifccablecarriersegmenttypeenum
ifccablecarriersegmenttypeenum = ENUMERATION('ifccablecarriersegmenttypeenum',
                                             'notdefined userdefined conduitsegment cableladdersegment cabletraysegment cabletrunkingsegment ')

# ENUMERATION TYPE ifcroleenum
ifcroleenum = ENUMERATION('ifcroleenum',
                          'constructionmanager owner userdefined structuralengineer architect projectmanager consultant supplier fieldconstructionmanager manufacturer commissioningengineer buildingoperator civilengineer engineer subcontractor reseller client contractor electricalengineer mechanicalengineer facilitiesmanager buildingowner costengineer ')

# ENUMERATION TYPE ifccurveinterpolationenum
ifccurveinterpolationenum = ENUMERATION('ifccurveinterpolationenum', 'notdefined log_log log_linear linear ')
# SELECT TYPE ifcvalue
ifcvalue = SELECT(
    'ifcderivedmeasurevalue',
    'ifcmeasurevalue',
    'ifcsimplevalue',
    scope=schema_scope)

# ENUMERATION TYPE ifcflowinstrumenttypeenum
ifcflowinstrumenttypeenum = ENUMERATION('ifcflowinstrumenttypeenum',
                                        'thermometer notdefined userdefined phaseanglemeter ammeter pressuregauge powerfactormeter voltmeter_peak frequencymeter voltmeter_rms ')
# SELECT TYPE ifclightdistributiondatasourceselect
ifclightdistributiondatasourceselect = SELECT(
    'ifcexternalreference',
    'ifclightintensitydistribution',
    scope=schema_scope)

# ENUMERATION TYPE ifcreinforcingbartypeenum
ifcreinforcingbartypeenum = ENUMERATION('ifcreinforcingbartypeenum',
                                        'shear main notdefined userdefined spacebar edge punching anchoring stud ligature ring ')

# ENUMERATION TYPE ifctransportelementtypeenum
ifctransportelementtypeenum = ENUMERATION('ifctransportelementtypeenum',
                                          'elevator notdefined userdefined escalator liftinggear craneway movingwalkway ')
# SELECT TYPE ifcdefinitionselect
ifcdefinitionselect = SELECT(
    'ifcobjectdefinition',
    'ifcpropertydefinition',
    scope=schema_scope)

# ENUMERATION TYPE ifcsolardevicetypeenum
ifcsolardevicetypeenum = ENUMERATION('ifcsolardevicetypeenum', 'notdefined userdefined solarcollector solarpanel ')

# ENUMERATION TYPE ifceventtypeenum
ifceventtypeenum = ENUMERATION('ifceventtypeenum', 'notdefined userdefined startevent intermediateevent endevent ')

# ENUMERATION TYPE ifcsectiontypeenum
ifcsectiontypeenum = ENUMERATION('ifcsectiontypeenum', 'tapered uniform ')
# SELECT TYPE ifcderivedmeasurevalue
ifcderivedmeasurevalue = SELECT(
    'ifcabsorbeddosemeasure',
    'ifcaccelerationmeasure',
    'ifcangularvelocitymeasure',
    'ifcareadensitymeasure',
    'ifccompoundplaneanglemeasure',
    'ifccurvaturemeasure',
    'ifcdoseequivalentmeasure',
    'ifcdynamicviscositymeasure',
    'ifcelectriccapacitancemeasure',
    'ifcelectricchargemeasure',
    'ifcelectricconductancemeasure',
    'ifcelectricresistancemeasure',
    'ifcelectricvoltagemeasure',
    'ifcenergymeasure',
    'ifcforcemeasure',
    'ifcfrequencymeasure',
    'ifcheatfluxdensitymeasure',
    'ifcheatingvaluemeasure',
    'ifcilluminancemeasure',
    'ifcinductancemeasure',
    'ifcintegercountratemeasure',
    'ifcionconcentrationmeasure',
    'ifcisothermalmoisturecapacitymeasure',
    'ifckinematicviscositymeasure',
    'ifclinearforcemeasure',
    'ifclinearmomentmeasure',
    'ifclinearstiffnessmeasure',
    'ifclinearvelocitymeasure',
    'ifcluminousfluxmeasure',
    'ifcluminousintensitydistributionmeasure',
    'ifcmagneticfluxdensitymeasure',
    'ifcmagneticfluxmeasure',
    'ifcmassdensitymeasure',
    'ifcmassflowratemeasure',
    'ifcmassperlengthmeasure',
    'ifcmodulusofelasticitymeasure',
    'ifcmodulusoflinearsubgradereactionmeasure',
    'ifcmodulusofrotationalsubgradereactionmeasure',
    'ifcmodulusofsubgradereactionmeasure',
    'ifcmoisturediffusivitymeasure',
    'ifcmolecularweightmeasure',
    'ifcmomentofinertiameasure',
    'ifcmonetarymeasure',
    'ifcphmeasure',
    'ifcplanarforcemeasure',
    'ifcpowermeasure',
    'ifcpressuremeasure',
    'ifcradioactivitymeasure',
    'ifcrotationalfrequencymeasure',
    'ifcrotationalmassmeasure',
    'ifcrotationalstiffnessmeasure',
    'ifcsectionmodulusmeasure',
    'ifcsectionalareaintegralmeasure',
    'ifcshearmodulusmeasure',
    'ifcsoundpowerlevelmeasure',
    'ifcsoundpowermeasure',
    'ifcsoundpressurelevelmeasure',
    'ifcsoundpressuremeasure',
    'ifcspecificheatcapacitymeasure',
    'ifctemperaturegradientmeasure',
    'ifctemperaturerateofchangemeasure',
    'ifcthermaladmittancemeasure',
    'ifcthermalconductivitymeasure',
    'ifcthermalexpansioncoefficientmeasure',
    'ifcthermalresistancemeasure',
    'ifcthermaltransmittancemeasure',
    'ifctorquemeasure',
    'ifcvaporpermeabilitymeasure',
    'ifcvolumetricflowratemeasure',
    'ifcwarpingconstantmeasure',
    'ifcwarpingmomentmeasure',
    scope=schema_scope)

# ENUMERATION TYPE ifcelementcompositionenum
ifcelementcompositionenum = ENUMERATION('ifcelementcompositionenum', 'complex element partial ')

# ENUMERATION TYPE ifcpropertysettemplatetypeenum
ifcpropertysettemplatetypeenum = ENUMERATION('ifcpropertysettemplatetypeenum',
                                             'notdefined qto_occurrencedriven qto_typedrivenoverride pset_performancedriven pset_occurrencedriven pset_typedrivenoverride pset_typedrivenonly qto_typedrivenonly ')
# SELECT TYPE ifcclassificationselect
ifcclassificationselect = SELECT(
    'ifcclassification',
    'ifcclassificationreference',
    scope=schema_scope)

# ENUMERATION TYPE ifcmechanicalfastenertypeenum
ifcmechanicalfastenertypeenum = ENUMERATION('ifcmechanicalfastenertypeenum',
                                            'notdefined userdefined studshearconnector dowel staple rivet anchorbolt nailplate screw shearconnector bolt nail coupler ')

# ENUMERATION TYPE ifcwindowpaneloperationenum
ifcwindowpaneloperationenum = ENUMERATION('ifcwindowpaneloperationenum',
                                          'pivotvertical notdefined pivothorizontal tiltandturnrighthand otheroperation fixedcasement slidinghorizontal slidingvertical tiltandturnlefthand sidehunglefthand bottomhung tophung sidehungrighthand removablecasement ')

# ENUMERATION TYPE ifcmembertypeenum
ifcmembertypeenum = ENUMERATION('ifcmembertypeenum',
                                'rafter notdefined userdefined arch_segment mullion stiffening_rib post brace suspension_cable stringer member stay_cable purlin collar strut stud suspender chord plate ')

# ENUMERATION TYPE ifcconstraintenum
ifcconstraintenum = ENUMERATION('ifcconstraintenum', 'advisory notdefined userdefined soft hard ')

# ENUMERATION TYPE ifcconstructionequipmentresourcetypeenum
ifcconstructionequipmentresourcetypeenum = ENUMERATION('ifcconstructionequipmentresourcetypeenum',
                                                       'notdefined userdefined heating earthmoving pumping lighting erecting transporting paving demolishing ')

# ENUMERATION TYPE ifclayersetdirectionenum
ifclayersetdirectionenum = ENUMERATION('ifclayersetdirectionenum', 'axis3 axis2 axis1 ')

# ENUMERATION TYPE ifcproceduretypeenum
ifcproceduretypeenum = ENUMERATION('ifcproceduretypeenum',
                                   'calibration notdefined userdefined shutdown advice_caution advice_note startup diagnostic advice_warning ')

# ENUMERATION TYPE ifctransformertypeenum
ifctransformertypeenum = ENUMERATION('ifctransformertypeenum',
                                     'notdefined userdefined voltage rectifier frequency current inverter ')

# ENUMERATION TYPE ifcsiunitname
ifcsiunitname = ENUMERATION('ifcsiunitname',
                            'hertz coulomb degree_celsius steradian siemens lux sievert watt cubic_metre ohm second pascal henry tesla volt joule kelvin ampere gram lumen mole gray square_metre candela farad radian newton becquerel metre weber ')

# ENUMERATION TYPE ifctubebundletypeenum
ifctubebundletypeenum = ENUMERATION('ifctubebundletypeenum', 'notdefined userdefined finned ')

# ENUMERATION TYPE ifcprojectordertypeenum
ifcprojectordertypeenum = ENUMERATION('ifcprojectordertypeenum',
                                      'notdefined userdefined changeorder workorder moveorder purchaseorder maintenanceworkorder ')

# ENUMERATION TYPE ifchumidifiertypeenum
ifchumidifiertypeenum = ENUMERATION('ifchumidifiertypeenum',
                                    'adiabaticairwasher adiabaticcompressedairnozzle notdefined userdefined assistednaturalgas steaminjection adiabaticrigidmedia adiabaticatomizing adiabaticpan adiabaticultrasonic assistedpropane assistedbutane assistedelectric assistedsteam adiabaticwettedelement ')

# ENUMERATION TYPE ifctrimmingpreference
ifctrimmingpreference = ENUMERATION('ifctrimmingpreference', 'parameter unspecified cartesian ')
# SELECT TYPE ifcmodulusoftranslationalsubgradereactionselect
ifcmodulusoftranslationalsubgradereactionselect = SELECT(
    'ifcboolean',
    'ifcmodulusoflinearsubgradereactionmeasure',
    scope=schema_scope)
# SELECT TYPE ifctranslationalstiffnessselect
ifctranslationalstiffnessselect = SELECT(
    'ifcboolean',
    'ifclinearstiffnessmeasure',
    scope=schema_scope)

# ENUMERATION TYPE ifcbooleanoperator
ifcbooleanoperator = ENUMERATION('ifcbooleanoperator', 'difference intersection union ')

# ENUMERATION TYPE ifcnullstyle
ifcnullstyle = ENUMERATION('ifcnullstyle', 'null ')
# SELECT TYPE ifcwarpingstiffnessselect
ifcwarpingstiffnessselect = SELECT(
    'ifcboolean',
    'ifcwarpingmomentmeasure',
    scope=schema_scope)

# ENUMERATION TYPE ifcpiletypeenum
ifcpiletypeenum = ENUMERATION('ifcpiletypeenum',
                              'cohesion notdefined userdefined driven friction jetgrouting support bored ')

# ENUMERATION TYPE ifcpumptypeenum
ifcpumptypeenum = ENUMERATION('ifcpumptypeenum',
                              'notdefined userdefined verticalinline circulator verticalturbine sumppump splitcase endsuction submersiblepump ')

# ENUMERATION TYPE ifctasktypeenum
ifctasktypeenum = ENUMERATION('ifctasktypeenum',
                              'notdefined userdefined move removal operation maintenance demolition dismantle renovation logistic construction installation disposal attendance ')
# SELECT TYPE ifcclassificationreferenceselect
ifcclassificationreferenceselect = SELECT(
    'ifcclassification',
    'ifcclassificationreference',
    scope=schema_scope)

# ENUMERATION TYPE ifcworkscheduletypeenum
ifcworkscheduletypeenum = ENUMERATION('ifcworkscheduletypeenum', 'notdefined userdefined actual planned baseline ')
# SELECT TYPE ifcbooleanoperand
ifcbooleanoperand = SELECT(
    'ifcbooleanresult',
    'ifccsgprimitive3d',
    'ifchalfspacesolid',
    'ifcsolidmodel',
    'ifctessellatedfaceset',
    scope=schema_scope)

# ENUMERATION TYPE ifcactionsourcetypeenum
ifcactionsourcetypeenum = ENUMERATION('ifcactionsourcetypeenum',
                                      'brakes propping notdefined wind_w userdefined earthquake_e shrinkage erection buoyancy settlement_u creep current ice snow_s dead_load_g temperature_t fire impact lack_of_fit prestressing_p impulse system_imperfection rain completion_g1 live_load_q wave transport ')

# ENUMERATION TYPE ifcbeamtypeenum
ifcbeamtypeenum = ENUMERATION('ifcbeamtypeenum',
                              'piercap notdefined userdefined edgebeam diaphragm hatstone joist lintel girder_segment spandrel cornice t_beam hollowcore beam ')

# ENUMERATION TYPE ifcdocumentconfidentialityenum
ifcdocumentconfidentialityenum = ENUMERATION('ifcdocumentconfidentialityenum',
                                             'restricted notdefined userdefined personal confidential public ')

# ENUMERATION TYPE ifcvibrationisolatortypeenum
ifcvibrationisolatortypeenum = ENUMERATION('ifcvibrationisolatortypeenum',
                                           'notdefined userdefined compression spring base ')

# ENUMERATION TYPE ifcelectrictimecontroltypeenum
ifcelectrictimecontroltypeenum = ENUMERATION('ifcelectrictimecontroltypeenum',
                                             'notdefined userdefined timedelay timeclock relay ')

# ENUMERATION TYPE ifcreflectancemethodenum
ifcreflectancemethodenum = ENUMERATION('ifcreflectancemethodenum',
                                       'glass notdefined flat strauss matt plastic phong mirror metal blinn ')
# SELECT TYPE ifcstyleassignmentselect
ifcstyleassignmentselect = SELECT(
    'ifcpresentationstyle',
    'ifcpresentationstyleassignment',
    scope=schema_scope)

# ENUMERATION TYPE ifcfootingtypeenum
ifcfootingtypeenum = ENUMERATION('ifcfootingtypeenum',
                                 'notdefined userdefined caisson_foundation footing_beam pile_cap pad_footing strip_footing ')

# ENUMERATION TYPE ifcdoorpanelpositionenum
ifcdoorpanelpositionenum = ENUMERATION('ifcdoorpanelpositionenum', 'notdefined middle right left ')

# ENUMERATION TYPE ifcbridgetypeenum
ifcbridgetypeenum = ENUMERATION('ifcbridgetypeenum',
                                'arched framework notdefined userdefined culvert suspension girder truss cantilever cable_stayed ')
# SELECT TYPE ifcaxis2placement
ifcaxis2placement = SELECT(
    'ifcaxis2placement2d',
    'ifcaxis2placement3d',
    scope=schema_scope)

# ENUMERATION TYPE ifcsurfacefeaturetypeenum
ifcsurfacefeaturetypeenum = ENUMERATION('ifcsurfacefeaturetypeenum',
                                        'notdefined userdefined mark tag defect treatment ')
# SELECT TYPE ifcprocessselect
ifcprocessselect = SELECT(
    'ifcprocess',
    'ifctypeprocess',
    scope=schema_scope)

# ENUMERATION TYPE ifcstructuralsurfaceactivitytypeenum
ifcstructuralsurfaceactivitytypeenum = ENUMERATION('ifcstructuralsurfaceactivitytypeenum',
                                                   'bilinear notdefined userdefined isocontour const discrete ')

# ENUMERATION TYPE ifcsequenceenum
ifcsequenceenum = ENUMERATION('ifcsequenceenum',
                              'notdefined userdefined finish_start start_finish finish_finish start_start ')

# ENUMERATION TYPE ifcbridgeparttypeenum
ifcbridgeparttypeenum = ENUMERATION('ifcbridgeparttypeenum',
                                    'pier notdefined userdefined superstructure surfacestructure foundation pylon abutment pier_segment substructure deck_segment deck ')
# SELECT TYPE ifctrimmingselect
ifctrimmingselect = SELECT(
    'ifccartesianpoint',
    'ifcparametervalue',
    scope=schema_scope)

# ENUMERATION TYPE ifcdoorpaneloperationenum
ifcdoorpaneloperationenum = ENUMERATION('ifcdoorpaneloperationenum',
                                        'notdefined userdefined folding double_acting revolving sliding rollingup swinging fixedpanel ')

# ENUMERATION TYPE ifcphysicalorvirtualenum
ifcphysicalorvirtualenum = ENUMERATION('ifcphysicalorvirtualenum', 'notdefined physical virtual ')
# SELECT TYPE ifcsolidorshell
ifcsolidorshell = SELECT(
    'ifcclosedshell',
    'ifcsolidmodel',
    scope=schema_scope)

# ENUMERATION TYPE ifcstackterminaltypeenum
ifcstackterminaltypeenum = ENUMERATION('ifcstackterminaltypeenum',
                                       'notdefined userdefined rainwaterhopper birdcage cowl ')

# ENUMERATION TYPE ifcconstructionmaterialresourcetypeenum
ifcconstructionmaterialresourcetypeenum = ENUMERATION('ifcconstructionmaterialresourcetypeenum',
                                                      'notdefined userdefined drywall gypsum fuel plastic aggregates wood concrete masonry metal ')

# ENUMERATION TYPE ifcexternalspatialelementtypeenum
ifcexternalspatialelementtypeenum = ENUMERATION('ifcexternalspatialelementtypeenum',
                                                'notdefined userdefined external_earth external external_water external_fire ')

# ENUMERATION TYPE ifcheatexchangertypeenum
ifcheatexchangertypeenum = ENUMERATION('ifcheatexchangertypeenum', 'notdefined userdefined plate shellandtube ')

# ENUMERATION TYPE ifcactuatortypeenum
ifcactuatortypeenum = ENUMERATION('ifcactuatortypeenum',
                                  'pneumaticactuator notdefined userdefined electricactuator handoperatedactuator thermostaticactuator hydraulicactuator ')

# ENUMERATION TYPE ifcdistributionsystemenum
ifcdistributionsystemenum = ENUMERATION('ifcdistributionsystemenum',
                                        'hazardous vent security notdefined userdefined gas heating exhaust domestichotwater conveying telephone wastewater condenserwater fuel municipalsolidwaste communication control powergeneration chilledwater tv audiovisual refrigeration lighting signal sewage airconditioning data ventilation lightningprotection oil electroacoustic fireprotection watersupply vacuum electrical earthing drainage stormwater domesticcoldwater disposal chemical compressedair operational rainwater ')

# ENUMERATION TYPE ifcsanitaryterminaltypeenum
ifcsanitaryterminaltypeenum = ENUMERATION('ifcsanitaryterminaltypeenum',
                                          'bath wcseat notdefined userdefined bidet sink urinal washhandbasin cistern shower sanitaryfountain toiletpan ')
# SELECT TYPE ifcsurfaceorfacesurface
ifcsurfaceorfacesurface = SELECT(
    'ifcfacebasedsurfacemodel',
    'ifcfacesurface',
    'ifcsurface',
    scope=schema_scope)

# ENUMERATION TYPE ifcmotorconnectiontypeenum
ifcmotorconnectiontypeenum = ENUMERATION('ifcmotorconnectiontypeenum',
                                         'notdefined userdefined directdrive beltdrive coupling ')
# SELECT TYPE ifccurvestylefontselect
ifccurvestylefontselect = SELECT(
    'ifccurvestylefont',
    'ifcpredefinedcurvefont',
    scope=schema_scope)

# ENUMERATION TYPE ifcairterminalboxtypeenum
ifcairterminalboxtypeenum = ENUMERATION('ifcairterminalboxtypeenum',
                                        'notdefined userdefined variableflowpressureindependant variableflowpressuredependant constantflow ')
# SELECT TYPE ifclibraryselect
ifclibraryselect = SELECT(
    'ifclibraryinformation',
    'ifclibraryreference',
    scope=schema_scope)

# ENUMERATION TYPE ifcprojectedortruelengthenum
ifcprojectedortruelengthenum = ENUMERATION('ifcprojectedortruelengthenum', 'true_length projected_length ')

# ENUMERATION TYPE ifcwindowtypepartitioningenum
ifcwindowtypepartitioningenum = ENUMERATION('ifcwindowtypepartitioningenum',
                                            'double_panel_vertical notdefined userdefined triple_panel_bottom triple_panel_horizontal triple_panel_top single_panel triple_panel_right triple_panel_left triple_panel_vertical double_panel_horizontal ')
# SELECT TYPE ifcactorselect
ifcactorselect = SELECT(
    'ifcorganization',
    'ifcperson',
    'ifcpersonandorganization',
    scope=schema_scope)

# ENUMERATION TYPE ifcwindowstyleconstructionenum
ifcwindowstyleconstructionenum = ENUMERATION('ifcwindowstyleconstructionenum',
                                             'notdefined plastic high_grade_steel wood aluminium_wood other_construction aluminium steel ')
# SELECT TYPE ifctextfontselect
ifctextfontselect = SELECT(
    'ifcexternallydefinedtextfont',
    'ifcpredefinedtextfont',
    scope=schema_scope)

# ENUMERATION TYPE ifcdistributionchamberelementtypeenum
ifcdistributionchamberelementtypeenum = ENUMERATION('ifcdistributionchamberelementtypeenum',
                                                    'notdefined userdefined inspectionchamber manhole sump formedduct inspectionpit valvechamber trench meterchamber ')

# ENUMERATION TYPE ifcgeographicelementtypeenum
ifcgeographicelementtypeenum = ENUMERATION('ifcgeographicelementtypeenum',
                                           'notdefined userdefined soil_boring_point terrain ')
# SELECT TYPE ifcbendingparameterselect
ifcbendingparameterselect = SELECT(
    'ifclengthmeasure',
    'ifcplaneanglemeasure',
    scope=schema_scope)

# ENUMERATION TYPE ifcloadgrouptypeenum
ifcloadgrouptypeenum = ENUMERATION('ifcloadgrouptypeenum',
                                   'notdefined userdefined load_group load_combination load_case ')

# ENUMERATION TYPE ifctransitioncode
ifctransitioncode = ENUMERATION('ifctransitioncode',
                                'contsamegradient continuous discontinuous contsamegradientsamecurvature ')
# SELECT TYPE ifcdocumentselect
ifcdocumentselect = SELECT(
    'ifcdocumentinformation',
    'ifcdocumentreference',
    scope=schema_scope)

# ENUMERATION TYPE ifcrecurrencetypeenum
ifcrecurrencetypeenum = ENUMERATION('ifcrecurrencetypeenum',
                                    'yearly_by_position monthly_by_day_of_month daily yearly_by_day_of_month monthly_by_position weekly by_weekday_count by_day_count ')

# ENUMERATION TYPE ifcsensortypeenum
ifcsensortypeenum = ENUMERATION('ifcsensortypeenum',
                                'radioactivitysensor lightsensor notdefined userdefined frostsensor moisturesensor pressuresensor co2sensor movementsensor gassensor identifiersensor humiditysensor soundsensor levelsensor contactsensor conductancesensor heatsensor windsensor temperaturesensor ionconcentrationsensor phsensor firesensor radiationsensor cosensor flowsensor smokesensor ')

# ENUMERATION TYPE ifcunitaryequipmenttypeenum
ifcunitaryequipmenttypeenum = ENUMERATION('ifcunitaryequipmenttypeenum',
                                          'splitsystem notdefined userdefined airconditioningunit airhandler dehumidifier rooftopunit ')

# ENUMERATION TYPE ifccostitemtypeenum
ifccostitemtypeenum = ENUMERATION('ifccostitemtypeenum', 'notdefined userdefined ')

# ENUMERATION TYPE ifcspaceheatertypeenum
ifcspaceheatertypeenum = ENUMERATION('ifcspaceheatertypeenum', 'notdefined userdefined radiator convector ')
# SELECT TYPE ifcspaceboundaryselect
ifcspaceboundaryselect = SELECT(
    'ifcexternalspatialelement',
    'ifcspace',
    scope=schema_scope)

# ENUMERATION TYPE ifcpipefittingtypeenum
ifcpipefittingtypeenum = ENUMERATION('ifcpipefittingtypeenum',
                                     'junction notdefined userdefined entry transition bend connector exit obstruction ')

# ENUMERATION TYPE ifccoveringtypeenum
ifccoveringtypeenum = ENUMERATION('ifccoveringtypeenum',
                                  'flooring roofing notdefined userdefined cladding membrane molding wrapping ceiling insulation skirtingboard sleeving coping ')

# ENUMERATION TYPE ifcevaporativecoolertypeenum
ifcevaporativecoolertypeenum = ENUMERATION('ifcevaporativecoolertypeenum',
                                           'notdefined indirectdirectcombination userdefined directevaporativerigidmediaaircooler indirectevaporativepackageaircooler directevaporativerandommediaaircooler indirectevaporativecoolingtowerorcoilcooler directevaporativeairwasher indirectevaporativewetcoil directevaporativeslingerspackagedaircooler directevaporativepackagedrotaryaircooler ')

# ENUMERATION TYPE ifcwindowstyleoperationenum
ifcwindowstyleoperationenum = ENUMERATION('ifcwindowstyleoperationenum',
                                          'double_panel_vertical notdefined userdefined triple_panel_bottom triple_panel_horizontal triple_panel_top single_panel triple_panel_right triple_panel_left triple_panel_vertical double_panel_horizontal ')

# ENUMERATION TYPE ifcslabtypeenum
ifcslabtypeenum = ENUMERATION('ifcslabtypeenum',
                              'approach_slab notdefined userdefined floor sidewalk paving landing roof baseslab wearing ')

# ENUMERATION TYPE ifcdistributionporttypeenum
ifcdistributionporttypeenum = ENUMERATION('ifcdistributionporttypeenum',
                                          'notdefined userdefined duct pipe cablecarrier cable ')

# ENUMERATION TYPE ifclaborresourcetypeenum
ifclaborresourcetypeenum = ENUMERATION('ifclaborresourcetypeenum',
                                       'flooring roofing electric notdefined userdefined cleaning drywall hvac finishing surveying administration general plumbing carpentry landscaping paving steelwork concrete sitegrading masonry painting ')

# ENUMERATION TYPE ifcvalvetypeenum
ifcvalvetypeenum = ENUMERATION('ifcvalvetypeenum',
                               'pressurerelief doublecheck notdefined userdefined antivacuum changeover pressurereducing gascock mixing check doubleregulating steamtrap airrelease safetycutoff regulating drawoffcock faucet gastap commissioning stopcock flushing diverting isolating ')

# ENUMERATION TYPE ifcderivedunitenum
ifcderivedunitenum = ENUMERATION('ifcderivedunitenum',
                                 'momentofinertiaunit moisturediffusivityunit modulusofrotationalsubgradereactionunit rotationalstiffnessunit compoundplaneangleunit userdefined ionconcentrationunit massdensityunit sectionmodulusunit modulusofelasticityunit kinematicviscosityunit isothermalmoisturecapacityunit linearvelocityunit heatingvalueunit integercountrateunit soundpowerlevelunit linearforceunit rotationalmassunit rotationalfrequencyunit torqueunit sectionareaintegralunit planarforceunit warpingmomentunit thermalexpansioncoefficientunit linearmomentunit soundpressureunit areadensityunit vaporpermeabilityunit accelerationunit thermaltransmittanceunit modulusoflinearsubgradereactionunit specificheatcapacityunit temperaturegradientunit thermalconductanceunit luminousintensitydistributionunit shearmodulusunit thermaladmittanceunit heatfluxdensityunit modulusofsubgradereactionunit thermalresistanceunit volumetricflowrateunit phunit massflowrateunit linearstiffnessunit soundpressurelevelunit massperlengthunit angularvelocityunit warpingconstantunit soundpowerunit temperaturerateofchangeunit dynamicviscosityunit curvatureunit molecularweightunit ')

# ENUMERATION TYPE ifccompressortypeenum
ifccompressortypeenum = ENUMERATION('ifccompressortypeenum',
                                    'twinscrew notdefined userdefined weldedshellhermetic opentype singlestage semihermetic reciprocating dynamic scroll hermetic singlescrew trochoidal rotary rollingpiston rotaryvane booster ')

# ENUMERATION TYPE ifcobjecttypeenum
ifcobjecttypeenum = ENUMERATION('ifcobjecttypeenum', 'actor notdefined group control resource product process project ')

# ENUMERATION TYPE ifcmedicaldevicetypeenum
ifcmedicaldevicetypeenum = ENUMERATION('ifcmedicaldevicetypeenum',
                                       'notdefined userdefined vacuumstation oxygengenerator airstation oxygenplant feedairunit ')

# ENUMERATION TYPE ifcswitchingdevicetypeenum
ifcswitchingdevicetypeenum = ENUMERATION('ifcswitchingdevicetypeenum',
                                         'dimmerswitch notdefined userdefined contactor selectorswitch starter momentaryswitch switchdisconnector emergencystop toggleswitch keypad ')
# SELECT TYPE ifcmaterialselect
ifcmaterialselect = SELECT(
    'ifcmaterialdefinition',
    'ifcmateriallist',
    'ifcmaterialusagedefinition',
    scope=schema_scope)

# ENUMERATION TYPE ifcrooftypeenum
ifcrooftypeenum = ENUMERATION('ifcrooftypeenum',
                              'dome_roof freeform notdefined flat_roof gable_roof userdefined hipped_gable_roof butterfly_roof hip_roof rainbow_roof barrel_roof pavilion_roof shed_roof mansard_roof gambrel_roof ')

# ENUMERATION TYPE ifcbuildingsystemtypeenum
ifcbuildingsystemtypeenum = ENUMERATION('ifcbuildingsystemtypeenum',
                                        'reinforcing notdefined userdefined prestressing fenestration foundation shading outershell loadbearing transport ')

# ENUMERATION TYPE ifccablecarrierfittingtypeenum
ifccablecarrierfittingtypeenum = ENUMERATION('ifccablecarrierfittingtypeenum',
                                             'reducer notdefined userdefined tee cross bend ')

# ENUMERATION TYPE ifccrewresourcetypeenum
ifccrewresourcetypeenum = ENUMERATION('ifccrewresourcetypeenum', 'notdefined userdefined site office ')
# SELECT TYPE ifcgeometricsetselect
ifcgeometricsetselect = SELECT(
    'ifccurve',
    'ifcpoint',
    'ifcsurface',
    scope=schema_scope)
# SELECT TYPE ifcspecularhighlightselect
ifcspecularhighlightselect = SELECT(
    'ifcspecularexponent',
    'ifcspecularroughness',
    scope=schema_scope)

# ENUMERATION TYPE ifcanalysistheorytypeenum
ifcanalysistheorytypeenum = ENUMERATION('ifcanalysistheorytypeenum',
                                        'full_nonlinear_theory notdefined userdefined first_order_theory third_order_theory second_order_theory ')

# ENUMERATION TYPE ifcelectricdistributionboardtypeenum
ifcelectricdistributionboardtypeenum = ENUMERATION('ifcelectricdistributionboardtypeenum',
                                                   'notdefined userdefined switchboard consumerunit distributionboard motorcontrolcentre ')

# ENUMERATION TYPE ifcperformancehistorytypeenum
ifcperformancehistorytypeenum = ENUMERATION('ifcperformancehistorytypeenum', 'notdefined userdefined ')

# ENUMERATION TYPE ifcoutlettypeenum
ifcoutlettypeenum = ENUMERATION('ifcoutlettypeenum',
                                'dataoutlet notdefined userdefined audiovisualoutlet telephoneoutlet poweroutlet communicationsoutlet ')

# ENUMERATION TYPE ifcinterceptortypeenum
ifcinterceptortypeenum = ENUMERATION('ifcinterceptortypeenum', 'grease notdefined userdefined cyclonic oil petrol ')
ifcpropertysetdefinitionset = SET(1, None, 'ifcpropertysetdefinition', scope=schema_scope)

# ENUMERATION TYPE ifcstructuralcurveactivitytypeenum
ifcstructuralcurveactivitytypeenum = ENUMERATION('ifcstructuralcurveactivitytypeenum',
                                                 'notdefined userdefined sinus parabola equidistant linear polygonal const discrete ')

# ENUMERATION TYPE ifcprotectivedevicetrippingunittypeenum
ifcprotectivedevicetrippingunittypeenum = ENUMERATION('ifcprotectivedevicetrippingunittypeenum',
                                                      'notdefined userdefined residualcurrent electromagnetic electronic thermal ')
# SELECT TYPE ifccurveoredgecurve
ifccurveoredgecurve = SELECT(
    'ifcboundedcurve',
    'ifcedgecurve',
    scope=schema_scope)
# SELECT TYPE ifcmodulusofrotationalsubgradereactionselect
ifcmodulusofrotationalsubgradereactionselect = SELECT(
    'ifcboolean',
    'ifcmodulusofrotationalsubgradereactionmeasure',
    scope=schema_scope)

# ENUMERATION TYPE ifctimeseriesdatatypeenum
ifctimeseriesdatatypeenum = ENUMERATION('ifctimeseriesdatatypeenum',
                                        'notdefined piecewisebinary piecewisecontinuous piecewiseconstant discretebinary continuous discrete ')

# ENUMERATION TYPE ifcbuildingelementparttypeenum
ifcbuildingelementparttypeenum = ENUMERATION('ifcbuildingelementparttypeenum',
                                             'notdefined userdefined precastpanel apron insulation ')

# ENUMERATION TYPE ifccoolingtowertypeenum
ifccoolingtowertypeenum = ENUMERATION('ifccoolingtowertypeenum',
                                      'notdefined userdefined mechanicalforceddraft mechanicalinduceddraft naturaldraft ')

# ENUMERATION TYPE ifcchillertypeenum
ifcchillertypeenum = ENUMERATION('ifcchillertypeenum', 'notdefined userdefined aircooled heatrecovery watercooled ')

# ENUMERATION TYPE ifcfastenertypeenum
ifcfastenertypeenum = ENUMERATION('ifcfastenertypeenum', 'weld notdefined userdefined glue mortar ')

# ENUMERATION TYPE ifcpipesegmenttypeenum
ifcpipesegmenttypeenum = ENUMERATION('ifcpipesegmenttypeenum',
                                     'notdefined userdefined culvert flexiblesegment rigidsegment gutter spool ')

# ENUMERATION TYPE ifcbuildingelementproxytypeenum
ifcbuildingelementproxytypeenum = ENUMERATION('ifcbuildingelementproxytypeenum',
                                              'notdefined userdefined complex provisionforvoid element provisionforspace partial ')

# ENUMERATION TYPE ifccomplexpropertytemplatetypeenum
ifccomplexpropertytemplatetypeenum = ENUMERATION('ifccomplexpropertytemplatetypeenum', 'p_complex q_complex ')

# ENUMERATION TYPE ifcairterminaltypeenum
ifcairterminaltypeenum = ENUMERATION('ifcairterminaltypeenum',
                                     'notdefined userdefined grille register louvre diffuser ')

# ENUMERATION TYPE ifcanalysismodeltypeenum
ifcanalysismodeltypeenum = ENUMERATION('ifcanalysismodeltypeenum',
                                       'in_plane_loading_2d notdefined userdefined out_plane_loading_2d loading_3d ')

# ENUMERATION TYPE ifcwindowpanelpositionenum
ifcwindowpanelpositionenum = ENUMERATION('ifcwindowpanelpositionenum', 'notdefined middle right top bottom left ')
# SELECT TYPE ifcsimplevalue
ifcsimplevalue = SELECT(
    'ifcbinary',
    'ifcboolean',
    'ifcdate',
    'ifcdatetime',
    'ifcduration',
    'ifcidentifier',
    'ifcinteger',
    'ifclabel',
    'ifclogical',
    'ifcpositiveinteger',
    'ifcreal',
    'ifctext',
    'ifctime',
    'ifctimestamp',
    scope=schema_scope)

# ENUMERATION TYPE ifcrailingtypeenum
ifcrailingtypeenum = ENUMERATION('ifcrailingtypeenum', 'notdefined userdefined balustrade guardrail handrail ')
# SELECT TYPE ifcappliedvalueselect
ifcappliedvalueselect = SELECT(
    'ifcmeasurewithunit',
    'ifcreference',
    'ifcvalue',
    scope=schema_scope)

# ENUMERATION TYPE ifcaudiovisualappliancetypeenum
ifcaudiovisualappliancetypeenum = ENUMERATION('ifcaudiovisualappliancetypeenum',
                                              'receiver tuner notdefined switcher userdefined telephone amplifier camera microphone projector display player speaker ')

# ENUMERATION TYPE ifcstructuralcurvemembertypeenum
ifcstructuralcurvemembertypeenum = ENUMERATION('ifcstructuralcurvemembertypeenum',
                                               'compression_member notdefined userdefined rigid_joined_member pin_joined_member tension_member cable ')

# ENUMERATION TYPE ifcstairtypeenum
ifcstairtypeenum = ENUMERATION('ifcstairtypeenum',
                               'three_quarter_turn_stair half_turn_stair notdefined half_winding_stair userdefined two_straight_run_stair two_quarter_turn_stair curved_run_stair three_quarter_winding_stair two_quarter_winding_stair straight_run_stair quarter_turn_stair quarter_winding_stair double_return_stair spiral_stair two_curved_run_stair ')

# ENUMERATION TYPE ifclightemissionsourceenum
ifclightemissionsourceenum = ENUMERATION('ifclightemissionsourceenum',
                                         'metalhalide notdefined highpressuresodium fluorescent lightemittingdiode compactfluorescent lowvoltagehalogen tungstenfilament mainvoltagehalogen highpressuremercury lowpressuresodium ')

# ENUMERATION TYPE ifcsurfaceside
ifcsurfaceside = ENUMERATION('ifcsurfaceside', 'negative both positive ')

# ENUMERATION TYPE ifcfiltertypeenum
ifcfiltertypeenum = ENUMERATION('ifcfiltertypeenum',
                                'compressedairfilter notdefined airparticlefilter userdefined waterfilter odorfilter strainer oilfilter ')

# ENUMERATION TYPE ifcdoorstyleoperationenum
ifcdoorstyleoperationenum = ENUMERATION('ifcdoorstyleoperationenum',
                                        'double_door_folding double_door_single_swing notdefined userdefined double_door_single_swing_opposite_left sliding_to_right double_swing_left sliding_to_left folding_to_left revolving single_swing_left rollingup double_door_single_swing_opposite_right single_swing_right double_door_double_swing double_door_sliding double_swing_right folding_to_right ')

# ENUMERATION TYPE ifcactiontypeenum
ifcactiontypeenum = ENUMERATION('ifcactiontypeenum', 'notdefined userdefined variable_q permanent_g extraordinary_a ')

# ENUMERATION TYPE ifcductsegmenttypeenum
ifcductsegmenttypeenum = ENUMERATION('ifcductsegmenttypeenum', 'notdefined userdefined flexiblesegment rigidsegment ')
# SELECT TYPE ifccolour
ifccolour = SELECT(
    'ifccolourspecification',
    'ifcpredefinedcolour',
    scope=schema_scope)
# SELECT TYPE ifclayereditem
ifclayereditem = SELECT(
    'ifcrepresentation',
    'ifcrepresentationitem',
    scope=schema_scope)

# ENUMERATION TYPE ifcworkcalendartypeenum
ifcworkcalendartypeenum = ENUMERATION('ifcworkcalendartypeenum',
                                      'notdefined userdefined thirdshift firstshift secondshift ')

# ENUMERATION TYPE ifcelectricflowstoragedevicetypeenum
ifcelectricflowstoragedevicetypeenum = ENUMERATION('ifcelectricflowstoragedevicetypeenum',
                                                   'harmonicfilter notdefined userdefined inductorbank battery ups capacitorbank ')

# ENUMERATION TYPE ifcelectricmotortypeenum
ifcelectricmotortypeenum = ENUMERATION('ifcelectricmotortypeenum',
                                       'synchronous notdefined userdefined reluctancesynchronous induction polyphase dc ')

# ENUMERATION TYPE ifccondensertypeenum
ifccondensertypeenum = ENUMERATION('ifccondensertypeenum',
                                   'notdefined userdefined watercooledshellcoil evaporativecooled watercooledtubeintube aircooled watercooled watercooledbrazedplate watercooledshelltube ')

# ENUMERATION TYPE ifceventtriggertypeenum
ifceventtriggertypeenum = ENUMERATION('ifceventtriggertypeenum',
                                      'notdefined userdefined eventtime eventmessage eventcomplex eventrule ')

# ENUMERATION TYPE ifcpermittypeenum
ifcpermittypeenum = ENUMERATION('ifcpermittypeenum', 'notdefined userdefined building access work ')

# ENUMERATION TYPE ifcplatetypeenum
ifcplatetypeenum = ENUMERATION('ifcplatetypeenum',
                               'gusset_plate stiffener_plate notdefined userdefined sheet flange_plate curtain_panel splice_plate cover_plate web_plate base_plate ')

# ENUMERATION TYPE ifccostscheduletypeenum
ifccostscheduletypeenum = ENUMERATION('ifccostscheduletypeenum',
                                      'notdefined userdefined budget costplan estimate scheduleofrates unpricedbillofquantities pricedbillofquantities tender ')
# SELECT TYPE ifccsgselect
ifccsgselect = SELECT(
    'ifcbooleanresult',
    'ifccsgprimitive3d',
    scope=schema_scope)

# ENUMERATION TYPE ifctextpath
ifctextpath = ENUMERATION('ifctextpath', 'up right down left ')

# ENUMERATION TYPE ifcflowmetertypeenum
ifcflowmetertypeenum = ENUMERATION('ifcflowmetertypeenum',
                                   'notdefined userdefined gasmeter watermeter energymeter oilmeter ')

# ENUMERATION TYPE ifcjunctionboxtypeenum
ifcjunctionboxtypeenum = ENUMERATION('ifcjunctionboxtypeenum', 'power notdefined userdefined data ')

# ENUMERATION TYPE ifcstateenum
ifcstateenum = ENUMERATION('ifcstateenum', 'readwrite readwritelocked locked readonlylocked readonly ')

# ENUMERATION TYPE ifctanktypeenum
ifctanktypeenum = ENUMERATION('ifctanktypeenum',
                              'expansion breakpressure feedandexpansion pressurevessel notdefined userdefined vessel storage basin ')
# SELECT TYPE ifcproductrepresentationselect
ifcproductrepresentationselect = SELECT(
    'ifcproductdefinitionshape',
    'ifcrepresentationmap',
    scope=schema_scope)

# ENUMERATION TYPE ifcchangeactionenum
ifcchangeactionenum = ENUMERATION('ifcchangeactionenum', 'added notdefined modified deleted nochange ')

# ENUMERATION TYPE ifcgeometricprojectionenum
ifcgeometricprojectionenum = ENUMERATION('ifcgeometricprojectionenum',
                                         'reflected_plan_view notdefined userdefined elevation_view section_view plan_view graph_view model_view sketch_view ')

# ENUMERATION TYPE ifcaddresstypeenum
ifcaddresstypeenum = ENUMERATION('ifcaddresstypeenum', 'home userdefined site office distributionpoint ')

# ENUMERATION TYPE ifcopeningelementtypeenum
ifcopeningelementtypeenum = ENUMERATION('ifcopeningelementtypeenum', 'notdefined userdefined opening recess ')

# ENUMERATION TYPE ifcdoorstyleconstructionenum
ifcdoorstyleconstructionenum = ENUMERATION('ifcdoorstyleconstructionenum',
                                           'notdefined userdefined plastic high_grade_steel wood aluminium_wood aluminium_plastic aluminium steel ')
# SELECT TYPE ifchatchlinedistanceselect
ifchatchlinedistanceselect = SELECT(
    'ifcpositivelengthmeasure',
    'ifcvector',
    scope=schema_scope)

# ENUMERATION TYPE ifcunitarycontrolelementtypeenum
ifcunitarycontrolelementtypeenum = ENUMERATION('ifcunitarycontrolelementtypeenum',
                                               'notdefined userdefined indicatorpanel controlpanel mimicpanel alarmpanel weatherstation gasdetectionpanel thermostat humidistat ')

# ENUMERATION TYPE ifccablesegmenttypeenum
ifccablesegmenttypeenum = ENUMERATION('ifccablesegmenttypeenum',
                                      'notdefined userdefined cablesegment conductorsegment coresegment busbarsegment ')

# ENUMERATION TYPE ifcfantypeenum
ifcfantypeenum = ENUMERATION('ifcfantypeenum',
                             'notdefined userdefined centrifugalforwardcurved tubeaxial centrifugalairfoil centrifugalradial vaneaxial propelloraxial centrifugalbackwardinclinedcurved ')
# SELECT TYPE ifcmodulusofsubgradereactionselect
ifcmodulusofsubgradereactionselect = SELECT(
    'ifcboolean',
    'ifcmodulusofsubgradereactionmeasure',
    scope=schema_scope)

# ENUMERATION TYPE ifcenginetypeenum
ifcenginetypeenum = ENUMERATION('ifcenginetypeenum', 'internalcombustion notdefined userdefined externalcombustion ')

# ENUMERATION TYPE ifcspatialzonetypeenum
ifcspatialzonetypeenum = ENUMERATION('ifcspatialzonetypeenum',
                                     'security notdefined userdefined occupancy firesafety thermal lighting construction ventilation transport ')

# ENUMERATION TYPE ifcelementassemblytypeenum
ifcelementassemblytypeenum = ENUMERATION('ifcelementassemblytypeenum',
                                         'slab_field pier notdefined userdefined arch accessory_assembly rigid_frame reinforcement_unit girder truss pylon beam_grid cross_bracing abutment braced_frame deck ')

# ENUMERATION TYPE ifcgridtypeenum
ifcgridtypeenum = ENUMERATION('ifcgridtypeenum', 'notdefined userdefined rectangular triangular irregular radial ')
# SELECT TYPE ifcpointorvertexpoint
ifcpointorvertexpoint = SELECT(
    'ifcpoint',
    'ifcvertexpoint',
    scope=schema_scope)

# ENUMERATION TYPE ifcknottype
ifcknottype = ENUMERATION('ifcknottype', 'piecewise_bezier_knots uniform_knots quasi_uniform_knots unspecified ')
ifccomplexnumber = ARRAY(1, 2, 'REAL', scope=schema_scope)

# ENUMERATION TYPE ifcunitenum
ifcunitenum = ENUMERATION('ifcunitenum',
                          'illuminanceunit electricresistanceunit magneticfluxdensityunit userdefined pressureunit electricconductanceunit energyunit thermodynamictemperatureunit electricchargeunit solidangleunit electriccurrentunit massunit powerunit luminousintensityunit electriccapacitanceunit frequencyunit inductanceunit luminousfluxunit absorbeddoseunit planeangleunit timeunit radioactivityunit amountofsubstanceunit lengthunit magneticfluxunit volumeunit doseequivalentunit areaunit electricvoltageunit forceunit ')

# ENUMERATION TYPE ifcvibrationdampertypeenum
ifcvibrationdampertypeenum = ENUMERATION('ifcvibrationdampertypeenum',
                                         'bending_yield axial_yield notdefined userdefined shear_yield friction viscous rubber ')

# ENUMERATION TYPE ifccurtainwalltypeenum
ifccurtainwalltypeenum = ENUMERATION('ifccurtainwalltypeenum', 'notdefined userdefined ')

# ENUMERATION TYPE ifcdocumentstatusenum
ifcdocumentstatusenum = ENUMERATION('ifcdocumentstatusenum', 'notdefined draft revision finaldraft final ')

# ENUMERATION TYPE ifcstairflighttypeenum
ifcstairflighttypeenum = ENUMERATION('ifcstairflighttypeenum',
                                     'freeform notdefined userdefined curved winder spiral straight ')
# SELECT TYPE ifcfillstyleselect
ifcfillstyleselect = SELECT(
    'ifccolour',
    'ifcexternallydefinedhatchstyle',
    'ifcfillareastylehatching',
    'ifcfillareastyletiles',
    scope=schema_scope)
# SELECT TYPE ifcsizeselect
ifcsizeselect = SELECT(
    'ifcdescriptivemeasure',
    'ifclengthmeasure',
    'ifcnormalisedratiomeasure',
    'ifcpositivelengthmeasure',
    'ifcpositiveratiomeasure',
    'ifcratiomeasure',
    scope=schema_scope)
ifccompoundplaneanglemeasure = LIST(3, 4, 'INTEGER', scope=schema_scope)

# ENUMERATION TYPE ifcbearingtypeenum
ifcbearingtypeenum = ENUMERATION('ifcbearingtypeenum',
                                 'guide notdefined userdefined rocker roller cylindrical spherical pot elastomeric disk ')

# ENUMERATION TYPE ifcglobalorlocalenum
ifcglobalorlocalenum = ENUMERATION('ifcglobalorlocalenum', 'global_coords local_coords ')

# ENUMERATION TYPE ifcinternalorexternalenum
ifcinternalorexternalenum = ENUMERATION('ifcinternalorexternalenum',
                                        'notdefined internal external_earth external external_water external_fire ')

# ENUMERATION TYPE ifcwalltypeenum
ifcwalltypeenum = ENUMERATION('ifcwalltypeenum',
                              'shear partitioning notdefined userdefined movable elementedwall parapet solidwall plumbingwall polygonal standard retainingwall ')
# SELECT TYPE ifcgridplacementdirectionselect
ifcgridplacementdirectionselect = SELECT(
    'ifcdirection',
    'ifcvirtualgridintersection',
    scope=schema_scope)

# ENUMERATION TYPE ifcburnertypeenum
ifcburnertypeenum = ENUMERATION('ifcburnertypeenum', 'notdefined userdefined ')

# ENUMERATION TYPE ifcoccupanttypeenum
ifcoccupanttypeenum = ENUMERATION('ifcoccupanttypeenum',
                                  'owner notdefined userdefined lettingagent lessee lessor tenant assignee assignor ')

# ENUMERATION TYPE ifcpreferredsurfacecurverepresentation
ifcpreferredsurfacecurverepresentation = ENUMERATION('ifcpreferredsurfacecurverepresentation',
                                                     'curve3d pcurve_s2 pcurve_s1 ')

# ENUMERATION TYPE ifcalarmtypeenum
ifcalarmtypeenum = ENUMERATION('ifcalarmtypeenum',
                               'notdefined userdefined whistle bell breakglassbutton siren light manualpullbox ')

# ENUMERATION TYPE ifccoiltypeenum
ifccoiltypeenum = ENUMERATION('ifccoiltypeenum',
                              'notdefined userdefined watercoolingcoil dxcoolingcoil electricheatingcoil waterheatingcoil hydroniccoil gasheatingcoil steamheatingcoil ')

# ENUMERATION TYPE ifctendontypeenum
ifctendontypeenum = ENUMERATION('ifctendontypeenum', 'bar notdefined userdefined wire coated strand ')

# ENUMERATION TYPE ifcchimneytypeenum
ifcchimneytypeenum = ENUMERATION('ifcchimneytypeenum', 'notdefined userdefined ')

# ENUMERATION TYPE ifccooledbeamtypeenum
ifccooledbeamtypeenum = ENUMERATION('ifccooledbeamtypeenum', 'notdefined userdefined active passive ')

# ENUMERATION TYPE ifccaissonfoundationtypeenum
ifccaissonfoundationtypeenum = ENUMERATION('ifccaissonfoundationtypeenum', 'well notdefined userdefined caisson ')

# ENUMERATION TYPE ifcassemblyplaceenum
ifcassemblyplaceenum = ENUMERATION('ifcassemblyplaceenum', 'notdefined factory site ')

# ENUMERATION TYPE ifcconnectiontypeenum
ifcconnectiontypeenum = ENUMERATION('ifcconnectiontypeenum', 'notdefined atstart atpath atend ')

# ENUMERATION TYPE ifcprofiletypeenum
ifcprofiletypeenum = ENUMERATION('ifcprofiletypeenum', 'curve area ')

# ENUMERATION TYPE ifcreinforcingbarroleenum
ifcreinforcingbarroleenum = ENUMERATION('ifcreinforcingbarroleenum',
                                        'shear main notdefined userdefined edge punching anchoring stud ligature ring ')
# SELECT TYPE ifccurveonsurface
ifccurveonsurface = SELECT(
    'ifccompositecurveonsurface',
    'ifcpcurve',
    'ifcsurfacecurve',
    scope=schema_scope)


####################
# ENTITY ifcrepresentationitem #
####################
class ifcrepresentationitem(BaseEntityClass):
    '''Entity ifcrepresentationitem definition.

	:param layerassignment
	:type layerassignment:SET(0,1,'ifcpresentationlayerassignment', scope = schema_scope)

	:param styledbyitem
	:type styledbyitem:SET(0,1,'ifcstyleditem', scope = schema_scope)
	'''
    # This class does not define any attribute.
    pass

    @property
    def layerassignment(self):
        return self._layerassignment

    @layerassignment.setter
    def layerassignment(self, value):
        # INVERSE argument
        raise AssertionError('Argument layerassignment is INVERSE. It is computed and can not be set to any value')

    @property
    def styledbyitem(self):
        return self._styledbyitem

    @styledbyitem.setter
    def styledbyitem(self, value):
        # INVERSE argument
        raise AssertionError('Argument styledbyitem is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcgeometricrepresentationitem #
####################
class ifcgeometricrepresentationitem(ifcrepresentationitem):
    '''Entity ifcgeometricrepresentationitem definition.
	'''

    def __init__(self, ):
        ifcrepresentationitem.__init__(self, )


####################
# ENTITY ifcalignment2dsegment #
####################
class ifcalignment2dsegment(ifcgeometricrepresentationitem):
    '''Entity ifcalignment2dsegment definition.

	:param tangentialcontinuity
	:type tangentialcontinuity:ifcboolean

	:param starttag
	:type starttag:ifclabel

	:param endtag
	:type endtag:ifclabel
	'''

    def __init__(self, tangentialcontinuity, starttag, endtag, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._tangentialcontinuity = tangentialcontinuity
        self._starttag = starttag
        self._endtag = endtag

    @property
    def tangentialcontinuity(self):
        return self._tangentialcontinuity

    @tangentialcontinuity.setter
    def tangentialcontinuity(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._tangentialcontinuity = ifcboolean(value)
            else:
                self._tangentialcontinuity = value
        else:
            self._tangentialcontinuity = value

    @property
    def starttag(self):
        return self._starttag

    @starttag.setter
    def starttag(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._starttag = ifclabel(value)
            else:
                self._starttag = value
        else:
            self._starttag = value

    @property
    def endtag(self):
        return self._endtag

    @endtag.setter
    def endtag(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._endtag = ifclabel(value)
            else:
                self._endtag = value
        else:
            self._endtag = value


####################
# ENTITY ifcalignment2dhorizontalsegment #
####################
class ifcalignment2dhorizontalsegment(ifcalignment2dsegment):
    '''Entity ifcalignment2dhorizontalsegment definition.

	:param curvegeometry
	:type curvegeometry:ifccurvesegment2d

	:param tohorizontal
	:type tohorizontal:SET(1,1,'ifcalignment2dhorizontal', scope = schema_scope)
	'''

    def __init__(self, inherited0__tangentialcontinuity, inherited1__starttag, inherited2__endtag, curvegeometry, ):
        ifcalignment2dsegment.__init__(self, inherited0__tangentialcontinuity, inherited1__starttag,
                                       inherited2__endtag, )
        self._curvegeometry = curvegeometry

    @property
    def curvegeometry(self):
        return self._curvegeometry

    @curvegeometry.setter
    def curvegeometry(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurvesegment2d):
            self._curvegeometry = ifccurvesegment2d(value)
        else:
            self._curvegeometry = value

    @property
    def tohorizontal(self):
        return self._tohorizontal

    @tohorizontal.setter
    def tohorizontal(self, value):
        # INVERSE argument
        raise AssertionError('Argument tohorizontal is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcnamedunit #
####################
class ifcnamedunit(BaseEntityClass):
    '''Entity ifcnamedunit definition.

	:param dimensions
	:type dimensions:ifcdimensionalexponents

	:param unittype
	:type unittype:ifcunitenum
	'''

    def __init__(self, dimensions, unittype, ):
        self._dimensions = dimensions
        self._unittype = unittype

    @property
    def dimensions(self):
        return self._dimensions

    @dimensions.setter
    def dimensions(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdimensionalexponents):
            self._dimensions = ifcdimensionalexponents(value)
        else:
            self._dimensions = value

    @property
    def unittype(self):
        return self._unittype

    @unittype.setter
    def unittype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcunitenum):
            self._unittype = ifcunitenum(value)
        else:
            self._unittype = value

    def wr1(self):
        eval_wr1_wr = ifccorrectdimensions(self.self.unittype, self.self.dimensions)
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


####################
# ENTITY ifccurve #
####################
class ifccurve(ifcgeometricrepresentationitem):
    '''Entity ifccurve definition.

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, ):
        ifcgeometricrepresentationitem.__init__(self, )

    @property
    def dim(self):
        attribute_eval = ifccurvedim(self)
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcoffsetcurve #
####################
class ifcoffsetcurve(ifccurve):
    '''Entity ifcoffsetcurve definition.

	:param basiscurve
	:type basiscurve:ifccurve
	'''

    def __init__(self, basiscurve, ):
        ifccurve.__init__(self, )
        self._basiscurve = basiscurve

    @property
    def basiscurve(self):
        return self._basiscurve

    @basiscurve.setter
    def basiscurve(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._basiscurve = ifccurve(value)
        else:
            self._basiscurve = value


####################
# ENTITY ifcoffsetcurve2d #
####################
class ifcoffsetcurve2d(ifcoffsetcurve):
    '''Entity ifcoffsetcurve2d definition.

	:param distance
	:type distance:ifclengthmeasure

	:param selfintersect
	:type selfintersect:ifclogical
	'''

    def __init__(self, inherited0__basiscurve, distance, selfintersect, ):
        ifcoffsetcurve.__init__(self, inherited0__basiscurve, )
        self._distance = distance
        self._selfintersect = selfintersect

    @property
    def distance(self):
        return self._distance

    @distance.setter
    def distance(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._distance = ifclengthmeasure(value)
        else:
            self._distance = value

    @property
    def selfintersect(self):
        return self._selfintersect

    @selfintersect.setter
    def selfintersect(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclogical):
            self._selfintersect = ifclogical(value)
        else:
            self._selfintersect = value

    def dimis2d(self):
        eval_dimis2d_wr = (self.basiscurve.self.dim == 2)
        if not eval_dimis2d_wr:
            raise AssertionError('Rule dimis2d violated')
        else:
            return eval_dimis2d_wr


####################
# ENTITY ifcroot #
####################
class ifcroot(BaseEntityClass):
    '''Entity ifcroot definition.

	:param globalid
	:type globalid:ifcgloballyuniqueid

	:param ownerhistory
	:type ownerhistory:ifcownerhistory

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext
	'''

    def __init__(self, globalid, ownerhistory, name, description, ):
        self._globalid = globalid
        self._ownerhistory = ownerhistory
        self._name = name
        self._description = description

    @property
    def globalid(self):
        return self._globalid

    @globalid.setter
    def globalid(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcgloballyuniqueid):
            self._globalid = ifcgloballyuniqueid(value)
        else:
            self._globalid = value

    @property
    def ownerhistory(self):
        return self._ownerhistory

    @ownerhistory.setter
    def ownerhistory(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcownerhistory):
                self._ownerhistory = ifcownerhistory(value)
            else:
                self._ownerhistory = value
        else:
            self._ownerhistory = value

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value


####################
# ENTITY ifcobjectdefinition #
####################
class ifcobjectdefinition(ifcroot):
    '''Entity ifcobjectdefinition definition.

	:param hasassignments
	:type hasassignments:SET(0,None,'ifcrelassigns', scope = schema_scope)

	:param nests
	:type nests:SET(0,1,'ifcrelnests', scope = schema_scope)

	:param isnestedby
	:type isnestedby:SET(0,None,'ifcrelnests', scope = schema_scope)

	:param hascontext
	:type hascontext:SET(0,1,'ifcreldeclares', scope = schema_scope)

	:param isdecomposedby
	:type isdecomposedby:SET(0,None,'ifcrelaggregates', scope = schema_scope)

	:param decomposes
	:type decomposes:SET(0,1,'ifcrelaggregates', scope = schema_scope)

	:param hasassociations
	:type hasassociations:SET(0,None,'ifcrelassociates', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description, ):
        ifcroot.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                         inherited3__description, )

    @property
    def hasassignments(self):
        return self._hasassignments

    @hasassignments.setter
    def hasassignments(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasassignments is INVERSE. It is computed and can not be set to any value')

    @property
    def nests(self):
        return self._nests

    @nests.setter
    def nests(self, value):
        # INVERSE argument
        raise AssertionError('Argument nests is INVERSE. It is computed and can not be set to any value')

    @property
    def isnestedby(self):
        return self._isnestedby

    @isnestedby.setter
    def isnestedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument isnestedby is INVERSE. It is computed and can not be set to any value')

    @property
    def hascontext(self):
        return self._hascontext

    @hascontext.setter
    def hascontext(self, value):
        # INVERSE argument
        raise AssertionError('Argument hascontext is INVERSE. It is computed and can not be set to any value')

    @property
    def isdecomposedby(self):
        return self._isdecomposedby

    @isdecomposedby.setter
    def isdecomposedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument isdecomposedby is INVERSE. It is computed and can not be set to any value')

    @property
    def decomposes(self):
        return self._decomposes

    @decomposes.setter
    def decomposes(self, value):
        # INVERSE argument
        raise AssertionError('Argument decomposes is INVERSE. It is computed and can not be set to any value')

    @property
    def hasassociations(self):
        return self._hasassociations

    @hasassociations.setter
    def hasassociations(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasassociations is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcobject #
####################
class ifcobject(ifcobjectdefinition):
    '''Entity ifcobject definition.

	:param objecttype
	:type objecttype:ifclabel

	:param isdeclaredby
	:type isdeclaredby:SET(0,1,'ifcreldefinesbyobject', scope = schema_scope)

	:param declares
	:type declares:SET(0,None,'ifcreldefinesbyobject', scope = schema_scope)

	:param istypedby
	:type istypedby:SET(0,1,'ifcreldefinesbytype', scope = schema_scope)

	:param isdefinedby
	:type isdefinedby:SET(0,None,'ifcreldefinesbyproperties', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 objecttype, ):
        ifcobjectdefinition.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, )
        self._objecttype = objecttype

    @property
    def objecttype(self):
        return self._objecttype

    @objecttype.setter
    def objecttype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._objecttype = ifclabel(value)
            else:
                self._objecttype = value
        else:
            self._objecttype = value

    @property
    def isdeclaredby(self):
        return self._isdeclaredby

    @isdeclaredby.setter
    def isdeclaredby(self, value):
        # INVERSE argument
        raise AssertionError('Argument isdeclaredby is INVERSE. It is computed and can not be set to any value')

    @property
    def declares(self):
        return self._declares

    @declares.setter
    def declares(self, value):
        # INVERSE argument
        raise AssertionError('Argument declares is INVERSE. It is computed and can not be set to any value')

    @property
    def istypedby(self):
        return self._istypedby

    @istypedby.setter
    def istypedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument istypedby is INVERSE. It is computed and can not be set to any value')

    @property
    def isdefinedby(self):
        return self._isdefinedby

    @isdefinedby.setter
    def isdefinedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument isdefinedby is INVERSE. It is computed and can not be set to any value')

    def uniquepropertysetnames(self):
        eval_uniquepropertysetnames_wr = ((SIZEOF(self.isdefinedby) == 0) or ifcuniquedefinitionnames(self.isdefinedby))
        if not eval_uniquepropertysetnames_wr:
            raise AssertionError('Rule uniquepropertysetnames violated')
        else:
            return eval_uniquepropertysetnames_wr


####################
# ENTITY ifcproduct #
####################
class ifcproduct(ifcobject):
    '''Entity ifcproduct definition.

	:param objectplacement
	:type objectplacement:ifcobjectplacement

	:param representation
	:type representation:ifcproductrepresentation

	:param referencedby
	:type referencedby:SET(0,None,'ifcrelassignstoproduct', scope = schema_scope)

	:param positionedrelativeto
	:type positionedrelativeto:SET(0,1,'ifcrelpositions', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, objectplacement, representation, ):
        ifcobject.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                           inherited3__description, inherited4__objecttype, )
        self._objectplacement = objectplacement
        self._representation = representation

    @property
    def objectplacement(self):
        return self._objectplacement

    @objectplacement.setter
    def objectplacement(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcobjectplacement):
                self._objectplacement = ifcobjectplacement(value)
            else:
                self._objectplacement = value
        else:
            self._objectplacement = value

    @property
    def representation(self):
        return self._representation

    @representation.setter
    def representation(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcproductrepresentation):
                self._representation = ifcproductrepresentation(value)
            else:
                self._representation = value
        else:
            self._representation = value

    @property
    def referencedby(self):
        return self._referencedby

    @referencedby.setter
    def referencedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument referencedby is INVERSE. It is computed and can not be set to any value')

    @property
    def positionedrelativeto(self):
        return self._positionedrelativeto

    @positionedrelativeto.setter
    def positionedrelativeto(self, value):
        # INVERSE argument
        raise AssertionError('Argument positionedrelativeto is INVERSE. It is computed and can not be set to any value')

    def placementforshaperepresentation(self):
        eval_placementforshaperepresentation_wr = (((EXISTS(self.representation) and EXISTS(self.objectplacement)) or (
                    EXISTS(self.representation) and (SIZEOF(None) == 0))) or (not EXISTS(self.representation)))
        if not eval_placementforshaperepresentation_wr:
            raise AssertionError('Rule placementforshaperepresentation violated')
        else:
            return eval_placementforshaperepresentation_wr


####################
# ENTITY ifcport #
####################
class ifcport(ifcproduct):
    '''Entity ifcport definition.

	:param containedin
	:type containedin:SET(0,1,'ifcrelconnectsporttoelement', scope = schema_scope)

	:param connectedfrom
	:type connectedfrom:SET(0,1,'ifcrelconnectsports', scope = schema_scope)

	:param connectedto
	:type connectedto:SET(0,1,'ifcrelconnectsports', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, ):
        ifcproduct.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, )

    @property
    def containedin(self):
        return self._containedin

    @containedin.setter
    def containedin(self, value):
        # INVERSE argument
        raise AssertionError('Argument containedin is INVERSE. It is computed and can not be set to any value')

    @property
    def connectedfrom(self):
        return self._connectedfrom

    @connectedfrom.setter
    def connectedfrom(self, value):
        # INVERSE argument
        raise AssertionError('Argument connectedfrom is INVERSE. It is computed and can not be set to any value')

    @property
    def connectedto(self):
        return self._connectedto

    @connectedto.setter
    def connectedto(self, value):
        # INVERSE argument
        raise AssertionError('Argument connectedto is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcdistributionport #
####################
class ifcdistributionport(ifcport):
    '''Entity ifcdistributionport definition.

	:param flowdirection
	:type flowdirection:ifcflowdirectionenum

	:param predefinedtype
	:type predefinedtype:ifcdistributionporttypeenum

	:param systemtype
	:type systemtype:ifcdistributionsystemenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, flowdirection,
                 predefinedtype, systemtype, ):
        ifcport.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                         inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                         inherited6__representation, )
        self._flowdirection = flowdirection
        self._predefinedtype = predefinedtype
        self._systemtype = systemtype

    @property
    def flowdirection(self):
        return self._flowdirection

    @flowdirection.setter
    def flowdirection(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcflowdirectionenum):
                self._flowdirection = ifcflowdirectionenum(value)
            else:
                self._flowdirection = value
        else:
            self._flowdirection = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdistributionporttypeenum):
                self._predefinedtype = ifcdistributionporttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def systemtype(self):
        return self._systemtype

    @systemtype.setter
    def systemtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdistributionsystemenum):
                self._systemtype = ifcdistributionsystemenum(value)
            else:
                self._systemtype = value
        else:
            self._systemtype = value


####################
# ENTITY ifcpresentationitem #
####################
class ifcpresentationitem(BaseEntityClass):
    '''Entity ifcpresentationitem definition.
	'''
    # This class does not define any attribute.
    pass


####################
# ENTITY ifcpredefineditem #
####################
class ifcpredefineditem(ifcpresentationitem):
    '''Entity ifcpredefineditem definition.

	:param name
	:type name:ifclabel
	'''

    def __init__(self, name, ):
        ifcpresentationitem.__init__(self, )
        self._name = name

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value


####################
# ENTITY ifcpredefinedcolour #
####################
class ifcpredefinedcolour(ifcpredefineditem):
    '''Entity ifcpredefinedcolour definition.
	'''

    def __init__(self, inherited0__name, ):
        ifcpredefineditem.__init__(self, inherited0__name, )


####################
# ENTITY ifcdraughtingpredefinedcolour #
####################
class ifcdraughtingpredefinedcolour(ifcpredefinedcolour):
    '''Entity ifcdraughtingpredefinedcolour definition.
	'''

    def __init__(self, inherited0__name, ):
        ifcpredefinedcolour.__init__(self, inherited0__name, )

    def predefinedcolournames(self):
        eval_predefinedcolournames_wr = (
                    self.self.ifcpredefineditem.self.name == ['black', 'red', 'green', 'blue', 'yellow', 'magenta',
                                                              'cyan', 'white', 'by layer'])
        if not eval_predefinedcolournames_wr:
            raise AssertionError('Rule predefinedcolournames violated')
        else:
            return eval_predefinedcolournames_wr


####################
# ENTITY ifcmaterialdefinition #
####################
class ifcmaterialdefinition(BaseEntityClass):
    '''Entity ifcmaterialdefinition definition.

	:param associatedto
	:type associatedto:SET(0,None,'ifcrelassociatesmaterial', scope = schema_scope)

	:param hasexternalreferences
	:type hasexternalreferences:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)

	:param hasproperties
	:type hasproperties:SET(0,None,'ifcmaterialproperties', scope = schema_scope)
	'''
    # This class does not define any attribute.
    pass

    @property
    def associatedto(self):
        return self._associatedto

    @associatedto.setter
    def associatedto(self, value):
        # INVERSE argument
        raise AssertionError('Argument associatedto is INVERSE. It is computed and can not be set to any value')

    @property
    def hasexternalreferences(self):
        return self._hasexternalreferences

    @hasexternalreferences.setter
    def hasexternalreferences(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument hasexternalreferences is INVERSE. It is computed and can not be set to any value')

    @property
    def hasproperties(self):
        return self._hasproperties

    @hasproperties.setter
    def hasproperties(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasproperties is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcmaterialprofile #
####################
class ifcmaterialprofile(ifcmaterialdefinition):
    '''Entity ifcmaterialprofile definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param material
	:type material:ifcmaterial

	:param profile
	:type profile:ifcprofiledef

	:param priority
	:type priority:ifcinteger

	:param category
	:type category:ifclabel

	:param tomaterialprofileset
	:type tomaterialprofileset:ifcmaterialprofileset
	'''

    def __init__(self, name, description, material, profile, priority, category, ):
        ifcmaterialdefinition.__init__(self, )
        self._name = name
        self._description = description
        self._material = material
        self._profile = profile
        self._priority = priority
        self._category = category

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def material(self):
        return self._material

    @material.setter
    def material(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmaterial):
                self._material = ifcmaterial(value)
            else:
                self._material = value
        else:
            self._material = value

    @property
    def profile(self):
        return self._profile

    @profile.setter
    def profile(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprofiledef):
            self._profile = ifcprofiledef(value)
        else:
            self._profile = value

    @property
    def priority(self):
        return self._priority

    @priority.setter
    def priority(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcinteger):
                self._priority = ifcinteger(value)
            else:
                self._priority = value
        else:
            self._priority = value

    @property
    def category(self):
        return self._category

    @category.setter
    def category(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._category = ifclabel(value)
            else:
                self._category = value
        else:
            self._category = value

    @property
    def tomaterialprofileset(self):
        return self._tomaterialprofileset

    @tomaterialprofileset.setter
    def tomaterialprofileset(self, value):
        # INVERSE argument
        raise AssertionError('Argument tomaterialprofileset is INVERSE. It is computed and can not be set to any value')

    def normalizedpriority(self):
        eval_normalizedpriority_wr = ((not EXISTS(self.priority)) or ((0 <= self.priority) and (self.priority <= 100)))
        if not eval_normalizedpriority_wr:
            raise AssertionError('Rule normalizedpriority violated')
        else:
            return eval_normalizedpriority_wr


####################
# ENTITY ifcrelationship #
####################
class ifcrelationship(ifcroot):
    '''Entity ifcrelationship definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description, ):
        ifcroot.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                         inherited3__description, )


####################
# ENTITY ifcrelconnects #
####################
class ifcrelconnects(ifcrelationship):
    '''Entity ifcrelconnects definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description, ):
        ifcrelationship.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, )


####################
# ENTITY ifcrelpositions #
####################
class ifcrelpositions(ifcrelconnects):
    '''Entity ifcrelpositions definition.

	:param relatingpositioningelement
	:type relatingpositioningelement:ifcpositioningelement

	:param relatedproducts
	:type relatedproducts:SET(1,None,'ifcproduct', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingpositioningelement, relatedproducts, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatingpositioningelement = relatingpositioningelement
        self._relatedproducts = relatedproducts

    @property
    def relatingpositioningelement(self):
        return self._relatingpositioningelement

    @relatingpositioningelement.setter
    def relatingpositioningelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositioningelement):
            self._relatingpositioningelement = ifcpositioningelement(value)
        else:
            self._relatingpositioningelement = value

    @property
    def relatedproducts(self):
        return self._relatedproducts

    @relatedproducts.setter
    def relatedproducts(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcproduct', scope=schema_scope)):
            self._relatedproducts = SET(value)
        else:
            self._relatedproducts = value

    def noselfreference(self):
        eval_noselfreference_wr = (SIZEOF(None) == 0)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifctessellateditem #
####################
class ifctessellateditem(ifcgeometricrepresentationitem):
    '''Entity ifctessellateditem definition.
	'''

    def __init__(self, ):
        ifcgeometricrepresentationitem.__init__(self, )


####################
# ENTITY ifcexternalreference #
####################
class ifcexternalreference(BaseEntityClass):
    '''Entity ifcexternalreference definition.

	:param location
	:type location:ifcurireference

	:param identification
	:type identification:ifcidentifier

	:param name
	:type name:ifclabel

	:param externalreferenceforresources
	:type externalreferenceforresources:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''

    def __init__(self, location, identification, name, ):
        self._location = location
        self._identification = identification
        self._name = name

    @property
    def location(self):
        return self._location

    @location.setter
    def location(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcurireference):
                self._location = ifcurireference(value)
            else:
                self._location = value
        else:
            self._location = value

    @property
    def identification(self):
        return self._identification

    @identification.setter
    def identification(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._identification = ifcidentifier(value)
            else:
                self._identification = value
        else:
            self._identification = value

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def externalreferenceforresources(self):
        return self._externalreferenceforresources

    @externalreferenceforresources.setter
    def externalreferenceforresources(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument externalreferenceforresources is INVERSE. It is computed and can not be set to any value')

    def wr1(self):
        eval_wr1_wr = ((EXISTS(self.identification) or EXISTS(self.location)) or EXISTS(self.name))
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


####################
# ENTITY ifcexternallydefinedtextfont #
####################
class ifcexternallydefinedtextfont(ifcexternalreference):
    '''Entity ifcexternallydefinedtextfont definition.
	'''

    def __init__(self, inherited0__location, inherited1__identification, inherited2__name, ):
        ifcexternalreference.__init__(self, inherited0__location, inherited1__identification, inherited2__name, )


####################
# ENTITY ifcelement #
####################
class ifcelement(ifcproduct):
    '''Entity ifcelement definition.

	:param tag
	:type tag:ifcidentifier

	:param fillsvoids
	:type fillsvoids:SET(0,1,'ifcrelfillselement', scope = schema_scope)

	:param connectedto
	:type connectedto:SET(0,None,'ifcrelconnectselements', scope = schema_scope)

	:param isinterferedbyelements
	:type isinterferedbyelements:SET(0,None,'ifcrelinterfereselements', scope = schema_scope)

	:param interfereselements
	:type interfereselements:SET(0,None,'ifcrelinterfereselements', scope = schema_scope)

	:param hasprojections
	:type hasprojections:SET(0,None,'ifcrelprojectselement', scope = schema_scope)

	:param referencedinstructures
	:type referencedinstructures:SET(0,None,'ifcrelreferencedinspatialstructure', scope = schema_scope)

	:param hasopenings
	:type hasopenings:SET(0,None,'ifcrelvoidselement', scope = schema_scope)

	:param isconnectionrealization
	:type isconnectionrealization:SET(0,None,'ifcrelconnectswithrealizingelements', scope = schema_scope)

	:param providesboundaries
	:type providesboundaries:SET(0,None,'ifcrelspaceboundary', scope = schema_scope)

	:param connectedfrom
	:type connectedfrom:SET(0,None,'ifcrelconnectselements', scope = schema_scope)

	:param containedinstructure
	:type containedinstructure:SET(0,1,'ifcrelcontainedinspatialstructure', scope = schema_scope)

	:param hascoverings
	:type hascoverings:SET(0,None,'ifcrelcoversbldgelements', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, tag, ):
        ifcproduct.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, )
        self._tag = tag

    @property
    def tag(self):
        return self._tag

    @tag.setter
    def tag(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._tag = ifcidentifier(value)
            else:
                self._tag = value
        else:
            self._tag = value

    @property
    def fillsvoids(self):
        return self._fillsvoids

    @fillsvoids.setter
    def fillsvoids(self, value):
        # INVERSE argument
        raise AssertionError('Argument fillsvoids is INVERSE. It is computed and can not be set to any value')

    @property
    def connectedto(self):
        return self._connectedto

    @connectedto.setter
    def connectedto(self, value):
        # INVERSE argument
        raise AssertionError('Argument connectedto is INVERSE. It is computed and can not be set to any value')

    @property
    def isinterferedbyelements(self):
        return self._isinterferedbyelements

    @isinterferedbyelements.setter
    def isinterferedbyelements(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument isinterferedbyelements is INVERSE. It is computed and can not be set to any value')

    @property
    def interfereselements(self):
        return self._interfereselements

    @interfereselements.setter
    def interfereselements(self, value):
        # INVERSE argument
        raise AssertionError('Argument interfereselements is INVERSE. It is computed and can not be set to any value')

    @property
    def hasprojections(self):
        return self._hasprojections

    @hasprojections.setter
    def hasprojections(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasprojections is INVERSE. It is computed and can not be set to any value')

    @property
    def referencedinstructures(self):
        return self._referencedinstructures

    @referencedinstructures.setter
    def referencedinstructures(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument referencedinstructures is INVERSE. It is computed and can not be set to any value')

    @property
    def hasopenings(self):
        return self._hasopenings

    @hasopenings.setter
    def hasopenings(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasopenings is INVERSE. It is computed and can not be set to any value')

    @property
    def isconnectionrealization(self):
        return self._isconnectionrealization

    @isconnectionrealization.setter
    def isconnectionrealization(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument isconnectionrealization is INVERSE. It is computed and can not be set to any value')

    @property
    def providesboundaries(self):
        return self._providesboundaries

    @providesboundaries.setter
    def providesboundaries(self, value):
        # INVERSE argument
        raise AssertionError('Argument providesboundaries is INVERSE. It is computed and can not be set to any value')

    @property
    def connectedfrom(self):
        return self._connectedfrom

    @connectedfrom.setter
    def connectedfrom(self, value):
        # INVERSE argument
        raise AssertionError('Argument connectedfrom is INVERSE. It is computed and can not be set to any value')

    @property
    def containedinstructure(self):
        return self._containedinstructure

    @containedinstructure.setter
    def containedinstructure(self, value):
        # INVERSE argument
        raise AssertionError('Argument containedinstructure is INVERSE. It is computed and can not be set to any value')

    @property
    def hascoverings(self):
        return self._hascoverings

    @hascoverings.setter
    def hascoverings(self, value):
        # INVERSE argument
        raise AssertionError('Argument hascoverings is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcbuildingelement #
####################
class ifcbuildingelement(ifcelement):
    '''Entity ifcbuildingelement definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, inherited7__tag, )

    def maxonematerialassociation(self):
        eval_maxonematerialassociation_wr = (SIZEOF(None) <= 1)
        if not eval_maxonematerialassociation_wr:
            raise AssertionError('Rule maxonematerialassociation violated')
        else:
            return eval_maxonematerialassociation_wr


####################
# ENTITY ifcshadingdevice #
####################
class ifcshadingdevice(ifcbuildingelement):
    '''Entity ifcshadingdevice definition.

	:param predefinedtype
	:type predefinedtype:ifcshadingdevicetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcshadingdevicetypeenum):
                self._predefinedtype = ifcshadingdevicetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcshadingdevicetypeenum.userdefined)) or ((
                                                                                                  self.predefinedtype == ifcshadingdevicetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCSHADINGDEVICETYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcstructuralconnectioncondition #
####################
class ifcstructuralconnectioncondition(BaseEntityClass):
    '''Entity ifcstructuralconnectioncondition definition.

	:param name
	:type name:ifclabel
	'''

    def __init__(self, name, ):
        self._name = name

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value


####################
# ENTITY ifcmateriallist #
####################
class ifcmateriallist(BaseEntityClass):
    '''Entity ifcmateriallist definition.

	:param materials
	:type materials:LIST(1,None,'ifcmaterial', scope = schema_scope)
	'''

    def __init__(self, materials, ):
        self._materials = materials

    @property
    def materials(self):
        return self._materials

    @materials.setter
    def materials(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcmaterial', scope=schema_scope)):
            self._materials = LIST(value)
        else:
            self._materials = value


####################
# ENTITY ifcpropertyabstraction #
####################
class ifcpropertyabstraction(BaseEntityClass):
    '''Entity ifcpropertyabstraction definition.

	:param hasexternalreferences
	:type hasexternalreferences:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''
    # This class does not define any attribute.
    pass

    @property
    def hasexternalreferences(self):
        return self._hasexternalreferences

    @hasexternalreferences.setter
    def hasexternalreferences(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument hasexternalreferences is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcpredefinedproperties #
####################
class ifcpredefinedproperties(ifcpropertyabstraction):
    '''Entity ifcpredefinedproperties definition.
	'''

    def __init__(self, ):
        ifcpropertyabstraction.__init__(self, )


####################
# ENTITY ifcdistributionelement #
####################
class ifcdistributionelement(ifcelement):
    '''Entity ifcdistributionelement definition.

	:param hasports
	:type hasports:SET(0,None,'ifcrelconnectsporttoelement', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, inherited7__tag, )

    @property
    def hasports(self):
        return self._hasports

    @hasports.setter
    def hasports(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasports is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcdistributioncontrolelement #
####################
class ifcdistributioncontrolelement(ifcdistributionelement):
    '''Entity ifcdistributioncontrolelement definition.

	:param assignedtoflowelement
	:type assignedtoflowelement:SET(0,1,'ifcrelflowcontrolelements', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcdistributionelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                        inherited6__representation, inherited7__tag, )

    @property
    def assignedtoflowelement(self):
        return self._assignedtoflowelement

    @assignedtoflowelement.setter
    def assignedtoflowelement(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument assignedtoflowelement is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcsensor #
####################
class ifcsensor(ifcdistributioncontrolelement):
    '''Entity ifcsensor definition.

	:param predefinedtype
	:type predefinedtype:ifcsensortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcdistributioncontrolelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__objecttype,
                                               inherited5__objectplacement, inherited6__representation,
                                               inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsensortypeenum):
                self._predefinedtype = ifcsensortypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcsensortypeenum.userdefined)) or (
                        (self.predefinedtype == ifcsensortypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCSENSORTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcgroup #
####################
class ifcgroup(ifcobject):
    '''Entity ifcgroup definition.

	:param isgroupedby
	:type isgroupedby:SET(0,None,'ifcrelassignstogroup', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, ):
        ifcobject.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                           inherited3__description, inherited4__objecttype, )

    @property
    def isgroupedby(self):
        return self._isgroupedby

    @isgroupedby.setter
    def isgroupedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument isgroupedby is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcstructuralresultgroup #
####################
class ifcstructuralresultgroup(ifcgroup):
    '''Entity ifcstructuralresultgroup definition.

	:param theorytype
	:type theorytype:ifcanalysistheorytypeenum

	:param resultforloadgroup
	:type resultforloadgroup:ifcstructuralloadgroup

	:param islinear
	:type islinear:ifcboolean

	:param resultgroupfor
	:type resultgroupfor:SET(0,1,'ifcstructuralanalysismodel', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, theorytype, resultforloadgroup, islinear, ):
        ifcgroup.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                          inherited3__description, inherited4__objecttype, )
        self._theorytype = theorytype
        self._resultforloadgroup = resultforloadgroup
        self._islinear = islinear

    @property
    def theorytype(self):
        return self._theorytype

    @theorytype.setter
    def theorytype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcanalysistheorytypeenum):
            self._theorytype = ifcanalysistheorytypeenum(value)
        else:
            self._theorytype = value

    @property
    def resultforloadgroup(self):
        return self._resultforloadgroup

    @resultforloadgroup.setter
    def resultforloadgroup(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcstructuralloadgroup):
                self._resultforloadgroup = ifcstructuralloadgroup(value)
            else:
                self._resultforloadgroup = value
        else:
            self._resultforloadgroup = value

    @property
    def islinear(self):
        return self._islinear

    @islinear.setter
    def islinear(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._islinear = ifcboolean(value)
        else:
            self._islinear = value

    @property
    def resultgroupfor(self):
        return self._resultgroupfor

    @resultgroupfor.setter
    def resultgroupfor(self, value):
        # INVERSE argument
        raise AssertionError('Argument resultgroupfor is INVERSE. It is computed and can not be set to any value')

    def hasobjecttype(self):
        eval_hasobjecttype_wr = ((self.theorytype != ifcanalysistheorytypeenum.userdefined) or EXISTS(
            self.self.ifcobject.self.objecttype))
        if not eval_hasobjecttype_wr:
            raise AssertionError('Rule hasobjecttype violated')
        else:
            return eval_hasobjecttype_wr


####################
# ENTITY ifcsolidmodel #
####################
class ifcsolidmodel(ifcgeometricrepresentationitem):
    '''Entity ifcsolidmodel definition.

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, ):
        ifcgeometricrepresentationitem.__init__(self, )

    @property
    def dim(self):
        attribute_eval = 3
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcmanifoldsolidbrep #
####################
class ifcmanifoldsolidbrep(ifcsolidmodel):
    '''Entity ifcmanifoldsolidbrep definition.

	:param outer
	:type outer:ifcclosedshell
	'''

    def __init__(self, outer, ):
        ifcsolidmodel.__init__(self, )
        self._outer = outer

    @property
    def outer(self):
        return self._outer

    @outer.setter
    def outer(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcclosedshell):
            self._outer = ifcclosedshell(value)
        else:
            self._outer = value


####################
# ENTITY ifcadvancedbrep #
####################
class ifcadvancedbrep(ifcmanifoldsolidbrep):
    '''Entity ifcadvancedbrep definition.
	'''

    def __init__(self, inherited0__outer, ):
        ifcmanifoldsolidbrep.__init__(self, inherited0__outer, )

    def hasadvancedfaces(self):
        eval_hasadvancedfaces_wr = (SIZEOF(None) == 0)
        if not eval_hasadvancedfaces_wr:
            raise AssertionError('Rule hasadvancedfaces violated')
        else:
            return eval_hasadvancedfaces_wr


####################
# ENTITY ifcadvancedbrepwithvoids #
####################
class ifcadvancedbrepwithvoids(ifcadvancedbrep):
    '''Entity ifcadvancedbrepwithvoids definition.

	:param voids
	:type voids:SET(1,None,'ifcclosedshell', scope = schema_scope)
	'''

    def __init__(self, inherited0__outer, voids, ):
        ifcadvancedbrep.__init__(self, inherited0__outer, )
        self._voids = voids

    @property
    def voids(self):
        return self._voids

    @voids.setter
    def voids(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcclosedshell', scope=schema_scope)):
            self._voids = SET(value)
        else:
            self._voids = value

    def voidshaveadvancedfaces(self):
        eval_voidshaveadvancedfaces_wr = (SIZEOF(None) == 0)
        if not eval_voidshaveadvancedfaces_wr:
            raise AssertionError('Rule voidshaveadvancedfaces violated')
        else:
            return eval_voidshaveadvancedfaces_wr


####################
# ENTITY ifcfeatureelement #
####################
class ifcfeatureelement(ifcelement):
    '''Entity ifcfeatureelement definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, inherited7__tag, )


####################
# ENTITY ifcfeatureelementsubtraction #
####################
class ifcfeatureelementsubtraction(ifcfeatureelement):
    '''Entity ifcfeatureelementsubtraction definition.

	:param voidselements
	:type voidselements:ifcrelvoidselement
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcfeatureelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, )

    @property
    def voidselements(self):
        return self._voidselements

    @voidselements.setter
    def voidselements(self, value):
        # INVERSE argument
        raise AssertionError('Argument voidselements is INVERSE. It is computed and can not be set to any value')

    def hasnosubtraction(self):
        eval_hasnosubtraction_wr = (SIZEOF(self.self.ifcelement.self.hasopenings) == 0)
        if not eval_hasnosubtraction_wr:
            raise AssertionError('Rule hasnosubtraction violated')
        else:
            return eval_hasnosubtraction_wr

    def isnotfilling(self):
        eval_isnotfilling_wr = (SIZEOF(self.self.ifcelement.self.fillsvoids) == 0)
        if not eval_isnotfilling_wr:
            raise AssertionError('Rule isnotfilling violated')
        else:
            return eval_isnotfilling_wr


####################
# ENTITY ifcopeningelement #
####################
class ifcopeningelement(ifcfeatureelementsubtraction):
    '''Entity ifcopeningelement definition.

	:param predefinedtype
	:type predefinedtype:ifcopeningelementtypeenum

	:param hasfillings
	:type hasfillings:SET(0,None,'ifcrelfillselement', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcfeatureelementsubtraction.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                              inherited3__description, inherited4__objecttype,
                                              inherited5__objectplacement, inherited6__representation,
                                              inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcopeningelementtypeenum):
                self._predefinedtype = ifcopeningelementtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def hasfillings(self):
        return self._hasfillings

    @hasfillings.setter
    def hasfillings(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasfillings is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcramp #
####################
class ifcramp(ifcbuildingelement):
    '''Entity ifcramp definition.

	:param predefinedtype
	:type predefinedtype:ifcramptypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcramptypeenum):
                self._predefinedtype = ifcramptypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcramptypeenum.userdefined)) or (
                        (self.predefinedtype == ifcramptypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCRAMPTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcschedulingtime #
####################
class ifcschedulingtime(BaseEntityClass):
    '''Entity ifcschedulingtime definition.

	:param name
	:type name:ifclabel

	:param dataorigin
	:type dataorigin:ifcdataoriginenum

	:param userdefineddataorigin
	:type userdefineddataorigin:ifclabel
	'''

    def __init__(self, name, dataorigin, userdefineddataorigin, ):
        self._name = name
        self._dataorigin = dataorigin
        self._userdefineddataorigin = userdefineddataorigin

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def dataorigin(self):
        return self._dataorigin

    @dataorigin.setter
    def dataorigin(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdataoriginenum):
                self._dataorigin = ifcdataoriginenum(value)
            else:
                self._dataorigin = value
        else:
            self._dataorigin = value

    @property
    def userdefineddataorigin(self):
        return self._userdefineddataorigin

    @userdefineddataorigin.setter
    def userdefineddataorigin(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefineddataorigin = ifclabel(value)
            else:
                self._userdefineddataorigin = value
        else:
            self._userdefineddataorigin = value


####################
# ENTITY ifctasktime #
####################
class ifctasktime(ifcschedulingtime):
    '''Entity ifctasktime definition.

	:param durationtype
	:type durationtype:ifctaskdurationenum

	:param scheduleduration
	:type scheduleduration:ifcduration

	:param schedulestart
	:type schedulestart:ifcdatetime

	:param schedulefinish
	:type schedulefinish:ifcdatetime

	:param earlystart
	:type earlystart:ifcdatetime

	:param earlyfinish
	:type earlyfinish:ifcdatetime

	:param latestart
	:type latestart:ifcdatetime

	:param latefinish
	:type latefinish:ifcdatetime

	:param freefloat
	:type freefloat:ifcduration

	:param totalfloat
	:type totalfloat:ifcduration

	:param iscritical
	:type iscritical:ifcboolean

	:param statustime
	:type statustime:ifcdatetime

	:param actualduration
	:type actualduration:ifcduration

	:param actualstart
	:type actualstart:ifcdatetime

	:param actualfinish
	:type actualfinish:ifcdatetime

	:param remainingtime
	:type remainingtime:ifcduration

	:param completion
	:type completion:ifcpositiveratiomeasure
	'''

    def __init__(self, inherited0__name, inherited1__dataorigin, inherited2__userdefineddataorigin, durationtype,
                 scheduleduration, schedulestart, schedulefinish, earlystart, earlyfinish, latestart, latefinish,
                 freefloat, totalfloat, iscritical, statustime, actualduration, actualstart, actualfinish,
                 remainingtime, completion, ):
        ifcschedulingtime.__init__(self, inherited0__name, inherited1__dataorigin, inherited2__userdefineddataorigin, )
        self._durationtype = durationtype
        self._scheduleduration = scheduleduration
        self._schedulestart = schedulestart
        self._schedulefinish = schedulefinish
        self._earlystart = earlystart
        self._earlyfinish = earlyfinish
        self._latestart = latestart
        self._latefinish = latefinish
        self._freefloat = freefloat
        self._totalfloat = totalfloat
        self._iscritical = iscritical
        self._statustime = statustime
        self._actualduration = actualduration
        self._actualstart = actualstart
        self._actualfinish = actualfinish
        self._remainingtime = remainingtime
        self._completion = completion

    @property
    def durationtype(self):
        return self._durationtype

    @durationtype.setter
    def durationtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctaskdurationenum):
                self._durationtype = ifctaskdurationenum(value)
            else:
                self._durationtype = value
        else:
            self._durationtype = value

    @property
    def scheduleduration(self):
        return self._scheduleduration

    @scheduleduration.setter
    def scheduleduration(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcduration):
                self._scheduleduration = ifcduration(value)
            else:
                self._scheduleduration = value
        else:
            self._scheduleduration = value

    @property
    def schedulestart(self):
        return self._schedulestart

    @schedulestart.setter
    def schedulestart(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._schedulestart = ifcdatetime(value)
            else:
                self._schedulestart = value
        else:
            self._schedulestart = value

    @property
    def schedulefinish(self):
        return self._schedulefinish

    @schedulefinish.setter
    def schedulefinish(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._schedulefinish = ifcdatetime(value)
            else:
                self._schedulefinish = value
        else:
            self._schedulefinish = value

    @property
    def earlystart(self):
        return self._earlystart

    @earlystart.setter
    def earlystart(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._earlystart = ifcdatetime(value)
            else:
                self._earlystart = value
        else:
            self._earlystart = value

    @property
    def earlyfinish(self):
        return self._earlyfinish

    @earlyfinish.setter
    def earlyfinish(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._earlyfinish = ifcdatetime(value)
            else:
                self._earlyfinish = value
        else:
            self._earlyfinish = value

    @property
    def latestart(self):
        return self._latestart

    @latestart.setter
    def latestart(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._latestart = ifcdatetime(value)
            else:
                self._latestart = value
        else:
            self._latestart = value

    @property
    def latefinish(self):
        return self._latefinish

    @latefinish.setter
    def latefinish(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._latefinish = ifcdatetime(value)
            else:
                self._latefinish = value
        else:
            self._latefinish = value

    @property
    def freefloat(self):
        return self._freefloat

    @freefloat.setter
    def freefloat(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcduration):
                self._freefloat = ifcduration(value)
            else:
                self._freefloat = value
        else:
            self._freefloat = value

    @property
    def totalfloat(self):
        return self._totalfloat

    @totalfloat.setter
    def totalfloat(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcduration):
                self._totalfloat = ifcduration(value)
            else:
                self._totalfloat = value
        else:
            self._totalfloat = value

    @property
    def iscritical(self):
        return self._iscritical

    @iscritical.setter
    def iscritical(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._iscritical = ifcboolean(value)
            else:
                self._iscritical = value
        else:
            self._iscritical = value

    @property
    def statustime(self):
        return self._statustime

    @statustime.setter
    def statustime(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._statustime = ifcdatetime(value)
            else:
                self._statustime = value
        else:
            self._statustime = value

    @property
    def actualduration(self):
        return self._actualduration

    @actualduration.setter
    def actualduration(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcduration):
                self._actualduration = ifcduration(value)
            else:
                self._actualduration = value
        else:
            self._actualduration = value

    @property
    def actualstart(self):
        return self._actualstart

    @actualstart.setter
    def actualstart(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._actualstart = ifcdatetime(value)
            else:
                self._actualstart = value
        else:
            self._actualstart = value

    @property
    def actualfinish(self):
        return self._actualfinish

    @actualfinish.setter
    def actualfinish(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._actualfinish = ifcdatetime(value)
            else:
                self._actualfinish = value
        else:
            self._actualfinish = value

    @property
    def remainingtime(self):
        return self._remainingtime

    @remainingtime.setter
    def remainingtime(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcduration):
                self._remainingtime = ifcduration(value)
            else:
                self._remainingtime = value
        else:
            self._remainingtime = value

    @property
    def completion(self):
        return self._completion

    @completion.setter
    def completion(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositiveratiomeasure):
                self._completion = ifcpositiveratiomeasure(value)
            else:
                self._completion = value
        else:
            self._completion = value


####################
# ENTITY ifctasktimerecurring #
####################
class ifctasktimerecurring(ifctasktime):
    '''Entity ifctasktimerecurring definition.

	:param recurrence
	:type recurrence:ifcrecurrencepattern
	'''

    def __init__(self, inherited0__name, inherited1__dataorigin, inherited2__userdefineddataorigin,
                 inherited3__durationtype, inherited4__scheduleduration, inherited5__schedulestart,
                 inherited6__schedulefinish, inherited7__earlystart, inherited8__earlyfinish, inherited9__latestart,
                 inherited10__latefinish, inherited11__freefloat, inherited12__totalfloat, inherited13__iscritical,
                 inherited14__statustime, inherited15__actualduration, inherited16__actualstart,
                 inherited17__actualfinish, inherited18__remainingtime, inherited19__completion, recurrence, ):
        ifctasktime.__init__(self, inherited0__name, inherited1__dataorigin, inherited2__userdefineddataorigin,
                             inherited3__durationtype, inherited4__scheduleduration, inherited5__schedulestart,
                             inherited6__schedulefinish, inherited7__earlystart, inherited8__earlyfinish,
                             inherited9__latestart, inherited10__latefinish, inherited11__freefloat,
                             inherited12__totalfloat, inherited13__iscritical, inherited14__statustime,
                             inherited15__actualduration, inherited16__actualstart, inherited17__actualfinish,
                             inherited18__remainingtime, inherited19__completion, )
        self._recurrence = recurrence

    @property
    def recurrence(self):
        return self._recurrence

    @recurrence.setter
    def recurrence(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcrecurrencepattern):
            self._recurrence = ifcrecurrencepattern(value)
        else:
            self._recurrence = value


####################
# ENTITY ifcelementcomponent #
####################
class ifcelementcomponent(ifcelement):
    '''Entity ifcelementcomponent definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, inherited7__tag, )


####################
# ENTITY ifcvibrationdamper #
####################
class ifcvibrationdamper(ifcelementcomponent):
    '''Entity ifcvibrationdamper definition.

	:param predefinedtype
	:type predefinedtype:ifcvibrationdampertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcelementcomponent.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcvibrationdampertypeenum):
                self._predefinedtype = ifcvibrationdampertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcvibrationdampertypeenum.userdefined)) or ((
                                                                                                    self.predefinedtype == ifcvibrationdampertypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCVIBRATIONDAMPERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcclassificationreference #
####################
class ifcclassificationreference(ifcexternalreference):
    '''Entity ifcclassificationreference definition.

	:param referencedsource
	:type referencedsource:ifcclassificationreferenceselect

	:param description
	:type description:ifctext

	:param sort
	:type sort:ifcidentifier

	:param classificationrefforobjects
	:type classificationrefforobjects:SET(0,None,'ifcrelassociatesclassification', scope = schema_scope)

	:param hasreferences
	:type hasreferences:SET(0,None,'ifcclassificationreference', scope = schema_scope)
	'''

    def __init__(self, inherited0__location, inherited1__identification, inherited2__name, referencedsource,
                 description, sort, ):
        ifcexternalreference.__init__(self, inherited0__location, inherited1__identification, inherited2__name, )
        self._referencedsource = referencedsource
        self._description = description
        self._sort = sort

    @property
    def referencedsource(self):
        return self._referencedsource

    @referencedsource.setter
    def referencedsource(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcclassificationreferenceselect):
                self._referencedsource = ifcclassificationreferenceselect(value)
            else:
                self._referencedsource = value
        else:
            self._referencedsource = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def sort(self):
        return self._sort

    @sort.setter
    def sort(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._sort = ifcidentifier(value)
            else:
                self._sort = value
        else:
            self._sort = value

    @property
    def classificationrefforobjects(self):
        return self._classificationrefforobjects

    @classificationrefforobjects.setter
    def classificationrefforobjects(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument classificationrefforobjects is INVERSE. It is computed and can not be set to any value')

    @property
    def hasreferences(self):
        return self._hasreferences

    @hasreferences.setter
    def hasreferences(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasreferences is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcboundedcurve #
####################
class ifcboundedcurve(ifccurve):
    '''Entity ifcboundedcurve definition.

	:param positioningelement
	:type positioningelement:ifclinearpositioningelement
	'''

    def __init__(self, ):
        ifccurve.__init__(self, )

    @property
    def positioningelement(self):
        return self._positioningelement

    @positioningelement.setter
    def positioningelement(self, value):
        # INVERSE argument
        raise AssertionError('Argument positioningelement is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifccurvesegment2d #
####################
class ifccurvesegment2d(ifcboundedcurve):
    '''Entity ifccurvesegment2d definition.

	:param startpoint
	:type startpoint:ifccartesianpoint

	:param startdirection
	:type startdirection:ifcplaneanglemeasure

	:param segmentlength
	:type segmentlength:ifcpositivelengthmeasure
	'''

    def __init__(self, startpoint, startdirection, segmentlength, ):
        ifcboundedcurve.__init__(self, )
        self._startpoint = startpoint
        self._startdirection = startdirection
        self._segmentlength = segmentlength

    @property
    def startpoint(self):
        return self._startpoint

    @startpoint.setter
    def startpoint(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccartesianpoint):
            self._startpoint = ifccartesianpoint(value)
        else:
            self._startpoint = value

    @property
    def startdirection(self):
        return self._startdirection

    @startdirection.setter
    def startdirection(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcplaneanglemeasure):
            self._startdirection = ifcplaneanglemeasure(value)
        else:
            self._startdirection = value

    @property
    def segmentlength(self):
        return self._segmentlength

    @segmentlength.setter
    def segmentlength(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._segmentlength = ifcpositivelengthmeasure(value)
        else:
            self._segmentlength = value


####################
# ENTITY ifcdistributionflowelement #
####################
class ifcdistributionflowelement(ifcdistributionelement):
    '''Entity ifcdistributionflowelement definition.

	:param hascontrolelements
	:type hascontrolelements:SET(0,1,'ifcrelflowcontrolelements', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcdistributionelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                        inherited6__representation, inherited7__tag, )

    @property
    def hascontrolelements(self):
        return self._hascontrolelements

    @hascontrolelements.setter
    def hascontrolelements(self, value):
        # INVERSE argument
        raise AssertionError('Argument hascontrolelements is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcflowsegment #
####################
class ifcflowsegment(ifcdistributionflowelement):
    '''Entity ifcflowsegment definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcdistributionflowelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation, inherited7__tag, )


####################
# ENTITY ifcductsegment #
####################
class ifcductsegment(ifcflowsegment):
    '''Entity ifcductsegment definition.

	:param predefinedtype
	:type predefinedtype:ifcductsegmenttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowsegment.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcductsegmenttypeenum):
                self._predefinedtype = ifcductsegmenttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcductsegmenttypeenum.userdefined)) or ((
                                                                                                self.predefinedtype == ifcductsegmenttypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCDUCTSEGMENTTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcobjectplacement #
####################
class ifcobjectplacement(BaseEntityClass):
    '''Entity ifcobjectplacement definition.

	:param placementrelto
	:type placementrelto:ifcobjectplacement

	:param placesobject
	:type placesobject:SET(0,None,'ifcproduct', scope = schema_scope)
	'''

    def __init__(self, placementrelto, ):
        self._placementrelto = placementrelto

    @property
    def placementrelto(self):
        return self._placementrelto

    @placementrelto.setter
    def placementrelto(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcobjectplacement):
                self._placementrelto = ifcobjectplacement(value)
            else:
                self._placementrelto = value
        else:
            self._placementrelto = value

    @property
    def placesobject(self):
        return self._placesobject

    @placesobject.setter
    def placesobject(self, value):
        # INVERSE argument
        raise AssertionError('Argument placesobject is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcgridplacement #
####################
class ifcgridplacement(ifcobjectplacement):
    '''Entity ifcgridplacement definition.

	:param placementlocation
	:type placementlocation:ifcvirtualgridintersection

	:param placementrefdirection
	:type placementrefdirection:ifcgridplacementdirectionselect
	'''

    def __init__(self, inherited0__placementrelto, placementlocation, placementrefdirection, ):
        ifcobjectplacement.__init__(self, inherited0__placementrelto, )
        self._placementlocation = placementlocation
        self._placementrefdirection = placementrefdirection

    @property
    def placementlocation(self):
        return self._placementlocation

    @placementlocation.setter
    def placementlocation(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcvirtualgridintersection):
            self._placementlocation = ifcvirtualgridintersection(value)
        else:
            self._placementlocation = value

    @property
    def placementrefdirection(self):
        return self._placementrefdirection

    @placementrefdirection.setter
    def placementrefdirection(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcgridplacementdirectionselect):
                self._placementrefdirection = ifcgridplacementdirectionselect(value)
            else:
                self._placementrefdirection = value
        else:
            self._placementrefdirection = value


####################
# ENTITY ifctopologicalrepresentationitem #
####################
class ifctopologicalrepresentationitem(ifcrepresentationitem):
    '''Entity ifctopologicalrepresentationitem definition.
	'''

    def __init__(self, ):
        ifcrepresentationitem.__init__(self, )


####################
# ENTITY ifcloop #
####################
class ifcloop(ifctopologicalrepresentationitem):
    '''Entity ifcloop definition.
	'''

    def __init__(self, ):
        ifctopologicalrepresentationitem.__init__(self, )


####################
# ENTITY ifcpolyloop #
####################
class ifcpolyloop(ifcloop):
    '''Entity ifcpolyloop definition.

	:param polygon
	:type polygon:LIST(3,None,'ifccartesianpoint', scope = schema_scope)
	'''

    def __init__(self, polygon, ):
        ifcloop.__init__(self, )
        self._polygon = polygon

    @property
    def polygon(self):
        return self._polygon

    @polygon.setter
    def polygon(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(3, None, 'ifccartesianpoint', scope=schema_scope)):
            self._polygon = LIST(value)
        else:
            self._polygon = value

    def allpointssamedim(self):
        eval_allpointssamedim_wr = (SIZEOF(None) == 0)
        if not eval_allpointssamedim_wr:
            raise AssertionError('Rule allpointssamedim violated')
        else:
            return eval_allpointssamedim_wr


####################
# ENTITY ifctypeobject #
####################
class ifctypeobject(ifcobjectdefinition):
    '''Entity ifctypeobject definition.

	:param applicableoccurrence
	:type applicableoccurrence:ifcidentifier

	:param haspropertysets
	:type haspropertysets:SET(1,None,'ifcpropertysetdefinition', scope = schema_scope)

	:param types
	:type types:SET(0,1,'ifcreldefinesbytype', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 applicableoccurrence, haspropertysets, ):
        ifcobjectdefinition.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, )
        self._applicableoccurrence = applicableoccurrence
        self._haspropertysets = haspropertysets

    @property
    def applicableoccurrence(self):
        return self._applicableoccurrence

    @applicableoccurrence.setter
    def applicableoccurrence(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._applicableoccurrence = ifcidentifier(value)
            else:
                self._applicableoccurrence = value
        else:
            self._applicableoccurrence = value

    @property
    def haspropertysets(self):
        return self._haspropertysets

    @haspropertysets.setter
    def haspropertysets(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'ifcpropertysetdefinition', scope=schema_scope)):
                self._haspropertysets = SET(value)
            else:
                self._haspropertysets = value
        else:
            self._haspropertysets = value

    @property
    def types(self):
        return self._types

    @types.setter
    def types(self, value):
        # INVERSE argument
        raise AssertionError('Argument types is INVERSE. It is computed and can not be set to any value')

    def namerequired(self):
        eval_namerequired_wr = EXISTS(self.self.ifcroot.self.name)
        if not eval_namerequired_wr:
            raise AssertionError('Rule namerequired violated')
        else:
            return eval_namerequired_wr

    def uniquepropertysetnames(self):
        eval_uniquepropertysetnames_wr = (
                    (not EXISTS(self.haspropertysets)) or ifcuniquepropertysetnames(self.haspropertysets))
        if not eval_uniquepropertysetnames_wr:
            raise AssertionError('Rule uniquepropertysetnames violated')
        else:
            return eval_uniquepropertysetnames_wr


####################
# ENTITY ifctypeproduct #
####################
class ifctypeproduct(ifctypeobject):
    '''Entity ifctypeproduct definition.

	:param representationmaps
	:type representationmaps:LIST(1,None,'ifcrepresentationmap', scope = schema_scope)

	:param tag
	:type tag:ifclabel

	:param referencedby
	:type referencedby:SET(0,None,'ifcrelassignstoproduct', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, representationmaps, tag, ):
        ifctypeobject.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                               inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets, )
        self._representationmaps = representationmaps
        self._tag = tag

    @property
    def representationmaps(self):
        return self._representationmaps

    @representationmaps.setter
    def representationmaps(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcrepresentationmap', scope=schema_scope)):
                self._representationmaps = LIST(value)
            else:
                self._representationmaps = value
        else:
            self._representationmaps = value

    @property
    def tag(self):
        return self._tag

    @tag.setter
    def tag(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._tag = ifclabel(value)
            else:
                self._tag = value
        else:
            self._tag = value

    @property
    def referencedby(self):
        return self._referencedby

    @referencedby.setter
    def referencedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument referencedby is INVERSE. It is computed and can not be set to any value')

    def applicableoccurrence(self):
        eval_applicableoccurrence_wr = ((not EXISTS(self.self.ifctypeobject.self.types[1])) or (SIZEOF(None) == 0))
        if not eval_applicableoccurrence_wr:
            raise AssertionError('Rule applicableoccurrence violated')
        else:
            return eval_applicableoccurrence_wr


####################
# ENTITY ifcspatialelementtype #
####################
class ifcspatialelementtype(ifctypeproduct):
    '''Entity ifcspatialelementtype definition.

	:param elementtype
	:type elementtype:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, elementtype, ):
        ifctypeproduct.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__representationmaps, inherited7__tag, )
        self._elementtype = elementtype

    @property
    def elementtype(self):
        return self._elementtype

    @elementtype.setter
    def elementtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._elementtype = ifclabel(value)
            else:
                self._elementtype = value
        else:
            self._elementtype = value


####################
# ENTITY ifcspatialstructureelementtype #
####################
class ifcspatialstructureelementtype(ifcspatialelementtype):
    '''Entity ifcspatialstructureelementtype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcspatialelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__applicableoccurrence,
                                       inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                       inherited8__elementtype, )


####################
# ENTITY ifcspacetype #
####################
class ifcspacetype(ifcspatialstructureelementtype):
    '''Entity ifcspacetype definition.

	:param predefinedtype
	:type predefinedtype:ifcspacetypeenum

	:param longname
	:type longname:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, longname, ):
        ifcspatialstructureelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                                inherited3__description, inherited4__applicableoccurrence,
                                                inherited5__haspropertysets, inherited6__representationmaps,
                                                inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype
        self._longname = longname

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcspacetypeenum):
            self._predefinedtype = ifcspacetypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def longname(self):
        return self._longname

    @longname.setter
    def longname(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._longname = ifclabel(value)
            else:
                self._longname = value
        else:
            self._longname = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcspacetypeenum.userdefined) or (
                    (self.predefinedtype == ifcspacetypeenum.userdefined) and EXISTS(
                self.self.ifcspatialelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcboundarycondition #
####################
class ifcboundarycondition(BaseEntityClass):
    '''Entity ifcboundarycondition definition.

	:param name
	:type name:ifclabel
	'''

    def __init__(self, name, ):
        self._name = name

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value


####################
# ENTITY ifcboundarynodecondition #
####################
class ifcboundarynodecondition(ifcboundarycondition):
    '''Entity ifcboundarynodecondition definition.

	:param translationalstiffnessx
	:type translationalstiffnessx:ifctranslationalstiffnessselect

	:param translationalstiffnessy
	:type translationalstiffnessy:ifctranslationalstiffnessselect

	:param translationalstiffnessz
	:type translationalstiffnessz:ifctranslationalstiffnessselect

	:param rotationalstiffnessx
	:type rotationalstiffnessx:ifcrotationalstiffnessselect

	:param rotationalstiffnessy
	:type rotationalstiffnessy:ifcrotationalstiffnessselect

	:param rotationalstiffnessz
	:type rotationalstiffnessz:ifcrotationalstiffnessselect
	'''

    def __init__(self, inherited0__name, translationalstiffnessx, translationalstiffnessy, translationalstiffnessz,
                 rotationalstiffnessx, rotationalstiffnessy, rotationalstiffnessz, ):
        ifcboundarycondition.__init__(self, inherited0__name, )
        self._translationalstiffnessx = translationalstiffnessx
        self._translationalstiffnessy = translationalstiffnessy
        self._translationalstiffnessz = translationalstiffnessz
        self._rotationalstiffnessx = rotationalstiffnessx
        self._rotationalstiffnessy = rotationalstiffnessy
        self._rotationalstiffnessz = rotationalstiffnessz

    @property
    def translationalstiffnessx(self):
        return self._translationalstiffnessx

    @translationalstiffnessx.setter
    def translationalstiffnessx(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctranslationalstiffnessselect):
                self._translationalstiffnessx = ifctranslationalstiffnessselect(value)
            else:
                self._translationalstiffnessx = value
        else:
            self._translationalstiffnessx = value

    @property
    def translationalstiffnessy(self):
        return self._translationalstiffnessy

    @translationalstiffnessy.setter
    def translationalstiffnessy(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctranslationalstiffnessselect):
                self._translationalstiffnessy = ifctranslationalstiffnessselect(value)
            else:
                self._translationalstiffnessy = value
        else:
            self._translationalstiffnessy = value

    @property
    def translationalstiffnessz(self):
        return self._translationalstiffnessz

    @translationalstiffnessz.setter
    def translationalstiffnessz(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctranslationalstiffnessselect):
                self._translationalstiffnessz = ifctranslationalstiffnessselect(value)
            else:
                self._translationalstiffnessz = value
        else:
            self._translationalstiffnessz = value

    @property
    def rotationalstiffnessx(self):
        return self._rotationalstiffnessx

    @rotationalstiffnessx.setter
    def rotationalstiffnessx(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcrotationalstiffnessselect):
                self._rotationalstiffnessx = ifcrotationalstiffnessselect(value)
            else:
                self._rotationalstiffnessx = value
        else:
            self._rotationalstiffnessx = value

    @property
    def rotationalstiffnessy(self):
        return self._rotationalstiffnessy

    @rotationalstiffnessy.setter
    def rotationalstiffnessy(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcrotationalstiffnessselect):
                self._rotationalstiffnessy = ifcrotationalstiffnessselect(value)
            else:
                self._rotationalstiffnessy = value
        else:
            self._rotationalstiffnessy = value

    @property
    def rotationalstiffnessz(self):
        return self._rotationalstiffnessz

    @rotationalstiffnessz.setter
    def rotationalstiffnessz(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcrotationalstiffnessselect):
                self._rotationalstiffnessz = ifcrotationalstiffnessselect(value)
            else:
                self._rotationalstiffnessz = value
        else:
            self._rotationalstiffnessz = value


####################
# ENTITY ifccirculararcsegment2d #
####################
class ifccirculararcsegment2d(ifccurvesegment2d):
    '''Entity ifccirculararcsegment2d definition.

	:param radius
	:type radius:ifcpositivelengthmeasure

	:param isccw
	:type isccw:ifcboolean
	'''

    def __init__(self, inherited0__startpoint, inherited1__startdirection, inherited2__segmentlength, radius, isccw, ):
        ifccurvesegment2d.__init__(self, inherited0__startpoint, inherited1__startdirection,
                                   inherited2__segmentlength, )
        self._radius = radius
        self._isccw = isccw

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._radius = ifcpositivelengthmeasure(value)
        else:
            self._radius = value

    @property
    def isccw(self):
        return self._isccw

    @isccw.setter
    def isccw(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._isccw = ifcboolean(value)
        else:
            self._isccw = value


####################
# ENTITY ifcprofiledef #
####################
class ifcprofiledef(BaseEntityClass):
    '''Entity ifcprofiledef definition.

	:param profiletype
	:type profiletype:ifcprofiletypeenum

	:param profilename
	:type profilename:ifclabel

	:param hasexternalreference
	:type hasexternalreference:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)

	:param hasproperties
	:type hasproperties:SET(0,None,'ifcprofileproperties', scope = schema_scope)
	'''

    def __init__(self, profiletype, profilename, ):
        self._profiletype = profiletype
        self._profilename = profilename

    @property
    def profiletype(self):
        return self._profiletype

    @profiletype.setter
    def profiletype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprofiletypeenum):
            self._profiletype = ifcprofiletypeenum(value)
        else:
            self._profiletype = value

    @property
    def profilename(self):
        return self._profilename

    @profilename.setter
    def profilename(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._profilename = ifclabel(value)
            else:
                self._profilename = value
        else:
            self._profilename = value

    @property
    def hasexternalreference(self):
        return self._hasexternalreference

    @hasexternalreference.setter
    def hasexternalreference(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasexternalreference is INVERSE. It is computed and can not be set to any value')

    @property
    def hasproperties(self):
        return self._hasproperties

    @hasproperties.setter
    def hasproperties(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasproperties is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcparameterizedprofiledef #
####################
class ifcparameterizedprofiledef(ifcprofiledef):
    '''Entity ifcparameterizedprofiledef definition.

	:param position
	:type position:ifcaxis2placement2d
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, position, ):
        ifcprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename, )
        self._position = position

    @property
    def position(self):
        return self._position

    @position.setter
    def position(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcaxis2placement2d):
                self._position = ifcaxis2placement2d(value)
            else:
                self._position = value
        else:
            self._position = value


####################
# ENTITY ifcellipseprofiledef #
####################
class ifcellipseprofiledef(ifcparameterizedprofiledef):
    '''Entity ifcellipseprofiledef definition.

	:param semiaxis1
	:type semiaxis1:ifcpositivelengthmeasure

	:param semiaxis2
	:type semiaxis2:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, semiaxis1, semiaxis2, ):
        ifcparameterizedprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename,
                                            inherited2__position, )
        self._semiaxis1 = semiaxis1
        self._semiaxis2 = semiaxis2

    @property
    def semiaxis1(self):
        return self._semiaxis1

    @semiaxis1.setter
    def semiaxis1(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._semiaxis1 = ifcpositivelengthmeasure(value)
        else:
            self._semiaxis1 = value

    @property
    def semiaxis2(self):
        return self._semiaxis2

    @semiaxis2.setter
    def semiaxis2(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._semiaxis2 = ifcpositivelengthmeasure(value)
        else:
            self._semiaxis2 = value


####################
# ENTITY ifccsgprimitive3d #
####################
class ifccsgprimitive3d(ifcgeometricrepresentationitem):
    '''Entity ifccsgprimitive3d definition.

	:param position
	:type position:ifcaxis2placement3d

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, position, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._position = position

    @property
    def position(self):
        return self._position

    @position.setter
    def position(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcaxis2placement3d):
            self._position = ifcaxis2placement3d(value)
        else:
            self._position = value

    @property
    def dim(self):
        attribute_eval = 3
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcrightcircularcone #
####################
class ifcrightcircularcone(ifccsgprimitive3d):
    '''Entity ifcrightcircularcone definition.

	:param height
	:type height:ifcpositivelengthmeasure

	:param bottomradius
	:type bottomradius:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__position, height, bottomradius, ):
        ifccsgprimitive3d.__init__(self, inherited0__position, )
        self._height = height
        self._bottomradius = bottomradius

    @property
    def height(self):
        return self._height

    @height.setter
    def height(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._height = ifcpositivelengthmeasure(value)
        else:
            self._height = value

    @property
    def bottomradius(self):
        return self._bottomradius

    @bottomradius.setter
    def bottomradius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._bottomradius = ifcpositivelengthmeasure(value)
        else:
            self._bottomradius = value


####################
# ENTITY ifcresourcelevelrelationship #
####################
class ifcresourcelevelrelationship(BaseEntityClass):
    '''Entity ifcresourcelevelrelationship definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext
	'''

    def __init__(self, name, description, ):
        self._name = name
        self._description = description

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value


####################
# ENTITY ifccurrencyrelationship #
####################
class ifccurrencyrelationship(ifcresourcelevelrelationship):
    '''Entity ifccurrencyrelationship definition.

	:param relatingmonetaryunit
	:type relatingmonetaryunit:ifcmonetaryunit

	:param relatedmonetaryunit
	:type relatedmonetaryunit:ifcmonetaryunit

	:param exchangerate
	:type exchangerate:ifcpositiveratiomeasure

	:param ratedatetime
	:type ratedatetime:ifcdatetime

	:param ratesource
	:type ratesource:ifclibraryinformation
	'''

    def __init__(self, inherited0__name, inherited1__description, relatingmonetaryunit, relatedmonetaryunit,
                 exchangerate, ratedatetime, ratesource, ):
        ifcresourcelevelrelationship.__init__(self, inherited0__name, inherited1__description, )
        self._relatingmonetaryunit = relatingmonetaryunit
        self._relatedmonetaryunit = relatedmonetaryunit
        self._exchangerate = exchangerate
        self._ratedatetime = ratedatetime
        self._ratesource = ratesource

    @property
    def relatingmonetaryunit(self):
        return self._relatingmonetaryunit

    @relatingmonetaryunit.setter
    def relatingmonetaryunit(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmonetaryunit):
            self._relatingmonetaryunit = ifcmonetaryunit(value)
        else:
            self._relatingmonetaryunit = value

    @property
    def relatedmonetaryunit(self):
        return self._relatedmonetaryunit

    @relatedmonetaryunit.setter
    def relatedmonetaryunit(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmonetaryunit):
            self._relatedmonetaryunit = ifcmonetaryunit(value)
        else:
            self._relatedmonetaryunit = value

    @property
    def exchangerate(self):
        return self._exchangerate

    @exchangerate.setter
    def exchangerate(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositiveratiomeasure):
            self._exchangerate = ifcpositiveratiomeasure(value)
        else:
            self._exchangerate = value

    @property
    def ratedatetime(self):
        return self._ratedatetime

    @ratedatetime.setter
    def ratedatetime(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._ratedatetime = ifcdatetime(value)
            else:
                self._ratedatetime = value
        else:
            self._ratedatetime = value

    @property
    def ratesource(self):
        return self._ratesource

    @ratesource.setter
    def ratesource(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclibraryinformation):
                self._ratesource = ifclibraryinformation(value)
            else:
                self._ratesource = value
        else:
            self._ratesource = value


####################
# ENTITY ifcsystem #
####################
class ifcsystem(ifcgroup):
    '''Entity ifcsystem definition.

	:param servicesbuildings
	:type servicesbuildings:SET(0,1,'ifcrelservicesbuildings', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, ):
        ifcgroup.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                          inherited3__description, inherited4__objecttype, )

    @property
    def servicesbuildings(self):
        return self._servicesbuildings

    @servicesbuildings.setter
    def servicesbuildings(self, value):
        # INVERSE argument
        raise AssertionError('Argument servicesbuildings is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcdistributionsystem #
####################
class ifcdistributionsystem(ifcsystem):
    '''Entity ifcdistributionsystem definition.

	:param longname
	:type longname:ifclabel

	:param predefinedtype
	:type predefinedtype:ifcdistributionsystemenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, longname, predefinedtype, ):
        ifcsystem.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                           inherited3__description, inherited4__objecttype, )
        self._longname = longname
        self._predefinedtype = predefinedtype

    @property
    def longname(self):
        return self._longname

    @longname.setter
    def longname(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._longname = ifclabel(value)
            else:
                self._longname = value
        else:
            self._longname = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdistributionsystemenum):
                self._predefinedtype = ifcdistributionsystemenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value


####################
# ENTITY ifcdistributioncircuit #
####################
class ifcdistributioncircuit(ifcdistributionsystem):
    '''Entity ifcdistributioncircuit definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__longname, inherited6__predefinedtype, ):
        ifcdistributionsystem.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__longname,
                                       inherited6__predefinedtype, )


####################
# ENTITY ifceventtime #
####################
class ifceventtime(ifcschedulingtime):
    '''Entity ifceventtime definition.

	:param actualdate
	:type actualdate:ifcdatetime

	:param earlydate
	:type earlydate:ifcdatetime

	:param latedate
	:type latedate:ifcdatetime

	:param scheduledate
	:type scheduledate:ifcdatetime
	'''

    def __init__(self, inherited0__name, inherited1__dataorigin, inherited2__userdefineddataorigin, actualdate,
                 earlydate, latedate, scheduledate, ):
        ifcschedulingtime.__init__(self, inherited0__name, inherited1__dataorigin, inherited2__userdefineddataorigin, )
        self._actualdate = actualdate
        self._earlydate = earlydate
        self._latedate = latedate
        self._scheduledate = scheduledate

    @property
    def actualdate(self):
        return self._actualdate

    @actualdate.setter
    def actualdate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._actualdate = ifcdatetime(value)
            else:
                self._actualdate = value
        else:
            self._actualdate = value

    @property
    def earlydate(self):
        return self._earlydate

    @earlydate.setter
    def earlydate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._earlydate = ifcdatetime(value)
            else:
                self._earlydate = value
        else:
            self._earlydate = value

    @property
    def latedate(self):
        return self._latedate

    @latedate.setter
    def latedate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._latedate = ifcdatetime(value)
            else:
                self._latedate = value
        else:
            self._latedate = value

    @property
    def scheduledate(self):
        return self._scheduledate

    @scheduledate.setter
    def scheduledate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._scheduledate = ifcdatetime(value)
            else:
                self._scheduledate = value
        else:
            self._scheduledate = value


####################
# ENTITY ifcsectionproperties #
####################
class ifcsectionproperties(ifcpredefinedproperties):
    '''Entity ifcsectionproperties definition.

	:param sectiontype
	:type sectiontype:ifcsectiontypeenum

	:param startprofile
	:type startprofile:ifcprofiledef

	:param endprofile
	:type endprofile:ifcprofiledef
	'''

    def __init__(self, sectiontype, startprofile, endprofile, ):
        ifcpredefinedproperties.__init__(self, )
        self._sectiontype = sectiontype
        self._startprofile = startprofile
        self._endprofile = endprofile

    @property
    def sectiontype(self):
        return self._sectiontype

    @sectiontype.setter
    def sectiontype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsectiontypeenum):
            self._sectiontype = ifcsectiontypeenum(value)
        else:
            self._sectiontype = value

    @property
    def startprofile(self):
        return self._startprofile

    @startprofile.setter
    def startprofile(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprofiledef):
            self._startprofile = ifcprofiledef(value)
        else:
            self._startprofile = value

    @property
    def endprofile(self):
        return self._endprofile

    @endprofile.setter
    def endprofile(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcprofiledef):
                self._endprofile = ifcprofiledef(value)
            else:
                self._endprofile = value
        else:
            self._endprofile = value


####################
# ENTITY ifcelementtype #
####################
class ifcelementtype(ifctypeproduct):
    '''Entity ifcelementtype definition.

	:param elementtype
	:type elementtype:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, elementtype, ):
        ifctypeproduct.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__representationmaps, inherited7__tag, )
        self._elementtype = elementtype

    @property
    def elementtype(self):
        return self._elementtype

    @elementtype.setter
    def elementtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._elementtype = ifclabel(value)
            else:
                self._elementtype = value
        else:
            self._elementtype = value


####################
# ENTITY ifcelementcomponenttype #
####################
class ifcelementcomponenttype(ifcelementtype):
    '''Entity ifcelementcomponenttype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__representationmaps, inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcfastenertype #
####################
class ifcfastenertype(ifcelementcomponenttype):
    '''Entity ifcfastenertype definition.

	:param predefinedtype
	:type predefinedtype:ifcfastenertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcelementcomponenttype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__applicableoccurrence,
                                         inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                         inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcfastenertypeenum):
            self._predefinedtype = ifcfastenertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcfastenertypeenum.userdefined) or (
                    (self.predefinedtype == ifcfastenertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcreinforcingelementtype #
####################
class ifcreinforcingelementtype(ifcelementcomponenttype):
    '''Entity ifcreinforcingelementtype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcelementcomponenttype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__applicableoccurrence,
                                         inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                         inherited8__elementtype, )


####################
# ENTITY ifcreinforcingbartype #
####################
class ifcreinforcingbartype(ifcreinforcingelementtype):
    '''Entity ifcreinforcingbartype definition.

	:param predefinedtype
	:type predefinedtype:ifcreinforcingbartypeenum

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param crosssectionarea
	:type crosssectionarea:ifcareameasure

	:param barlength
	:type barlength:ifcpositivelengthmeasure

	:param barsurface
	:type barsurface:ifcreinforcingbarsurfaceenum

	:param bendingshapecode
	:type bendingshapecode:ifclabel

	:param bendingparameters
	:type bendingparameters:LIST(1,None,'ifcbendingparameterselect', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, nominaldiameter, crosssectionarea, barlength,
                 barsurface, bendingshapecode, bendingparameters, ):
        ifcreinforcingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__applicableoccurrence,
                                           inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                           inherited8__elementtype, )
        self._predefinedtype = predefinedtype
        self._nominaldiameter = nominaldiameter
        self._crosssectionarea = crosssectionarea
        self._barlength = barlength
        self._barsurface = barsurface
        self._bendingshapecode = bendingshapecode
        self._bendingparameters = bendingparameters

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcreinforcingbartypeenum):
            self._predefinedtype = ifcreinforcingbartypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def nominaldiameter(self):
        return self._nominaldiameter

    @nominaldiameter.setter
    def nominaldiameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._nominaldiameter = ifcpositivelengthmeasure(value)
            else:
                self._nominaldiameter = value
        else:
            self._nominaldiameter = value

    @property
    def crosssectionarea(self):
        return self._crosssectionarea

    @crosssectionarea.setter
    def crosssectionarea(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcareameasure):
                self._crosssectionarea = ifcareameasure(value)
            else:
                self._crosssectionarea = value
        else:
            self._crosssectionarea = value

    @property
    def barlength(self):
        return self._barlength

    @barlength.setter
    def barlength(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._barlength = ifcpositivelengthmeasure(value)
            else:
                self._barlength = value
        else:
            self._barlength = value

    @property
    def barsurface(self):
        return self._barsurface

    @barsurface.setter
    def barsurface(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreinforcingbarsurfaceenum):
                self._barsurface = ifcreinforcingbarsurfaceenum(value)
            else:
                self._barsurface = value
        else:
            self._barsurface = value

    @property
    def bendingshapecode(self):
        return self._bendingshapecode

    @bendingshapecode.setter
    def bendingshapecode(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._bendingshapecode = ifclabel(value)
            else:
                self._bendingshapecode = value
        else:
            self._bendingshapecode = value

    @property
    def bendingparameters(self):
        return self._bendingparameters

    @bendingparameters.setter
    def bendingparameters(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcbendingparameterselect', scope=schema_scope)):
                self._bendingparameters = LIST(value)
            else:
                self._bendingparameters = value
        else:
            self._bendingparameters = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcreinforcingbartypeenum.userdefined) or (
                    (self.predefinedtype == ifcreinforcingbartypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def bendingshapecodeprovided(self):
        eval_bendingshapecodeprovided_wr = ((not EXISTS(self.bendingparameters)) or EXISTS(self.bendingshapecode))
        if not eval_bendingshapecodeprovided_wr:
            raise AssertionError('Rule bendingshapecodeprovided violated')
        else:
            return eval_bendingshapecodeprovided_wr


####################
# ENTITY ifccurvestylefontpattern #
####################
class ifccurvestylefontpattern(ifcpresentationitem):
    '''Entity ifccurvestylefontpattern definition.

	:param visiblesegmentlength
	:type visiblesegmentlength:ifclengthmeasure

	:param invisiblesegmentlength
	:type invisiblesegmentlength:ifcpositivelengthmeasure
	'''

    def __init__(self, visiblesegmentlength, invisiblesegmentlength, ):
        ifcpresentationitem.__init__(self, )
        self._visiblesegmentlength = visiblesegmentlength
        self._invisiblesegmentlength = invisiblesegmentlength

    @property
    def visiblesegmentlength(self):
        return self._visiblesegmentlength

    @visiblesegmentlength.setter
    def visiblesegmentlength(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._visiblesegmentlength = ifclengthmeasure(value)
        else:
            self._visiblesegmentlength = value

    @property
    def invisiblesegmentlength(self):
        return self._invisiblesegmentlength

    @invisiblesegmentlength.setter
    def invisiblesegmentlength(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._invisiblesegmentlength = ifcpositivelengthmeasure(value)
        else:
            self._invisiblesegmentlength = value

    def visiblelengthgreaterequalzero(self):
        eval_visiblelengthgreaterequalzero_wr = (self.visiblesegmentlength >= 0)
        if not eval_visiblelengthgreaterequalzero_wr:
            raise AssertionError('Rule visiblelengthgreaterequalzero violated')
        else:
            return eval_visiblelengthgreaterequalzero_wr


####################
# ENTITY ifcbuildingelementtype #
####################
class ifcbuildingelementtype(ifcelementtype):
    '''Entity ifcbuildingelementtype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__representationmaps, inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcplatetype #
####################
class ifcplatetype(ifcbuildingelementtype):
    '''Entity ifcplatetype definition.

	:param predefinedtype
	:type predefinedtype:ifcplatetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcplatetypeenum):
            self._predefinedtype = ifcplatetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcplatetypeenum.userdefined) or (
                    (self.predefinedtype == ifcplatetypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifctyperesource #
####################
class ifctyperesource(ifctypeobject):
    '''Entity ifctyperesource definition.

	:param identification
	:type identification:ifcidentifier

	:param longdescription
	:type longdescription:ifctext

	:param resourcetype
	:type resourcetype:ifclabel

	:param resourceof
	:type resourceof:SET(0,None,'ifcrelassignstoresource', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, identification, longdescription,
                 resourcetype, ):
        ifctypeobject.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                               inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets, )
        self._identification = identification
        self._longdescription = longdescription
        self._resourcetype = resourcetype

    @property
    def identification(self):
        return self._identification

    @identification.setter
    def identification(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._identification = ifcidentifier(value)
            else:
                self._identification = value
        else:
            self._identification = value

    @property
    def longdescription(self):
        return self._longdescription

    @longdescription.setter
    def longdescription(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._longdescription = ifctext(value)
            else:
                self._longdescription = value
        else:
            self._longdescription = value

    @property
    def resourcetype(self):
        return self._resourcetype

    @resourcetype.setter
    def resourcetype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._resourcetype = ifclabel(value)
            else:
                self._resourcetype = value
        else:
            self._resourcetype = value

    @property
    def resourceof(self):
        return self._resourceof

    @resourceof.setter
    def resourceof(self, value):
        # INVERSE argument
        raise AssertionError('Argument resourceof is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcconstructionresourcetype #
####################
class ifcconstructionresourcetype(ifctyperesource):
    '''Entity ifcconstructionresourcetype definition.

	:param basecosts
	:type basecosts:LIST(1,None,'ifcappliedvalue', scope = schema_scope)

	:param basequantity
	:type basequantity:ifcphysicalquantity
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__identification,
                 inherited7__longdescription, inherited8__resourcetype, basecosts, basequantity, ):
        ifctyperesource.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                 inherited6__identification, inherited7__longdescription, inherited8__resourcetype, )
        self._basecosts = basecosts
        self._basequantity = basequantity

    @property
    def basecosts(self):
        return self._basecosts

    @basecosts.setter
    def basecosts(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcappliedvalue', scope=schema_scope)):
                self._basecosts = LIST(value)
            else:
                self._basecosts = value
        else:
            self._basecosts = value

    @property
    def basequantity(self):
        return self._basequantity

    @basequantity.setter
    def basequantity(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcphysicalquantity):
                self._basequantity = ifcphysicalquantity(value)
            else:
                self._basequantity = value
        else:
            self._basequantity = value


####################
# ENTITY ifcsubcontractresourcetype #
####################
class ifcsubcontractresourcetype(ifcconstructionresourcetype):
    '''Entity ifcsubcontractresourcetype definition.

	:param predefinedtype
	:type predefinedtype:ifcsubcontractresourcetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__identification,
                 inherited7__longdescription, inherited8__resourcetype, inherited9__basecosts,
                 inherited10__basequantity, predefinedtype, ):
        ifcconstructionresourcetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                             inherited3__description, inherited4__applicableoccurrence,
                                             inherited5__haspropertysets, inherited6__identification,
                                             inherited7__longdescription, inherited8__resourcetype,
                                             inherited9__basecosts, inherited10__basequantity, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsubcontractresourcetypeenum):
            self._predefinedtype = ifcsubcontractresourcetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcsubcontractresourcetypeenum.userdefined) or (
                    (self.predefinedtype == ifcsubcontractresourcetypeenum.userdefined) and EXISTS(
                self.self.ifctyperesource.self.resourcetype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcrecurrencepattern #
####################
class ifcrecurrencepattern(BaseEntityClass):
    '''Entity ifcrecurrencepattern definition.

	:param recurrencetype
	:type recurrencetype:ifcrecurrencetypeenum

	:param daycomponent
	:type daycomponent:SET(1,None,'INTEGER', scope = schema_scope)

	:param weekdaycomponent
	:type weekdaycomponent:SET(1,None,'INTEGER', scope = schema_scope)

	:param monthcomponent
	:type monthcomponent:SET(1,None,'INTEGER', scope = schema_scope)

	:param position
	:type position:ifcinteger

	:param interval
	:type interval:ifcinteger

	:param occurrences
	:type occurrences:ifcinteger

	:param timeperiods
	:type timeperiods:LIST(1,None,'ifctimeperiod', scope = schema_scope)
	'''

    def __init__(self, recurrencetype, daycomponent, weekdaycomponent, monthcomponent, position, interval, occurrences,
                 timeperiods, ):
        self._recurrencetype = recurrencetype
        self._daycomponent = daycomponent
        self._weekdaycomponent = weekdaycomponent
        self._monthcomponent = monthcomponent
        self._position = position
        self._interval = interval
        self._occurrences = occurrences
        self._timeperiods = timeperiods

    @property
    def recurrencetype(self):
        return self._recurrencetype

    @recurrencetype.setter
    def recurrencetype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcrecurrencetypeenum):
            self._recurrencetype = ifcrecurrencetypeenum(value)
        else:
            self._recurrencetype = value

    @property
    def daycomponent(self):
        return self._daycomponent

    @daycomponent.setter
    def daycomponent(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'INTEGER', scope=schema_scope)):
                self._daycomponent = SET(value)
            else:
                self._daycomponent = value
        else:
            self._daycomponent = value

    @property
    def weekdaycomponent(self):
        return self._weekdaycomponent

    @weekdaycomponent.setter
    def weekdaycomponent(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'INTEGER', scope=schema_scope)):
                self._weekdaycomponent = SET(value)
            else:
                self._weekdaycomponent = value
        else:
            self._weekdaycomponent = value

    @property
    def monthcomponent(self):
        return self._monthcomponent

    @monthcomponent.setter
    def monthcomponent(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'INTEGER', scope=schema_scope)):
                self._monthcomponent = SET(value)
            else:
                self._monthcomponent = value
        else:
            self._monthcomponent = value

    @property
    def position(self):
        return self._position

    @position.setter
    def position(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcinteger):
                self._position = ifcinteger(value)
            else:
                self._position = value
        else:
            self._position = value

    @property
    def interval(self):
        return self._interval

    @interval.setter
    def interval(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcinteger):
                self._interval = ifcinteger(value)
            else:
                self._interval = value
        else:
            self._interval = value

    @property
    def occurrences(self):
        return self._occurrences

    @occurrences.setter
    def occurrences(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcinteger):
                self._occurrences = ifcinteger(value)
            else:
                self._occurrences = value
        else:
            self._occurrences = value

    @property
    def timeperiods(self):
        return self._timeperiods

    @timeperiods.setter
    def timeperiods(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifctimeperiod', scope=schema_scope)):
                self._timeperiods = LIST(value)
            else:
                self._timeperiods = value
        else:
            self._timeperiods = value


####################
# ENTITY ifcextendedproperties #
####################
class ifcextendedproperties(ifcpropertyabstraction):
    '''Entity ifcextendedproperties definition.

	:param name
	:type name:ifcidentifier

	:param description
	:type description:ifctext

	:param properties
	:type properties:SET(1,None,'ifcproperty', scope = schema_scope)
	'''

    def __init__(self, name, description, properties, ):
        ifcpropertyabstraction.__init__(self, )
        self._name = name
        self._description = description
        self._properties = properties

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._name = ifcidentifier(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def properties(self):
        return self._properties

    @properties.setter
    def properties(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcproperty', scope=schema_scope)):
            self._properties = SET(value)
        else:
            self._properties = value


####################
# ENTITY ifcpositioningelement #
####################
class ifcpositioningelement(ifcproduct):
    '''Entity ifcpositioningelement definition.

	:param containedinstructure
	:type containedinstructure:SET(0,1,'ifcrelcontainedinspatialstructure', scope = schema_scope)

	:param positions
	:type positions:SET(0,None,'ifcrelpositions', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, ):
        ifcproduct.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, )

    @property
    def containedinstructure(self):
        return self._containedinstructure

    @containedinstructure.setter
    def containedinstructure(self, value):
        # INVERSE argument
        raise AssertionError('Argument containedinstructure is INVERSE. It is computed and can not be set to any value')

    @property
    def positions(self):
        return self._positions

    @positions.setter
    def positions(self, value):
        # INVERSE argument
        raise AssertionError('Argument positions is INVERSE. It is computed and can not be set to any value')

    def hasplacement(self):
        eval_hasplacement_wr = EXISTS(self.self.ifcproduct.self.objectplacement)
        if not eval_hasplacement_wr:
            raise AssertionError('Rule hasplacement violated')
        else:
            return eval_hasplacement_wr


####################
# ENTITY ifclinearpositioningelement #
####################
class ifclinearpositioningelement(ifcpositioningelement):
    '''Entity ifclinearpositioningelement definition.

	:param axis
	:type axis:ifccurve
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, axis, ):
        ifcpositioningelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                       inherited6__representation, )
        self._axis = axis

    @property
    def axis(self):
        return self._axis

    @axis.setter
    def axis(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._axis = ifccurve(value)
        else:
            self._axis = value


####################
# ENTITY ifcrelconnectselements #
####################
class ifcrelconnectselements(ifcrelconnects):
    '''Entity ifcrelconnectselements definition.

	:param connectiongeometry
	:type connectiongeometry:ifcconnectiongeometry

	:param relatingelement
	:type relatingelement:ifcelement

	:param relatedelement
	:type relatedelement:ifcelement
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 connectiongeometry, relatingelement, relatedelement, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._connectiongeometry = connectiongeometry
        self._relatingelement = relatingelement
        self._relatedelement = relatedelement

    @property
    def connectiongeometry(self):
        return self._connectiongeometry

    @connectiongeometry.setter
    def connectiongeometry(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcconnectiongeometry):
                self._connectiongeometry = ifcconnectiongeometry(value)
            else:
                self._connectiongeometry = value
        else:
            self._connectiongeometry = value

    @property
    def relatingelement(self):
        return self._relatingelement

    @relatingelement.setter
    def relatingelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelement):
            self._relatingelement = ifcelement(value)
        else:
            self._relatingelement = value

    @property
    def relatedelement(self):
        return self._relatedelement

    @relatedelement.setter
    def relatedelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelement):
            self._relatedelement = ifcelement(value)
        else:
            self._relatedelement = value

    def noselfreference(self):
        eval_noselfreference_wr = (self.relatingelement != self.relatedelement)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifcrelconnectspathelements #
####################
class ifcrelconnectspathelements(ifcrelconnectselements):
    '''Entity ifcrelconnectspathelements definition.

	:param relatingpriorities
	:type relatingpriorities:LIST(0,None,'INTEGER', scope = schema_scope)

	:param relatedpriorities
	:type relatedpriorities:LIST(0,None,'INTEGER', scope = schema_scope)

	:param relatedconnectiontype
	:type relatedconnectiontype:ifcconnectiontypeenum

	:param relatingconnectiontype
	:type relatingconnectiontype:ifcconnectiontypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__connectiongeometry, inherited5__relatingelement, inherited6__relatedelement,
                 relatingpriorities, relatedpriorities, relatedconnectiontype, relatingconnectiontype, ):
        ifcrelconnectselements.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__connectiongeometry,
                                        inherited5__relatingelement, inherited6__relatedelement, )
        self._relatingpriorities = relatingpriorities
        self._relatedpriorities = relatedpriorities
        self._relatedconnectiontype = relatedconnectiontype
        self._relatingconnectiontype = relatingconnectiontype

    @property
    def relatingpriorities(self):
        return self._relatingpriorities

    @relatingpriorities.setter
    def relatingpriorities(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(0, None, 'INTEGER', scope=schema_scope)):
            self._relatingpriorities = LIST(value)
        else:
            self._relatingpriorities = value

    @property
    def relatedpriorities(self):
        return self._relatedpriorities

    @relatedpriorities.setter
    def relatedpriorities(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(0, None, 'INTEGER', scope=schema_scope)):
            self._relatedpriorities = LIST(value)
        else:
            self._relatedpriorities = value

    @property
    def relatedconnectiontype(self):
        return self._relatedconnectiontype

    @relatedconnectiontype.setter
    def relatedconnectiontype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcconnectiontypeenum):
            self._relatedconnectiontype = ifcconnectiontypeenum(value)
        else:
            self._relatedconnectiontype = value

    @property
    def relatingconnectiontype(self):
        return self._relatingconnectiontype

    @relatingconnectiontype.setter
    def relatingconnectiontype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcconnectiontypeenum):
            self._relatingconnectiontype = ifcconnectiontypeenum(value)
        else:
            self._relatingconnectiontype = value

    def normalizedrelatingpriorities(self):
        eval_normalizedrelatingpriorities_wr = (
                    (SIZEOF(self.relatingpriorities) == 0) or (SIZEOF(None) == SIZEOF(self.relatingpriorities)))
        if not eval_normalizedrelatingpriorities_wr:
            raise AssertionError('Rule normalizedrelatingpriorities violated')
        else:
            return eval_normalizedrelatingpriorities_wr

    def normalizedrelatedpriorities(self):
        eval_normalizedrelatedpriorities_wr = (
                    (SIZEOF(self.relatedpriorities) == 0) or (SIZEOF(None) == SIZEOF(self.relatedpriorities)))
        if not eval_normalizedrelatedpriorities_wr:
            raise AssertionError('Rule normalizedrelatedpriorities violated')
        else:
            return eval_normalizedrelatedpriorities_wr


####################
# ENTITY ifcrelspaceboundary #
####################
class ifcrelspaceboundary(ifcrelconnects):
    '''Entity ifcrelspaceboundary definition.

	:param relatingspace
	:type relatingspace:ifcspaceboundaryselect

	:param relatedbuildingelement
	:type relatedbuildingelement:ifcelement

	:param connectiongeometry
	:type connectiongeometry:ifcconnectiongeometry

	:param physicalorvirtualboundary
	:type physicalorvirtualboundary:ifcphysicalorvirtualenum

	:param internalorexternalboundary
	:type internalorexternalboundary:ifcinternalorexternalenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingspace, relatedbuildingelement, connectiongeometry, physicalorvirtualboundary,
                 internalorexternalboundary, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatingspace = relatingspace
        self._relatedbuildingelement = relatedbuildingelement
        self._connectiongeometry = connectiongeometry
        self._physicalorvirtualboundary = physicalorvirtualboundary
        self._internalorexternalboundary = internalorexternalboundary

    @property
    def relatingspace(self):
        return self._relatingspace

    @relatingspace.setter
    def relatingspace(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcspaceboundaryselect):
            self._relatingspace = ifcspaceboundaryselect(value)
        else:
            self._relatingspace = value

    @property
    def relatedbuildingelement(self):
        return self._relatedbuildingelement

    @relatedbuildingelement.setter
    def relatedbuildingelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelement):
            self._relatedbuildingelement = ifcelement(value)
        else:
            self._relatedbuildingelement = value

    @property
    def connectiongeometry(self):
        return self._connectiongeometry

    @connectiongeometry.setter
    def connectiongeometry(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcconnectiongeometry):
                self._connectiongeometry = ifcconnectiongeometry(value)
            else:
                self._connectiongeometry = value
        else:
            self._connectiongeometry = value

    @property
    def physicalorvirtualboundary(self):
        return self._physicalorvirtualboundary

    @physicalorvirtualboundary.setter
    def physicalorvirtualboundary(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcphysicalorvirtualenum):
            self._physicalorvirtualboundary = ifcphysicalorvirtualenum(value)
        else:
            self._physicalorvirtualboundary = value

    @property
    def internalorexternalboundary(self):
        return self._internalorexternalboundary

    @internalorexternalboundary.setter
    def internalorexternalboundary(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcinternalorexternalenum):
            self._internalorexternalboundary = ifcinternalorexternalenum(value)
        else:
            self._internalorexternalboundary = value

    def correctphysorvirt(self):
        eval_correctphysorvirt_wr = ((((self.physicalorvirtualboundary == ifcphysicalorvirtualenum.physical) and (
            not ('IFC4X2.IFCVIRTUALELEMENT' == TYPEOF(self.relatedbuildingelement)))) or ((
                                                                                                      self.physicalorvirtualboundary == ifcphysicalorvirtualenum.virtual) and (
                                                                                                      (
                                                                                                                  'IFC4X2.IFCVIRTUALELEMENT' == TYPEOF(
                                                                                                              self.relatedbuildingelement)) or (
                                                                                                                  'IFC4X2.IFCOPENINGELEMENT' == TYPEOF(
                                                                                                              self.relatedbuildingelement))))) or (
                                                 self.physicalorvirtualboundary == ifcphysicalorvirtualenum.notdefined))
        if not eval_correctphysorvirt_wr:
            raise AssertionError('Rule correctphysorvirt violated')
        else:
            return eval_correctphysorvirt_wr


####################
# ENTITY ifcrelspaceboundary1stlevel #
####################
class ifcrelspaceboundary1stlevel(ifcrelspaceboundary):
    '''Entity ifcrelspaceboundary1stlevel definition.

	:param parentboundary
	:type parentboundary:ifcrelspaceboundary1stlevel

	:param innerboundaries
	:type innerboundaries:SET(0,None,'ifcrelspaceboundary1stlevel', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatingspace, inherited5__relatedbuildingelement, inherited6__connectiongeometry,
                 inherited7__physicalorvirtualboundary, inherited8__internalorexternalboundary, parentboundary, ):
        ifcrelspaceboundary.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__relatingspace,
                                     inherited5__relatedbuildingelement, inherited6__connectiongeometry,
                                     inherited7__physicalorvirtualboundary, inherited8__internalorexternalboundary, )
        self._parentboundary = parentboundary

    @property
    def parentboundary(self):
        return self._parentboundary

    @parentboundary.setter
    def parentboundary(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcrelspaceboundary1stlevel):
                self._parentboundary = ifcrelspaceboundary1stlevel(value)
            else:
                self._parentboundary = value
        else:
            self._parentboundary = value

    @property
    def innerboundaries(self):
        return self._innerboundaries

    @innerboundaries.setter
    def innerboundaries(self, value):
        # INVERSE argument
        raise AssertionError('Argument innerboundaries is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcrelspaceboundary2ndlevel #
####################
class ifcrelspaceboundary2ndlevel(ifcrelspaceboundary1stlevel):
    '''Entity ifcrelspaceboundary2ndlevel definition.

	:param correspondingboundary
	:type correspondingboundary:ifcrelspaceboundary2ndlevel

	:param corresponds
	:type corresponds:SET(0,1,'ifcrelspaceboundary2ndlevel', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatingspace, inherited5__relatedbuildingelement, inherited6__connectiongeometry,
                 inherited7__physicalorvirtualboundary, inherited8__internalorexternalboundary,
                 inherited9__parentboundary, correspondingboundary, ):
        ifcrelspaceboundary1stlevel.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                             inherited3__description, inherited4__relatingspace,
                                             inherited5__relatedbuildingelement, inherited6__connectiongeometry,
                                             inherited7__physicalorvirtualboundary,
                                             inherited8__internalorexternalboundary, inherited9__parentboundary, )
        self._correspondingboundary = correspondingboundary

    @property
    def correspondingboundary(self):
        return self._correspondingboundary

    @correspondingboundary.setter
    def correspondingboundary(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcrelspaceboundary2ndlevel):
                self._correspondingboundary = ifcrelspaceboundary2ndlevel(value)
            else:
                self._correspondingboundary = value
        else:
            self._correspondingboundary = value

    @property
    def corresponds(self):
        return self._corresponds

    @corresponds.setter
    def corresponds(self, value):
        # INVERSE argument
        raise AssertionError('Argument corresponds is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcdistributionelementtype #
####################
class ifcdistributionelementtype(ifcelementtype):
    '''Entity ifcdistributionelementtype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__representationmaps, inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcdistributionflowelementtype #
####################
class ifcdistributionflowelementtype(ifcdistributionelementtype):
    '''Entity ifcdistributionflowelementtype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcdistributionelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__applicableoccurrence,
                                            inherited5__haspropertysets, inherited6__representationmaps,
                                            inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcflowterminaltype #
####################
class ifcflowterminaltype(ifcdistributionflowelementtype):
    '''Entity ifcflowterminaltype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcdistributionflowelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                                inherited3__description, inherited4__applicableoccurrence,
                                                inherited5__haspropertysets, inherited6__representationmaps,
                                                inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcspaceheatertype #
####################
class ifcspaceheatertype(ifcflowterminaltype):
    '''Entity ifcspaceheatertype definition.

	:param predefinedtype
	:type predefinedtype:ifcspaceheatertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowterminaltype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__applicableoccurrence,
                                     inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                     inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcspaceheatertypeenum):
            self._predefinedtype = ifcspaceheatertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcspaceheatertypeenum.userdefined) or (
                    (self.predefinedtype == ifcspaceheatertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifctimeseriesvalue #
####################
class ifctimeseriesvalue(BaseEntityClass):
    '''Entity ifctimeseriesvalue definition.

	:param listvalues
	:type listvalues:LIST(1,None,'ifcvalue', scope = schema_scope)
	'''

    def __init__(self, listvalues, ):
        self._listvalues = listvalues

    @property
    def listvalues(self):
        return self._listvalues

    @listvalues.setter
    def listvalues(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcvalue', scope=schema_scope)):
            self._listvalues = LIST(value)
        else:
            self._listvalues = value


####################
# ENTITY ifcflowstoragedevice #
####################
class ifcflowstoragedevice(ifcdistributionflowelement):
    '''Entity ifcflowstoragedevice definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcdistributionflowelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation, inherited7__tag, )


####################
# ENTITY ifclightdistributiondata #
####################
class ifclightdistributiondata(BaseEntityClass):
    '''Entity ifclightdistributiondata definition.

	:param mainplaneangle
	:type mainplaneangle:ifcplaneanglemeasure

	:param secondaryplaneangle
	:type secondaryplaneangle:LIST(1,None,'REAL', scope = schema_scope)

	:param luminousintensity
	:type luminousintensity:LIST(1,None,'REAL', scope = schema_scope)
	'''

    def __init__(self, mainplaneangle, secondaryplaneangle, luminousintensity, ):
        self._mainplaneangle = mainplaneangle
        self._secondaryplaneangle = secondaryplaneangle
        self._luminousintensity = luminousintensity

    @property
    def mainplaneangle(self):
        return self._mainplaneangle

    @mainplaneangle.setter
    def mainplaneangle(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcplaneanglemeasure):
            self._mainplaneangle = ifcplaneanglemeasure(value)
        else:
            self._mainplaneangle = value

    @property
    def secondaryplaneangle(self):
        return self._secondaryplaneangle

    @secondaryplaneangle.setter
    def secondaryplaneangle(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'REAL', scope=schema_scope)):
            self._secondaryplaneangle = LIST(value)
        else:
            self._secondaryplaneangle = value

    @property
    def luminousintensity(self):
        return self._luminousintensity

    @luminousintensity.setter
    def luminousintensity(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'REAL', scope=schema_scope)):
            self._luminousintensity = LIST(value)
        else:
            self._luminousintensity = value


####################
# ENTITY ifcrelassigns #
####################
class ifcrelassigns(ifcrelationship):
    '''Entity ifcrelassigns definition.

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcobjectdefinition', scope = schema_scope)

	:param relatedobjectstype
	:type relatedobjectstype:ifcobjecttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatedobjects, relatedobjectstype, ):
        ifcrelationship.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, )
        self._relatedobjects = relatedobjects
        self._relatedobjectstype = relatedobjectstype

    @property
    def relatedobjects(self):
        return self._relatedobjects

    @relatedobjects.setter
    def relatedobjects(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcobjectdefinition', scope=schema_scope)):
            self._relatedobjects = SET(value)
        else:
            self._relatedobjects = value

    @property
    def relatedobjectstype(self):
        return self._relatedobjectstype

    @relatedobjectstype.setter
    def relatedobjectstype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcobjecttypeenum):
                self._relatedobjectstype = ifcobjecttypeenum(value)
            else:
                self._relatedobjectstype = value
        else:
            self._relatedobjectstype = value

    def wr1(self):
        eval_wr1_wr = ifccorrectobjectassignment(self.relatedobjectstype, self.relatedobjects)
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


####################
# ENTITY ifcrelassignstogroup #
####################
class ifcrelassignstogroup(ifcrelassigns):
    '''Entity ifcrelassignstogroup definition.

	:param relatinggroup
	:type relatinggroup:ifcgroup
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatedobjects, inherited5__relatedobjectstype, relatinggroup, ):
        ifcrelassigns.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                               inherited3__description, inherited4__relatedobjects, inherited5__relatedobjectstype, )
        self._relatinggroup = relatinggroup

    @property
    def relatinggroup(self):
        return self._relatinggroup

    @relatinggroup.setter
    def relatinggroup(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcgroup):
            self._relatinggroup = ifcgroup(value)
        else:
            self._relatinggroup = value

    def noselfreference(self):
        eval_noselfreference_wr = (SIZEOF(None) == 0)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifcrelassignstoresource #
####################
class ifcrelassignstoresource(ifcrelassigns):
    '''Entity ifcrelassignstoresource definition.

	:param relatingresource
	:type relatingresource:ifcresourceselect
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatedobjects, inherited5__relatedobjectstype, relatingresource, ):
        ifcrelassigns.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                               inherited3__description, inherited4__relatedobjects, inherited5__relatedobjectstype, )
        self._relatingresource = relatingresource

    @property
    def relatingresource(self):
        return self._relatingresource

    @relatingresource.setter
    def relatingresource(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcresourceselect):
            self._relatingresource = ifcresourceselect(value)
        else:
            self._relatingresource = value

    def noselfreference(self):
        eval_noselfreference_wr = (SIZEOF(None) == 0)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifcstairtype #
####################
class ifcstairtype(ifcbuildingelementtype):
    '''Entity ifcstairtype definition.

	:param predefinedtype
	:type predefinedtype:ifcstairtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstairtypeenum):
            self._predefinedtype = ifcstairtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcstairtypeenum.userdefined) or (
                    (self.predefinedtype == ifcstairtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcslippageconnectioncondition #
####################
class ifcslippageconnectioncondition(ifcstructuralconnectioncondition):
    '''Entity ifcslippageconnectioncondition definition.

	:param slippagex
	:type slippagex:ifclengthmeasure

	:param slippagey
	:type slippagey:ifclengthmeasure

	:param slippagez
	:type slippagez:ifclengthmeasure
	'''

    def __init__(self, inherited0__name, slippagex, slippagey, slippagez, ):
        ifcstructuralconnectioncondition.__init__(self, inherited0__name, )
        self._slippagex = slippagex
        self._slippagey = slippagey
        self._slippagez = slippagez

    @property
    def slippagex(self):
        return self._slippagex

    @slippagex.setter
    def slippagex(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._slippagex = ifclengthmeasure(value)
            else:
                self._slippagex = value
        else:
            self._slippagex = value

    @property
    def slippagey(self):
        return self._slippagey

    @slippagey.setter
    def slippagey(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._slippagey = ifclengthmeasure(value)
            else:
                self._slippagey = value
        else:
            self._slippagey = value

    @property
    def slippagez(self):
        return self._slippagez

    @slippagez.setter
    def slippagez(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._slippagez = ifclengthmeasure(value)
            else:
                self._slippagez = value
        else:
            self._slippagez = value


####################
# ENTITY ifcactuator #
####################
class ifcactuator(ifcdistributioncontrolelement):
    '''Entity ifcactuator definition.

	:param predefinedtype
	:type predefinedtype:ifcactuatortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcdistributioncontrolelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__objecttype,
                                               inherited5__objectplacement, inherited6__representation,
                                               inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcactuatortypeenum):
                self._predefinedtype = ifcactuatortypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcactuatortypeenum.userdefined)) or (
                        (self.predefinedtype == ifcactuatortypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCACTUATORTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifccontextdependentunit #
####################
class ifccontextdependentunit(ifcnamedunit):
    '''Entity ifccontextdependentunit definition.

	:param name
	:type name:ifclabel

	:param hasexternalreference
	:type hasexternalreference:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''

    def __init__(self, inherited0__dimensions, inherited1__unittype, name, ):
        ifcnamedunit.__init__(self, inherited0__dimensions, inherited1__unittype, )
        self._name = name

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value

    @property
    def hasexternalreference(self):
        return self._hasexternalreference

    @hasexternalreference.setter
    def hasexternalreference(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasexternalreference is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcpropertydefinition #
####################
class ifcpropertydefinition(ifcroot):
    '''Entity ifcpropertydefinition definition.

	:param hascontext
	:type hascontext:SET(0,1,'ifcreldeclares', scope = schema_scope)

	:param hasassociations
	:type hasassociations:SET(0,None,'ifcrelassociates', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description, ):
        ifcroot.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                         inherited3__description, )

    @property
    def hascontext(self):
        return self._hascontext

    @hascontext.setter
    def hascontext(self, value):
        # INVERSE argument
        raise AssertionError('Argument hascontext is INVERSE. It is computed and can not be set to any value')

    @property
    def hasassociations(self):
        return self._hasassociations

    @hasassociations.setter
    def hasassociations(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasassociations is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcpropertytemplatedefinition #
####################
class ifcpropertytemplatedefinition(ifcpropertydefinition):
    '''Entity ifcpropertytemplatedefinition definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description, ):
        ifcpropertydefinition.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, )


####################
# ENTITY ifcpropertysettemplate #
####################
class ifcpropertysettemplate(ifcpropertytemplatedefinition):
    '''Entity ifcpropertysettemplate definition.

	:param templatetype
	:type templatetype:ifcpropertysettemplatetypeenum

	:param applicableentity
	:type applicableentity:ifcidentifier

	:param haspropertytemplates
	:type haspropertytemplates:SET(1,None,'ifcpropertytemplate', scope = schema_scope)

	:param defines
	:type defines:SET(0,None,'ifcreldefinesbytemplate', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 templatetype, applicableentity, haspropertytemplates, ):
        ifcpropertytemplatedefinition.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, )
        self._templatetype = templatetype
        self._applicableentity = applicableentity
        self._haspropertytemplates = haspropertytemplates

    @property
    def templatetype(self):
        return self._templatetype

    @templatetype.setter
    def templatetype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpropertysettemplatetypeenum):
                self._templatetype = ifcpropertysettemplatetypeenum(value)
            else:
                self._templatetype = value
        else:
            self._templatetype = value

    @property
    def applicableentity(self):
        return self._applicableentity

    @applicableentity.setter
    def applicableentity(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._applicableentity = ifcidentifier(value)
            else:
                self._applicableentity = value
        else:
            self._applicableentity = value

    @property
    def haspropertytemplates(self):
        return self._haspropertytemplates

    @haspropertytemplates.setter
    def haspropertytemplates(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcpropertytemplate', scope=schema_scope)):
            self._haspropertytemplates = SET(value)
        else:
            self._haspropertytemplates = value

    @property
    def defines(self):
        return self._defines

    @defines.setter
    def defines(self, value):
        # INVERSE argument
        raise AssertionError('Argument defines is INVERSE. It is computed and can not be set to any value')

    def existsname(self):
        eval_existsname_wr = EXISTS(self.self.ifcroot.self.name)
        if not eval_existsname_wr:
            raise AssertionError('Rule existsname violated')
        else:
            return eval_existsname_wr

    def uniquepropertynames(self):
        eval_uniquepropertynames_wr = ifcuniquepropertytemplatenames(self.haspropertytemplates)
        if not eval_uniquepropertynames_wr:
            raise AssertionError('Rule uniquepropertynames violated')
        else:
            return eval_uniquepropertynames_wr


####################
# ENTITY ifcenergyconversiondevicetype #
####################
class ifcenergyconversiondevicetype(ifcdistributionflowelementtype):
    '''Entity ifcenergyconversiondevicetype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcdistributionflowelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                                inherited3__description, inherited4__applicableoccurrence,
                                                inherited5__haspropertysets, inherited6__representationmaps,
                                                inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcflowcontrollertype #
####################
class ifcflowcontrollertype(ifcdistributionflowelementtype):
    '''Entity ifcflowcontrollertype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcdistributionflowelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                                inherited3__description, inherited4__applicableoccurrence,
                                                inherited5__haspropertysets, inherited6__representationmaps,
                                                inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcstairflight #
####################
class ifcstairflight(ifcbuildingelement):
    '''Entity ifcstairflight definition.

	:param numberofrisers
	:type numberofrisers:ifcinteger

	:param numberoftreads
	:type numberoftreads:ifcinteger

	:param riserheight
	:type riserheight:ifcpositivelengthmeasure

	:param treadlength
	:type treadlength:ifcpositivelengthmeasure

	:param predefinedtype
	:type predefinedtype:ifcstairflighttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 numberofrisers, numberoftreads, riserheight, treadlength, predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._numberofrisers = numberofrisers
        self._numberoftreads = numberoftreads
        self._riserheight = riserheight
        self._treadlength = treadlength
        self._predefinedtype = predefinedtype

    @property
    def numberofrisers(self):
        return self._numberofrisers

    @numberofrisers.setter
    def numberofrisers(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcinteger):
                self._numberofrisers = ifcinteger(value)
            else:
                self._numberofrisers = value
        else:
            self._numberofrisers = value

    @property
    def numberoftreads(self):
        return self._numberoftreads

    @numberoftreads.setter
    def numberoftreads(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcinteger):
                self._numberoftreads = ifcinteger(value)
            else:
                self._numberoftreads = value
        else:
            self._numberoftreads = value

    @property
    def riserheight(self):
        return self._riserheight

    @riserheight.setter
    def riserheight(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._riserheight = ifcpositivelengthmeasure(value)
            else:
                self._riserheight = value
        else:
            self._riserheight = value

    @property
    def treadlength(self):
        return self._treadlength

    @treadlength.setter
    def treadlength(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._treadlength = ifcpositivelengthmeasure(value)
            else:
                self._treadlength = value
        else:
            self._treadlength = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcstairflighttypeenum):
                self._predefinedtype = ifcstairflighttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcstairflighttypeenum.userdefined)) or ((
                                                                                                self.predefinedtype == ifcstairflighttypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCSTAIRFLIGHTTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcsurfacestyleshading #
####################
class ifcsurfacestyleshading(ifcpresentationitem):
    '''Entity ifcsurfacestyleshading definition.

	:param surfacecolour
	:type surfacecolour:ifccolourrgb

	:param transparency
	:type transparency:ifcnormalisedratiomeasure
	'''

    def __init__(self, surfacecolour, transparency, ):
        ifcpresentationitem.__init__(self, )
        self._surfacecolour = surfacecolour
        self._transparency = transparency

    @property
    def surfacecolour(self):
        return self._surfacecolour

    @surfacecolour.setter
    def surfacecolour(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccolourrgb):
            self._surfacecolour = ifccolourrgb(value)
        else:
            self._surfacecolour = value

    @property
    def transparency(self):
        return self._transparency

    @transparency.setter
    def transparency(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnormalisedratiomeasure):
                self._transparency = ifcnormalisedratiomeasure(value)
            else:
                self._transparency = value
        else:
            self._transparency = value


####################
# ENTITY ifcmaterialrelationship #
####################
class ifcmaterialrelationship(ifcresourcelevelrelationship):
    '''Entity ifcmaterialrelationship definition.

	:param relatingmaterial
	:type relatingmaterial:ifcmaterial

	:param relatedmaterials
	:type relatedmaterials:SET(1,None,'ifcmaterial', scope = schema_scope)

	:param expression
	:type expression:ifclabel
	'''

    def __init__(self, inherited0__name, inherited1__description, relatingmaterial, relatedmaterials, expression, ):
        ifcresourcelevelrelationship.__init__(self, inherited0__name, inherited1__description, )
        self._relatingmaterial = relatingmaterial
        self._relatedmaterials = relatedmaterials
        self._expression = expression

    @property
    def relatingmaterial(self):
        return self._relatingmaterial

    @relatingmaterial.setter
    def relatingmaterial(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmaterial):
            self._relatingmaterial = ifcmaterial(value)
        else:
            self._relatingmaterial = value

    @property
    def relatedmaterials(self):
        return self._relatedmaterials

    @relatedmaterials.setter
    def relatedmaterials(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcmaterial', scope=schema_scope)):
            self._relatedmaterials = SET(value)
        else:
            self._relatedmaterials = value

    @property
    def expression(self):
        return self._expression

    @expression.setter
    def expression(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._expression = ifclabel(value)
            else:
                self._expression = value
        else:
            self._expression = value


####################
# ENTITY ifctexturevertexlist #
####################
class ifctexturevertexlist(ifcpresentationitem):
    '''Entity ifctexturevertexlist definition.

	:param texcoordslist
	:type texcoordslist:LIST(1,None,LIST(2,2,'REAL', scope = schema_scope))
	'''

    def __init__(self, texcoordslist, ):
        ifcpresentationitem.__init__(self, )
        self._texcoordslist = texcoordslist

    @property
    def texcoordslist(self):
        return self._texcoordslist

    @texcoordslist.setter
    def texcoordslist(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, LIST(2, 2, 'REAL', scope=schema_scope))):
            self._texcoordslist = LIST(value)
        else:
            self._texcoordslist = value


####################
# ENTITY ifcdocumentinformationrelationship #
####################
class ifcdocumentinformationrelationship(ifcresourcelevelrelationship):
    '''Entity ifcdocumentinformationrelationship definition.

	:param relatingdocument
	:type relatingdocument:ifcdocumentinformation

	:param relateddocuments
	:type relateddocuments:SET(1,None,'ifcdocumentinformation', scope = schema_scope)

	:param relationshiptype
	:type relationshiptype:ifclabel
	'''

    def __init__(self, inherited0__name, inherited1__description, relatingdocument, relateddocuments,
                 relationshiptype, ):
        ifcresourcelevelrelationship.__init__(self, inherited0__name, inherited1__description, )
        self._relatingdocument = relatingdocument
        self._relateddocuments = relateddocuments
        self._relationshiptype = relationshiptype

    @property
    def relatingdocument(self):
        return self._relatingdocument

    @relatingdocument.setter
    def relatingdocument(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdocumentinformation):
            self._relatingdocument = ifcdocumentinformation(value)
        else:
            self._relatingdocument = value

    @property
    def relateddocuments(self):
        return self._relateddocuments

    @relateddocuments.setter
    def relateddocuments(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcdocumentinformation', scope=schema_scope)):
            self._relateddocuments = SET(value)
        else:
            self._relateddocuments = value

    @property
    def relationshiptype(self):
        return self._relationshiptype

    @relationshiptype.setter
    def relationshiptype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._relationshiptype = ifclabel(value)
            else:
                self._relationshiptype = value
        else:
            self._relationshiptype = value


####################
# ENTITY ifcstructuralactivity #
####################
class ifcstructuralactivity(ifcproduct):
    '''Entity ifcstructuralactivity definition.

	:param appliedload
	:type appliedload:ifcstructuralload

	:param globalorlocal
	:type globalorlocal:ifcglobalorlocalenum

	:param assignedtostructuralitem
	:type assignedtostructuralitem:SET(0,1,'ifcrelconnectsstructuralactivity', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, appliedload,
                 globalorlocal, ):
        ifcproduct.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, )
        self._appliedload = appliedload
        self._globalorlocal = globalorlocal

    @property
    def appliedload(self):
        return self._appliedload

    @appliedload.setter
    def appliedload(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstructuralload):
            self._appliedload = ifcstructuralload(value)
        else:
            self._appliedload = value

    @property
    def globalorlocal(self):
        return self._globalorlocal

    @globalorlocal.setter
    def globalorlocal(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcglobalorlocalenum):
            self._globalorlocal = ifcglobalorlocalenum(value)
        else:
            self._globalorlocal = value

    @property
    def assignedtostructuralitem(self):
        return self._assignedtostructuralitem

    @assignedtostructuralitem.setter
    def assignedtostructuralitem(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument assignedtostructuralitem is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcstructuralaction #
####################
class ifcstructuralaction(ifcstructuralactivity):
    '''Entity ifcstructuralaction definition.

	:param destabilizingload
	:type destabilizingload:ifcboolean
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__appliedload, inherited8__globalorlocal, destabilizingload, ):
        ifcstructuralactivity.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                       inherited6__representation, inherited7__appliedload, inherited8__globalorlocal, )
        self._destabilizingload = destabilizingload

    @property
    def destabilizingload(self):
        return self._destabilizingload

    @destabilizingload.setter
    def destabilizingload(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._destabilizingload = ifcboolean(value)
            else:
                self._destabilizingload = value
        else:
            self._destabilizingload = value


####################
# ENTITY ifcstructuralsurfaceaction #
####################
class ifcstructuralsurfaceaction(ifcstructuralaction):
    '''Entity ifcstructuralsurfaceaction definition.

	:param projectedortrue
	:type projectedortrue:ifcprojectedortruelengthenum

	:param predefinedtype
	:type predefinedtype:ifcstructuralsurfaceactivitytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__appliedload, inherited8__globalorlocal, inherited9__destabilizingload, projectedortrue,
                 predefinedtype, ):
        ifcstructuralaction.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, inherited7__appliedload, inherited8__globalorlocal,
                                     inherited9__destabilizingload, )
        self._projectedortrue = projectedortrue
        self._predefinedtype = predefinedtype

    @property
    def projectedortrue(self):
        return self._projectedortrue

    @projectedortrue.setter
    def projectedortrue(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcprojectedortruelengthenum):
                self._projectedortrue = ifcprojectedortruelengthenum(value)
            else:
                self._projectedortrue = value
        else:
            self._projectedortrue = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstructuralsurfaceactivitytypeenum):
            self._predefinedtype = ifcstructuralsurfaceactivitytypeenum(value)
        else:
            self._predefinedtype = value

    def projectedisglobal(self):
        eval_projectedisglobal_wr = ((not EXISTS(self.projectedortrue)) or (
                    (self.projectedortrue != ifcprojectedortruelengthenum.projected_length) or (
                        self.self.ifcstructuralactivity.self.globalorlocal == ifcglobalorlocalenum.global_coords)))
        if not eval_projectedisglobal_wr:
            raise AssertionError('Rule projectedisglobal violated')
        else:
            return eval_projectedisglobal_wr

    def hasobjecttype(self):
        eval_hasobjecttype_wr = ((self.predefinedtype != ifcstructuralsurfaceactivitytypeenum.userdefined) or EXISTS(
            self.self.ifcobject.self.objecttype))
        if not eval_hasobjecttype_wr:
            raise AssertionError('Rule hasobjecttype violated')
        else:
            return eval_hasobjecttype_wr


####################
# ENTITY ifczshapeprofiledef #
####################
class ifczshapeprofiledef(ifcparameterizedprofiledef):
    '''Entity ifczshapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param flangewidth
	:type flangewidth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param flangethickness
	:type flangethickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcnonnegativelengthmeasure

	:param edgeradius
	:type edgeradius:ifcnonnegativelengthmeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, depth, flangewidth,
                 webthickness, flangethickness, filletradius, edgeradius, ):
        ifcparameterizedprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename,
                                            inherited2__position, )
        self._depth = depth
        self._flangewidth = flangewidth
        self._webthickness = webthickness
        self._flangethickness = flangethickness
        self._filletradius = filletradius
        self._edgeradius = edgeradius

    @property
    def depth(self):
        return self._depth

    @depth.setter
    def depth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._depth = ifcpositivelengthmeasure(value)
        else:
            self._depth = value

    @property
    def flangewidth(self):
        return self._flangewidth

    @flangewidth.setter
    def flangewidth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._flangewidth = ifcpositivelengthmeasure(value)
        else:
            self._flangewidth = value

    @property
    def webthickness(self):
        return self._webthickness

    @webthickness.setter
    def webthickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._webthickness = ifcpositivelengthmeasure(value)
        else:
            self._webthickness = value

    @property
    def flangethickness(self):
        return self._flangethickness

    @flangethickness.setter
    def flangethickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._flangethickness = ifcpositivelengthmeasure(value)
        else:
            self._flangethickness = value

    @property
    def filletradius(self):
        return self._filletradius

    @filletradius.setter
    def filletradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._filletradius = ifcnonnegativelengthmeasure(value)
            else:
                self._filletradius = value
        else:
            self._filletradius = value

    @property
    def edgeradius(self):
        return self._edgeradius

    @edgeradius.setter
    def edgeradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._edgeradius = ifcnonnegativelengthmeasure(value)
            else:
                self._edgeradius = value
        else:
            self._edgeradius = value

    def validflangethickness(self):
        eval_validflangethickness_wr = (self.flangethickness < (self.depth / 2))
        if not eval_validflangethickness_wr:
            raise AssertionError('Rule validflangethickness violated')
        else:
            return eval_validflangethickness_wr


####################
# ENTITY ifccontrol #
####################
class ifccontrol(ifcobject):
    '''Entity ifccontrol definition.

	:param identification
	:type identification:ifcidentifier

	:param controls
	:type controls:SET(0,None,'ifcrelassignstocontrol', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, identification, ):
        ifcobject.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                           inherited3__description, inherited4__objecttype, )
        self._identification = identification

    @property
    def identification(self):
        return self._identification

    @identification.setter
    def identification(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._identification = ifcidentifier(value)
            else:
                self._identification = value
        else:
            self._identification = value

    @property
    def controls(self):
        return self._controls

    @controls.setter
    def controls(self, value):
        # INVERSE argument
        raise AssertionError('Argument controls is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcactionrequest #
####################
class ifcactionrequest(ifccontrol):
    '''Entity ifcactionrequest definition.

	:param predefinedtype
	:type predefinedtype:ifcactionrequesttypeenum

	:param status
	:type status:ifclabel

	:param longdescription
	:type longdescription:ifctext
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, predefinedtype, status, longdescription, ):
        ifccontrol.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__identification, )
        self._predefinedtype = predefinedtype
        self._status = status
        self._longdescription = longdescription

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcactionrequesttypeenum):
                self._predefinedtype = ifcactionrequesttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def status(self):
        return self._status

    @status.setter
    def status(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._status = ifclabel(value)
            else:
                self._status = value
        else:
            self._status = value

    @property
    def longdescription(self):
        return self._longdescription

    @longdescription.setter
    def longdescription(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._longdescription = ifctext(value)
            else:
                self._longdescription = value
        else:
            self._longdescription = value


####################
# ENTITY ifcperson #
####################
class ifcperson(BaseEntityClass):
    '''Entity ifcperson definition.

	:param identification
	:type identification:ifcidentifier

	:param familyname
	:type familyname:ifclabel

	:param givenname
	:type givenname:ifclabel

	:param middlenames
	:type middlenames:LIST(1,None,'STRING', scope = schema_scope)

	:param prefixtitles
	:type prefixtitles:LIST(1,None,'STRING', scope = schema_scope)

	:param suffixtitles
	:type suffixtitles:LIST(1,None,'STRING', scope = schema_scope)

	:param roles
	:type roles:LIST(1,None,'ifcactorrole', scope = schema_scope)

	:param addresses
	:type addresses:LIST(1,None,'ifcaddress', scope = schema_scope)

	:param engagedin
	:type engagedin:SET(0,None,'ifcpersonandorganization', scope = schema_scope)
	'''

    def __init__(self, identification, familyname, givenname, middlenames, prefixtitles, suffixtitles, roles,
                 addresses, ):
        self._identification = identification
        self._familyname = familyname
        self._givenname = givenname
        self._middlenames = middlenames
        self._prefixtitles = prefixtitles
        self._suffixtitles = suffixtitles
        self._roles = roles
        self._addresses = addresses

    @property
    def identification(self):
        return self._identification

    @identification.setter
    def identification(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._identification = ifcidentifier(value)
            else:
                self._identification = value
        else:
            self._identification = value

    @property
    def familyname(self):
        return self._familyname

    @familyname.setter
    def familyname(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._familyname = ifclabel(value)
            else:
                self._familyname = value
        else:
            self._familyname = value

    @property
    def givenname(self):
        return self._givenname

    @givenname.setter
    def givenname(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._givenname = ifclabel(value)
            else:
                self._givenname = value
        else:
            self._givenname = value

    @property
    def middlenames(self):
        return self._middlenames

    @middlenames.setter
    def middlenames(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'STRING', scope=schema_scope)):
                self._middlenames = LIST(value)
            else:
                self._middlenames = value
        else:
            self._middlenames = value

    @property
    def prefixtitles(self):
        return self._prefixtitles

    @prefixtitles.setter
    def prefixtitles(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'STRING', scope=schema_scope)):
                self._prefixtitles = LIST(value)
            else:
                self._prefixtitles = value
        else:
            self._prefixtitles = value

    @property
    def suffixtitles(self):
        return self._suffixtitles

    @suffixtitles.setter
    def suffixtitles(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'STRING', scope=schema_scope)):
                self._suffixtitles = LIST(value)
            else:
                self._suffixtitles = value
        else:
            self._suffixtitles = value

    @property
    def roles(self):
        return self._roles

    @roles.setter
    def roles(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcactorrole', scope=schema_scope)):
                self._roles = LIST(value)
            else:
                self._roles = value
        else:
            self._roles = value

    @property
    def addresses(self):
        return self._addresses

    @addresses.setter
    def addresses(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcaddress', scope=schema_scope)):
                self._addresses = LIST(value)
            else:
                self._addresses = value
        else:
            self._addresses = value

    @property
    def engagedin(self):
        return self._engagedin

    @engagedin.setter
    def engagedin(self, value):
        # INVERSE argument
        raise AssertionError('Argument engagedin is INVERSE. It is computed and can not be set to any value')

    def identifiableperson(self):
        eval_identifiableperson_wr = (
                    (EXISTS(self.identification) or EXISTS(self.familyname)) or EXISTS(self.givenname))
        if not eval_identifiableperson_wr:
            raise AssertionError('Rule identifiableperson violated')
        else:
            return eval_identifiableperson_wr

    def validsetofnames(self):
        eval_validsetofnames_wr = (
                    ((not EXISTS(self.middlenames)) or EXISTS(self.familyname)) or EXISTS(self.givenname))
        if not eval_validsetofnames_wr:
            raise AssertionError('Rule validsetofnames violated')
        else:
            return eval_validsetofnames_wr


####################
# ENTITY ifcproductrepresentation #
####################
class ifcproductrepresentation(BaseEntityClass):
    '''Entity ifcproductrepresentation definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param representations
	:type representations:LIST(1,None,'ifcrepresentation', scope = schema_scope)
	'''

    def __init__(self, name, description, representations, ):
        self._name = name
        self._description = description
        self._representations = representations

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def representations(self):
        return self._representations

    @representations.setter
    def representations(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcrepresentation', scope=schema_scope)):
            self._representations = LIST(value)
        else:
            self._representations = value


####################
# ENTITY ifcrelconnectsporttoelement #
####################
class ifcrelconnectsporttoelement(ifcrelconnects):
    '''Entity ifcrelconnectsporttoelement definition.

	:param relatingport
	:type relatingport:ifcport

	:param relatedelement
	:type relatedelement:ifcdistributionelement
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingport, relatedelement, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatingport = relatingport
        self._relatedelement = relatedelement

    @property
    def relatingport(self):
        return self._relatingport

    @relatingport.setter
    def relatingport(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcport):
            self._relatingport = ifcport(value)
        else:
            self._relatingport = value

    @property
    def relatedelement(self):
        return self._relatedelement

    @relatedelement.setter
    def relatedelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdistributionelement):
            self._relatedelement = ifcdistributionelement(value)
        else:
            self._relatedelement = value


####################
# ENTITY ifcstairflighttype #
####################
class ifcstairflighttype(ifcbuildingelementtype):
    '''Entity ifcstairflighttype definition.

	:param predefinedtype
	:type predefinedtype:ifcstairflighttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstairflighttypeenum):
            self._predefinedtype = ifcstairflighttypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcstairflighttypeenum.userdefined) or (
                    (self.predefinedtype == ifcstairflighttypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcflowterminal #
####################
class ifcflowterminal(ifcdistributionflowelement):
    '''Entity ifcflowterminal definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcdistributionflowelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation, inherited7__tag, )


####################
# ENTITY ifcwasteterminal #
####################
class ifcwasteterminal(ifcflowterminal):
    '''Entity ifcwasteterminal definition.

	:param predefinedtype
	:type predefinedtype:ifcwasteterminaltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowterminal.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcwasteterminaltypeenum):
                self._predefinedtype = ifcwasteterminaltypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcwasteterminaltypeenum.userdefined)) or ((
                                                                                                  self.predefinedtype == ifcwasteterminaltypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCWASTETERMINALTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcflowsegmenttype #
####################
class ifcflowsegmenttype(ifcdistributionflowelementtype):
    '''Entity ifcflowsegmenttype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcdistributionflowelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                                inherited3__description, inherited4__applicableoccurrence,
                                                inherited5__haspropertysets, inherited6__representationmaps,
                                                inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcductsegmenttype #
####################
class ifcductsegmenttype(ifcflowsegmenttype):
    '''Entity ifcductsegmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifcductsegmenttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowsegmenttype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__applicableoccurrence,
                                    inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                    inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcductsegmenttypeenum):
            self._predefinedtype = ifcductsegmenttypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcductsegmenttypeenum.userdefined) or (
                    (self.predefinedtype == ifcductsegmenttypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcflowtreatmentdevicetype #
####################
class ifcflowtreatmentdevicetype(ifcdistributionflowelementtype):
    '''Entity ifcflowtreatmentdevicetype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcdistributionflowelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                                inherited3__description, inherited4__applicableoccurrence,
                                                inherited5__haspropertysets, inherited6__representationmaps,
                                                inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcenergyconversiondevice #
####################
class ifcenergyconversiondevice(ifcdistributionflowelement):
    '''Entity ifcenergyconversiondevice definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcdistributionflowelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation, inherited7__tag, )


####################
# ENTITY ifcunitaryequipment #
####################
class ifcunitaryequipment(ifcenergyconversiondevice):
    '''Entity ifcunitaryequipment definition.

	:param predefinedtype
	:type predefinedtype:ifcunitaryequipmenttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcunitaryequipmenttypeenum):
                self._predefinedtype = ifcunitaryequipmenttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcunitaryequipmenttypeenum.userdefined)) or ((
                                                                                                     self.predefinedtype == ifcunitaryequipmenttypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCUNITARYEQUIPMENTTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcconic #
####################
class ifcconic(ifccurve):
    '''Entity ifcconic definition.

	:param position
	:type position:ifcaxis2placement
	'''

    def __init__(self, position, ):
        ifccurve.__init__(self, )
        self._position = position

    @property
    def position(self):
        return self._position

    @position.setter
    def position(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcaxis2placement):
            self._position = ifcaxis2placement(value)
        else:
            self._position = value


####################
# ENTITY ifcellipse #
####################
class ifcellipse(ifcconic):
    '''Entity ifcellipse definition.

	:param semiaxis1
	:type semiaxis1:ifcpositivelengthmeasure

	:param semiaxis2
	:type semiaxis2:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__position, semiaxis1, semiaxis2, ):
        ifcconic.__init__(self, inherited0__position, )
        self._semiaxis1 = semiaxis1
        self._semiaxis2 = semiaxis2

    @property
    def semiaxis1(self):
        return self._semiaxis1

    @semiaxis1.setter
    def semiaxis1(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._semiaxis1 = ifcpositivelengthmeasure(value)
        else:
            self._semiaxis1 = value

    @property
    def semiaxis2(self):
        return self._semiaxis2

    @semiaxis2.setter
    def semiaxis2(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._semiaxis2 = ifcpositivelengthmeasure(value)
        else:
            self._semiaxis2 = value


####################
# ENTITY ifcflowfittingtype #
####################
class ifcflowfittingtype(ifcdistributionflowelementtype):
    '''Entity ifcflowfittingtype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcdistributionflowelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                                inherited3__description, inherited4__applicableoccurrence,
                                                inherited5__haspropertysets, inherited6__representationmaps,
                                                inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcinterceptortype #
####################
class ifcinterceptortype(ifcflowtreatmentdevicetype):
    '''Entity ifcinterceptortype definition.

	:param predefinedtype
	:type predefinedtype:ifcinterceptortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowtreatmentdevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__applicableoccurrence,
                                            inherited5__haspropertysets, inherited6__representationmaps,
                                            inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcinterceptortypeenum):
            self._predefinedtype = ifcinterceptortypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcinterceptortypeenum.userdefined) or (
                    (self.predefinedtype == ifcinterceptortypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcreinforcingmeshtype #
####################
class ifcreinforcingmeshtype(ifcreinforcingelementtype):
    '''Entity ifcreinforcingmeshtype definition.

	:param predefinedtype
	:type predefinedtype:ifcreinforcingmeshtypeenum

	:param meshlength
	:type meshlength:ifcpositivelengthmeasure

	:param meshwidth
	:type meshwidth:ifcpositivelengthmeasure

	:param longitudinalbarnominaldiameter
	:type longitudinalbarnominaldiameter:ifcpositivelengthmeasure

	:param transversebarnominaldiameter
	:type transversebarnominaldiameter:ifcpositivelengthmeasure

	:param longitudinalbarcrosssectionarea
	:type longitudinalbarcrosssectionarea:ifcareameasure

	:param transversebarcrosssectionarea
	:type transversebarcrosssectionarea:ifcareameasure

	:param longitudinalbarspacing
	:type longitudinalbarspacing:ifcpositivelengthmeasure

	:param transversebarspacing
	:type transversebarspacing:ifcpositivelengthmeasure

	:param bendingshapecode
	:type bendingshapecode:ifclabel

	:param bendingparameters
	:type bendingparameters:LIST(1,None,'ifcbendingparameterselect', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, meshlength, meshwidth,
                 longitudinalbarnominaldiameter, transversebarnominaldiameter, longitudinalbarcrosssectionarea,
                 transversebarcrosssectionarea, longitudinalbarspacing, transversebarspacing, bendingshapecode,
                 bendingparameters, ):
        ifcreinforcingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__applicableoccurrence,
                                           inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                           inherited8__elementtype, )
        self._predefinedtype = predefinedtype
        self._meshlength = meshlength
        self._meshwidth = meshwidth
        self._longitudinalbarnominaldiameter = longitudinalbarnominaldiameter
        self._transversebarnominaldiameter = transversebarnominaldiameter
        self._longitudinalbarcrosssectionarea = longitudinalbarcrosssectionarea
        self._transversebarcrosssectionarea = transversebarcrosssectionarea
        self._longitudinalbarspacing = longitudinalbarspacing
        self._transversebarspacing = transversebarspacing
        self._bendingshapecode = bendingshapecode
        self._bendingparameters = bendingparameters

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcreinforcingmeshtypeenum):
            self._predefinedtype = ifcreinforcingmeshtypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def meshlength(self):
        return self._meshlength

    @meshlength.setter
    def meshlength(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._meshlength = ifcpositivelengthmeasure(value)
            else:
                self._meshlength = value
        else:
            self._meshlength = value

    @property
    def meshwidth(self):
        return self._meshwidth

    @meshwidth.setter
    def meshwidth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._meshwidth = ifcpositivelengthmeasure(value)
            else:
                self._meshwidth = value
        else:
            self._meshwidth = value

    @property
    def longitudinalbarnominaldiameter(self):
        return self._longitudinalbarnominaldiameter

    @longitudinalbarnominaldiameter.setter
    def longitudinalbarnominaldiameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._longitudinalbarnominaldiameter = ifcpositivelengthmeasure(value)
            else:
                self._longitudinalbarnominaldiameter = value
        else:
            self._longitudinalbarnominaldiameter = value

    @property
    def transversebarnominaldiameter(self):
        return self._transversebarnominaldiameter

    @transversebarnominaldiameter.setter
    def transversebarnominaldiameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._transversebarnominaldiameter = ifcpositivelengthmeasure(value)
            else:
                self._transversebarnominaldiameter = value
        else:
            self._transversebarnominaldiameter = value

    @property
    def longitudinalbarcrosssectionarea(self):
        return self._longitudinalbarcrosssectionarea

    @longitudinalbarcrosssectionarea.setter
    def longitudinalbarcrosssectionarea(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcareameasure):
                self._longitudinalbarcrosssectionarea = ifcareameasure(value)
            else:
                self._longitudinalbarcrosssectionarea = value
        else:
            self._longitudinalbarcrosssectionarea = value

    @property
    def transversebarcrosssectionarea(self):
        return self._transversebarcrosssectionarea

    @transversebarcrosssectionarea.setter
    def transversebarcrosssectionarea(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcareameasure):
                self._transversebarcrosssectionarea = ifcareameasure(value)
            else:
                self._transversebarcrosssectionarea = value
        else:
            self._transversebarcrosssectionarea = value

    @property
    def longitudinalbarspacing(self):
        return self._longitudinalbarspacing

    @longitudinalbarspacing.setter
    def longitudinalbarspacing(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._longitudinalbarspacing = ifcpositivelengthmeasure(value)
            else:
                self._longitudinalbarspacing = value
        else:
            self._longitudinalbarspacing = value

    @property
    def transversebarspacing(self):
        return self._transversebarspacing

    @transversebarspacing.setter
    def transversebarspacing(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._transversebarspacing = ifcpositivelengthmeasure(value)
            else:
                self._transversebarspacing = value
        else:
            self._transversebarspacing = value

    @property
    def bendingshapecode(self):
        return self._bendingshapecode

    @bendingshapecode.setter
    def bendingshapecode(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._bendingshapecode = ifclabel(value)
            else:
                self._bendingshapecode = value
        else:
            self._bendingshapecode = value

    @property
    def bendingparameters(self):
        return self._bendingparameters

    @bendingparameters.setter
    def bendingparameters(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcbendingparameterselect', scope=schema_scope)):
                self._bendingparameters = LIST(value)
            else:
                self._bendingparameters = value
        else:
            self._bendingparameters = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcreinforcingmeshtypeenum.userdefined) or (
                    (self.predefinedtype == ifcreinforcingmeshtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def bendingshapecodeprovided(self):
        eval_bendingshapecodeprovided_wr = ((not EXISTS(self.bendingparameters)) or EXISTS(self.bendingshapecode))
        if not eval_bendingshapecodeprovided_wr:
            raise AssertionError('Rule bendingshapecodeprovided violated')
        else:
            return eval_bendingshapecodeprovided_wr


####################
# ENTITY ifcreinforcingelement #
####################
class ifcreinforcingelement(ifcelementcomponent):
    '''Entity ifcreinforcingelement definition.

	:param steelgrade
	:type steelgrade:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 steelgrade, ):
        ifcelementcomponent.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, inherited7__tag, )
        self._steelgrade = steelgrade

    @property
    def steelgrade(self):
        return self._steelgrade

    @steelgrade.setter
    def steelgrade(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._steelgrade = ifclabel(value)
            else:
                self._steelgrade = value
        else:
            self._steelgrade = value


####################
# ENTITY ifctendon #
####################
class ifctendon(ifcreinforcingelement):
    '''Entity ifctendon definition.

	:param predefinedtype
	:type predefinedtype:ifctendontypeenum

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param crosssectionarea
	:type crosssectionarea:ifcareameasure

	:param tensionforce
	:type tensionforce:ifcforcemeasure

	:param prestress
	:type prestress:ifcpressuremeasure

	:param frictioncoefficient
	:type frictioncoefficient:ifcnormalisedratiomeasure

	:param anchorageslip
	:type anchorageslip:ifcpositivelengthmeasure

	:param mincurvatureradius
	:type mincurvatureradius:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__steelgrade, predefinedtype, nominaldiameter, crosssectionarea, tensionforce, prestress,
                 frictioncoefficient, anchorageslip, mincurvatureradius, ):
        ifcreinforcingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                       inherited6__representation, inherited7__tag, inherited8__steelgrade, )
        self._predefinedtype = predefinedtype
        self._nominaldiameter = nominaldiameter
        self._crosssectionarea = crosssectionarea
        self._tensionforce = tensionforce
        self._prestress = prestress
        self._frictioncoefficient = frictioncoefficient
        self._anchorageslip = anchorageslip
        self._mincurvatureradius = mincurvatureradius

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctendontypeenum):
                self._predefinedtype = ifctendontypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def nominaldiameter(self):
        return self._nominaldiameter

    @nominaldiameter.setter
    def nominaldiameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._nominaldiameter = ifcpositivelengthmeasure(value)
            else:
                self._nominaldiameter = value
        else:
            self._nominaldiameter = value

    @property
    def crosssectionarea(self):
        return self._crosssectionarea

    @crosssectionarea.setter
    def crosssectionarea(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcareameasure):
                self._crosssectionarea = ifcareameasure(value)
            else:
                self._crosssectionarea = value
        else:
            self._crosssectionarea = value

    @property
    def tensionforce(self):
        return self._tensionforce

    @tensionforce.setter
    def tensionforce(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcforcemeasure):
                self._tensionforce = ifcforcemeasure(value)
            else:
                self._tensionforce = value
        else:
            self._tensionforce = value

    @property
    def prestress(self):
        return self._prestress

    @prestress.setter
    def prestress(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpressuremeasure):
                self._prestress = ifcpressuremeasure(value)
            else:
                self._prestress = value
        else:
            self._prestress = value

    @property
    def frictioncoefficient(self):
        return self._frictioncoefficient

    @frictioncoefficient.setter
    def frictioncoefficient(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnormalisedratiomeasure):
                self._frictioncoefficient = ifcnormalisedratiomeasure(value)
            else:
                self._frictioncoefficient = value
        else:
            self._frictioncoefficient = value

    @property
    def anchorageslip(self):
        return self._anchorageslip

    @anchorageslip.setter
    def anchorageslip(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._anchorageslip = ifcpositivelengthmeasure(value)
            else:
                self._anchorageslip = value
        else:
            self._anchorageslip = value

    @property
    def mincurvatureradius(self):
        return self._mincurvatureradius

    @mincurvatureradius.setter
    def mincurvatureradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._mincurvatureradius = ifcpositivelengthmeasure(value)
            else:
                self._mincurvatureradius = value
        else:
            self._mincurvatureradius = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifctendontypeenum.userdefined)) or (
                        (self.predefinedtype == ifctendontypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCTENDONTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifccooledbeam #
####################
class ifccooledbeam(ifcenergyconversiondevice):
    '''Entity ifccooledbeam definition.

	:param predefinedtype
	:type predefinedtype:ifccooledbeamtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccooledbeamtypeenum):
                self._predefinedtype = ifccooledbeamtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifccooledbeamtypeenum.userdefined)) or ((
                                                                                               self.predefinedtype == ifccooledbeamtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCOOLEDBEAMTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcindexedpolygonalface #
####################
class ifcindexedpolygonalface(ifctessellateditem):
    '''Entity ifcindexedpolygonalface definition.

	:param coordindex
	:type coordindex:LIST(3,None,'INTEGER', scope = schema_scope)

	:param tofaceset
	:type tofaceset:SET(1,None,'ifcpolygonalfaceset', scope = schema_scope)
	'''

    def __init__(self, coordindex, ):
        ifctessellateditem.__init__(self, )
        self._coordindex = coordindex

    @property
    def coordindex(self):
        return self._coordindex

    @coordindex.setter
    def coordindex(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(3, None, 'INTEGER', scope=schema_scope)):
            self._coordindex = LIST(value)
        else:
            self._coordindex = value

    @property
    def tofaceset(self):
        return self._tofaceset

    @tofaceset.setter
    def tofaceset(self, value):
        # INVERSE argument
        raise AssertionError('Argument tofaceset is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcmateriallayerset #
####################
class ifcmateriallayerset(ifcmaterialdefinition):
    '''Entity ifcmateriallayerset definition.

	:param materiallayers
	:type materiallayers:LIST(1,None,'ifcmateriallayer', scope = schema_scope)

	:param layersetname
	:type layersetname:ifclabel

	:param description
	:type description:ifctext

	:param totalthickness
	:type totalthickness:ifclengthmeasure
	'''

    def __init__(self, materiallayers, layersetname, description, ):
        ifcmaterialdefinition.__init__(self, )
        self._materiallayers = materiallayers
        self._layersetname = layersetname
        self._description = description

    @property
    def materiallayers(self):
        return self._materiallayers

    @materiallayers.setter
    def materiallayers(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcmateriallayer', scope=schema_scope)):
            self._materiallayers = LIST(value)
        else:
            self._materiallayers = value

    @property
    def layersetname(self):
        return self._layersetname

    @layersetname.setter
    def layersetname(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._layersetname = ifclabel(value)
            else:
                self._layersetname = value
        else:
            self._layersetname = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def totalthickness(self):
        attribute_eval = ifcmlstotalthickness(self)
        return attribute_eval

    @totalthickness.setter
    def totalthickness(self, value):
        # DERIVED argument
        raise AssertionError('Argument totalthickness is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcstructuralanalysismodel #
####################
class ifcstructuralanalysismodel(ifcsystem):
    '''Entity ifcstructuralanalysismodel definition.

	:param predefinedtype
	:type predefinedtype:ifcanalysismodeltypeenum

	:param orientationof2dplane
	:type orientationof2dplane:ifcaxis2placement3d

	:param loadedby
	:type loadedby:SET(1,None,'ifcstructuralloadgroup', scope = schema_scope)

	:param hasresults
	:type hasresults:SET(1,None,'ifcstructuralresultgroup', scope = schema_scope)

	:param sharedplacement
	:type sharedplacement:ifcobjectplacement
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, predefinedtype, orientationof2dplane, loadedby, hasresults, sharedplacement, ):
        ifcsystem.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                           inherited3__description, inherited4__objecttype, )
        self._predefinedtype = predefinedtype
        self._orientationof2dplane = orientationof2dplane
        self._loadedby = loadedby
        self._hasresults = hasresults
        self._sharedplacement = sharedplacement

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcanalysismodeltypeenum):
            self._predefinedtype = ifcanalysismodeltypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def orientationof2dplane(self):
        return self._orientationof2dplane

    @orientationof2dplane.setter
    def orientationof2dplane(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcaxis2placement3d):
                self._orientationof2dplane = ifcaxis2placement3d(value)
            else:
                self._orientationof2dplane = value
        else:
            self._orientationof2dplane = value

    @property
    def loadedby(self):
        return self._loadedby

    @loadedby.setter
    def loadedby(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'ifcstructuralloadgroup', scope=schema_scope)):
                self._loadedby = SET(value)
            else:
                self._loadedby = value
        else:
            self._loadedby = value

    @property
    def hasresults(self):
        return self._hasresults

    @hasresults.setter
    def hasresults(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'ifcstructuralresultgroup', scope=schema_scope)):
                self._hasresults = SET(value)
            else:
                self._hasresults = value
        else:
            self._hasresults = value

    @property
    def sharedplacement(self):
        return self._sharedplacement

    @sharedplacement.setter
    def sharedplacement(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcobjectplacement):
                self._sharedplacement = ifcobjectplacement(value)
            else:
                self._sharedplacement = value
        else:
            self._sharedplacement = value

    def hasobjecttype(self):
        eval_hasobjecttype_wr = ((self.predefinedtype != ifcanalysismodeltypeenum.userdefined) or EXISTS(
            self.self.ifcobject.self.objecttype))
        if not eval_hasobjecttype_wr:
            raise AssertionError('Rule hasobjecttype violated')
        else:
            return eval_hasobjecttype_wr


####################
# ENTITY ifctessellatedfaceset #
####################
class ifctessellatedfaceset(ifctessellateditem):
    '''Entity ifctessellatedfaceset definition.

	:param coordinates
	:type coordinates:ifccartesianpointlist3d

	:param dim
	:type dim:ifcdimensioncount

	:param hascolours
	:type hascolours:SET(0,1,'ifcindexedcolourmap', scope = schema_scope)

	:param hastextures
	:type hastextures:SET(0,None,'ifcindexedtexturemap', scope = schema_scope)
	'''

    def __init__(self, coordinates, ):
        ifctessellateditem.__init__(self, )
        self._coordinates = coordinates

    @property
    def coordinates(self):
        return self._coordinates

    @coordinates.setter
    def coordinates(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccartesianpointlist3d):
            self._coordinates = ifccartesianpointlist3d(value)
        else:
            self._coordinates = value

    @property
    def dim(self):
        attribute_eval = 3
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')

    @property
    def hascolours(self):
        return self._hascolours

    @hascolours.setter
    def hascolours(self, value):
        # INVERSE argument
        raise AssertionError('Argument hascolours is INVERSE. It is computed and can not be set to any value')

    @property
    def hastextures(self):
        return self._hastextures

    @hastextures.setter
    def hastextures(self, value):
        # INVERSE argument
        raise AssertionError('Argument hastextures is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifctriangulatedfaceset #
####################
class ifctriangulatedfaceset(ifctessellatedfaceset):
    '''Entity ifctriangulatedfaceset definition.

	:param normals
	:type normals:LIST(1,None,LIST(3,3,'REAL', scope = schema_scope))

	:param closed
	:type closed:ifcboolean

	:param coordindex
	:type coordindex:LIST(1,None,LIST(3,3,'INTEGER', scope = schema_scope))

	:param pnindex
	:type pnindex:LIST(1,None,'INTEGER', scope = schema_scope)

	:param numberoftriangles
	:type numberoftriangles:ifcinteger
	'''

    def __init__(self, inherited0__coordinates, normals, closed, coordindex, pnindex, ):
        ifctessellatedfaceset.__init__(self, inherited0__coordinates, )
        self._normals = normals
        self._closed = closed
        self._coordindex = coordindex
        self._pnindex = pnindex

    @property
    def normals(self):
        return self._normals

    @normals.setter
    def normals(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, LIST(3, 3, 'REAL', scope=schema_scope))):
                self._normals = LIST(value)
            else:
                self._normals = value
        else:
            self._normals = value

    @property
    def closed(self):
        return self._closed

    @closed.setter
    def closed(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._closed = ifcboolean(value)
            else:
                self._closed = value
        else:
            self._closed = value

    @property
    def coordindex(self):
        return self._coordindex

    @coordindex.setter
    def coordindex(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, LIST(3, 3, 'INTEGER', scope=schema_scope))):
            self._coordindex = LIST(value)
        else:
            self._coordindex = value

    @property
    def pnindex(self):
        return self._pnindex

    @pnindex.setter
    def pnindex(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'INTEGER', scope=schema_scope)):
                self._pnindex = LIST(value)
            else:
                self._pnindex = value
        else:
            self._pnindex = value

    @property
    def numberoftriangles(self):
        attribute_eval = SIZEOF(self.coordindex)
        return attribute_eval

    @numberoftriangles.setter
    def numberoftriangles(self, value):
        # DERIVED argument
        raise AssertionError('Argument numberoftriangles is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcflowfitting #
####################
class ifcflowfitting(ifcdistributionflowelement):
    '''Entity ifcflowfitting definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcdistributionflowelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation, inherited7__tag, )


####################
# ENTITY ifccablecarrierfitting #
####################
class ifccablecarrierfitting(ifcflowfitting):
    '''Entity ifccablecarrierfitting definition.

	:param predefinedtype
	:type predefinedtype:ifccablecarrierfittingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowfitting.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccablecarrierfittingtypeenum):
                self._predefinedtype = ifccablecarrierfittingtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifccablecarrierfittingtypeenum.userdefined)) or ((
                                                                                                        self.predefinedtype == ifccablecarrierfittingtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCCABLECARRIERFITTINGTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcconnectiongeometry #
####################
class ifcconnectiongeometry(BaseEntityClass):
    '''Entity ifcconnectiongeometry definition.
	'''
    # This class does not define any attribute.
    pass


####################
# ENTITY ifcconnectioncurvegeometry #
####################
class ifcconnectioncurvegeometry(ifcconnectiongeometry):
    '''Entity ifcconnectioncurvegeometry definition.

	:param curveonrelatingelement
	:type curveonrelatingelement:ifccurveoredgecurve

	:param curveonrelatedelement
	:type curveonrelatedelement:ifccurveoredgecurve
	'''

    def __init__(self, curveonrelatingelement, curveonrelatedelement, ):
        ifcconnectiongeometry.__init__(self, )
        self._curveonrelatingelement = curveonrelatingelement
        self._curveonrelatedelement = curveonrelatedelement

    @property
    def curveonrelatingelement(self):
        return self._curveonrelatingelement

    @curveonrelatingelement.setter
    def curveonrelatingelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurveoredgecurve):
            self._curveonrelatingelement = ifccurveoredgecurve(value)
        else:
            self._curveonrelatingelement = value

    @property
    def curveonrelatedelement(self):
        return self._curveonrelatedelement

    @curveonrelatedelement.setter
    def curveonrelatedelement(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccurveoredgecurve):
                self._curveonrelatedelement = ifccurveoredgecurve(value)
            else:
                self._curveonrelatedelement = value
        else:
            self._curveonrelatedelement = value


####################
# ENTITY ifcpropertysetdefinition #
####################
class ifcpropertysetdefinition(ifcpropertydefinition):
    '''Entity ifcpropertysetdefinition definition.

	:param definestype
	:type definestype:SET(0,None,'ifctypeobject', scope = schema_scope)

	:param isdefinedby
	:type isdefinedby:SET(0,None,'ifcreldefinesbytemplate', scope = schema_scope)

	:param definesoccurrence
	:type definesoccurrence:SET(0,None,'ifcreldefinesbyproperties', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description, ):
        ifcpropertydefinition.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, )

    @property
    def definestype(self):
        return self._definestype

    @definestype.setter
    def definestype(self, value):
        # INVERSE argument
        raise AssertionError('Argument definestype is INVERSE. It is computed and can not be set to any value')

    @property
    def isdefinedby(self):
        return self._isdefinedby

    @isdefinedby.setter
    def isdefinedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument isdefinedby is INVERSE. It is computed and can not be set to any value')

    @property
    def definesoccurrence(self):
        return self._definesoccurrence

    @definesoccurrence.setter
    def definesoccurrence(self, value):
        # INVERSE argument
        raise AssertionError('Argument definesoccurrence is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcpredefinedpropertyset #
####################
class ifcpredefinedpropertyset(ifcpropertysetdefinition):
    '''Entity ifcpredefinedpropertyset definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description, ):
        ifcpropertysetdefinition.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, )


####################
# ENTITY ifcdoorpanelproperties #
####################
class ifcdoorpanelproperties(ifcpredefinedpropertyset):
    '''Entity ifcdoorpanelproperties definition.

	:param paneldepth
	:type paneldepth:ifcpositivelengthmeasure

	:param paneloperation
	:type paneloperation:ifcdoorpaneloperationenum

	:param panelwidth
	:type panelwidth:ifcnormalisedratiomeasure

	:param panelposition
	:type panelposition:ifcdoorpanelpositionenum

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 paneldepth, paneloperation, panelwidth, panelposition, shapeaspectstyle, ):
        ifcpredefinedpropertyset.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, )
        self._paneldepth = paneldepth
        self._paneloperation = paneloperation
        self._panelwidth = panelwidth
        self._panelposition = panelposition
        self._shapeaspectstyle = shapeaspectstyle

    @property
    def paneldepth(self):
        return self._paneldepth

    @paneldepth.setter
    def paneldepth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._paneldepth = ifcpositivelengthmeasure(value)
            else:
                self._paneldepth = value
        else:
            self._paneldepth = value

    @property
    def paneloperation(self):
        return self._paneloperation

    @paneloperation.setter
    def paneloperation(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdoorpaneloperationenum):
            self._paneloperation = ifcdoorpaneloperationenum(value)
        else:
            self._paneloperation = value

    @property
    def panelwidth(self):
        return self._panelwidth

    @panelwidth.setter
    def panelwidth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnormalisedratiomeasure):
                self._panelwidth = ifcnormalisedratiomeasure(value)
            else:
                self._panelwidth = value
        else:
            self._panelwidth = value

    @property
    def panelposition(self):
        return self._panelposition

    @panelposition.setter
    def panelposition(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdoorpanelpositionenum):
            self._panelposition = ifcdoorpanelpositionenum(value)
        else:
            self._panelposition = value

    @property
    def shapeaspectstyle(self):
        return self._shapeaspectstyle

    @shapeaspectstyle.setter
    def shapeaspectstyle(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcshapeaspect):
                self._shapeaspectstyle = ifcshapeaspect(value)
            else:
                self._shapeaspectstyle = value
        else:
            self._shapeaspectstyle = value

    def applicabletotype(self):
        eval_applicabletotype_wr = (EXISTS(self.self.ifcpropertysetdefinition.self.definestype[1]) and (
                    ('IFC4X2.IFCDOORTYPE' == TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1])) or (
                        'IFC4X2.IFCDOORSTYLE' == TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1]))))
        if not eval_applicabletotype_wr:
            raise AssertionError('Rule applicabletotype violated')
        else:
            return eval_applicabletotype_wr


####################
# ENTITY ifchumidifier #
####################
class ifchumidifier(ifcenergyconversiondevice):
    '''Entity ifchumidifier definition.

	:param predefinedtype
	:type predefinedtype:ifchumidifiertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifchumidifiertypeenum):
                self._predefinedtype = ifchumidifiertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifchumidifiertypeenum.userdefined)) or ((
                                                                                               self.predefinedtype == ifchumidifiertypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCHUMIDIFIERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcmaterial #
####################
class ifcmaterial(ifcmaterialdefinition):
    '''Entity ifcmaterial definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param category
	:type category:ifclabel

	:param hasrepresentation
	:type hasrepresentation:SET(0,1,'ifcmaterialdefinitionrepresentation', scope = schema_scope)

	:param isrelatedwith
	:type isrelatedwith:SET(0,None,'ifcmaterialrelationship', scope = schema_scope)

	:param relatesto
	:type relatesto:SET(0,1,'ifcmaterialrelationship', scope = schema_scope)
	'''

    def __init__(self, name, description, category, ):
        ifcmaterialdefinition.__init__(self, )
        self._name = name
        self._description = description
        self._category = category

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def category(self):
        return self._category

    @category.setter
    def category(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._category = ifclabel(value)
            else:
                self._category = value
        else:
            self._category = value

    @property
    def hasrepresentation(self):
        return self._hasrepresentation

    @hasrepresentation.setter
    def hasrepresentation(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasrepresentation is INVERSE. It is computed and can not be set to any value')

    @property
    def isrelatedwith(self):
        return self._isrelatedwith

    @isrelatedwith.setter
    def isrelatedwith(self, value):
        # INVERSE argument
        raise AssertionError('Argument isrelatedwith is INVERSE. It is computed and can not be set to any value')

    @property
    def relatesto(self):
        return self._relatesto

    @relatesto.setter
    def relatesto(self, value):
        # INVERSE argument
        raise AssertionError('Argument relatesto is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcbeam #
####################
class ifcbeam(ifcbuildingelement):
    '''Entity ifcbeam definition.

	:param predefinedtype
	:type predefinedtype:ifcbeamtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcbeamtypeenum):
                self._predefinedtype = ifcbeamtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcbeamtypeenum.userdefined)) or (
                        (self.predefinedtype == ifcbeamtypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCBEAMTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcbeamstandardcase #
####################
class ifcbeamstandardcase(ifcbeam):
    '''Entity ifcbeamstandardcase definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__predefinedtype, ):
        ifcbeam.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                         inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                         inherited6__representation, inherited7__tag, inherited8__predefinedtype, )

    def hasmaterialprofilesetusage(self):
        eval_hasmaterialprofilesetusage_wr = (SIZEOF(None) == 1)
        if not eval_hasmaterialprofilesetusage_wr:
            raise AssertionError('Rule hasmaterialprofilesetusage violated')
        else:
            return eval_hasmaterialprofilesetusage_wr


####################
# ENTITY ifccablecarriersegment #
####################
class ifccablecarriersegment(ifcflowsegment):
    '''Entity ifccablecarriersegment definition.

	:param predefinedtype
	:type predefinedtype:ifccablecarriersegmenttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowsegment.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccablecarriersegmenttypeenum):
                self._predefinedtype = ifccablecarriersegmenttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifccablecarriersegmenttypeenum.userdefined)) or ((
                                                                                                        self.predefinedtype == ifccablecarriersegmenttypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCCABLECARRIERSEGMENTTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcoffsetcurvebydistances #
####################
class ifcoffsetcurvebydistances(ifcoffsetcurve):
    '''Entity ifcoffsetcurvebydistances definition.

	:param offsetvalues
	:type offsetvalues:LIST(1,None,'ifcdistanceexpression', scope = schema_scope)

	:param tag
	:type tag:ifclabel
	'''

    def __init__(self, inherited0__basiscurve, offsetvalues, tag, ):
        ifcoffsetcurve.__init__(self, inherited0__basiscurve, )
        self._offsetvalues = offsetvalues
        self._tag = tag

    @property
    def offsetvalues(self):
        return self._offsetvalues

    @offsetvalues.setter
    def offsetvalues(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcdistanceexpression', scope=schema_scope)):
            self._offsetvalues = LIST(value)
        else:
            self._offsetvalues = value

    @property
    def tag(self):
        return self._tag

    @tag.setter
    def tag(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._tag = ifclabel(value)
            else:
                self._tag = value
        else:
            self._tag = value


####################
# ENTITY ifcplacement #
####################
class ifcplacement(ifcgeometricrepresentationitem):
    '''Entity ifcplacement definition.

	:param location
	:type location:ifccartesianpoint

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, location, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._location = location

    @property
    def location(self):
        return self._location

    @location.setter
    def location(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccartesianpoint):
            self._location = ifccartesianpoint(value)
        else:
            self._location = value

    @property
    def dim(self):
        attribute_eval = self.location.self.dim
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcaxis1placement #
####################
class ifcaxis1placement(ifcplacement):
    '''Entity ifcaxis1placement definition.

	:param axis
	:type axis:ifcdirection

	:param z
	:type z:ifcdirection
	'''

    def __init__(self, inherited0__location, axis, ):
        ifcplacement.__init__(self, inherited0__location, )
        self._axis = axis

    @property
    def axis(self):
        return self._axis

    @axis.setter
    def axis(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdirection):
                self._axis = ifcdirection(value)
            else:
                self._axis = value
        else:
            self._axis = value

    @property
    def z(self):
        attribute_eval = NVL(ifcnormalise(self.axis),
                             (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection([0, 0, 1]))
        return attribute_eval

    @z.setter
    def z(self, value):
        # DERIVED argument
        raise AssertionError('Argument z is DERIVED. It is computed and can not be set to any value')

    def axisis3d(self):
        eval_axisis3d_wr = ((not EXISTS(self.axis)) or (self.axis.self.dim == 3))
        if not eval_axisis3d_wr:
            raise AssertionError('Rule axisis3d violated')
        else:
            return eval_axisis3d_wr

    def locationis3d(self):
        eval_locationis3d_wr = (self.self.ifcplacement.self.location.self.dim == 3)
        if not eval_locationis3d_wr:
            raise AssertionError('Rule locationis3d violated')
        else:
            return eval_locationis3d_wr


####################
# ENTITY ifcfillareastylehatching #
####################
class ifcfillareastylehatching(ifcgeometricrepresentationitem):
    '''Entity ifcfillareastylehatching definition.

	:param hatchlineappearance
	:type hatchlineappearance:ifccurvestyle

	:param startofnexthatchline
	:type startofnexthatchline:ifchatchlinedistanceselect

	:param pointofreferencehatchline
	:type pointofreferencehatchline:ifccartesianpoint

	:param patternstart
	:type patternstart:ifccartesianpoint

	:param hatchlineangle
	:type hatchlineangle:ifcplaneanglemeasure
	'''

    def __init__(self, hatchlineappearance, startofnexthatchline, pointofreferencehatchline, patternstart,
                 hatchlineangle, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._hatchlineappearance = hatchlineappearance
        self._startofnexthatchline = startofnexthatchline
        self._pointofreferencehatchline = pointofreferencehatchline
        self._patternstart = patternstart
        self._hatchlineangle = hatchlineangle

    @property
    def hatchlineappearance(self):
        return self._hatchlineappearance

    @hatchlineappearance.setter
    def hatchlineappearance(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurvestyle):
            self._hatchlineappearance = ifccurvestyle(value)
        else:
            self._hatchlineappearance = value

    @property
    def startofnexthatchline(self):
        return self._startofnexthatchline

    @startofnexthatchline.setter
    def startofnexthatchline(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifchatchlinedistanceselect):
            self._startofnexthatchline = ifchatchlinedistanceselect(value)
        else:
            self._startofnexthatchline = value

    @property
    def pointofreferencehatchline(self):
        return self._pointofreferencehatchline

    @pointofreferencehatchline.setter
    def pointofreferencehatchline(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccartesianpoint):
                self._pointofreferencehatchline = ifccartesianpoint(value)
            else:
                self._pointofreferencehatchline = value
        else:
            self._pointofreferencehatchline = value

    @property
    def patternstart(self):
        return self._patternstart

    @patternstart.setter
    def patternstart(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccartesianpoint):
                self._patternstart = ifccartesianpoint(value)
            else:
                self._patternstart = value
        else:
            self._patternstart = value

    @property
    def hatchlineangle(self):
        return self._hatchlineangle

    @hatchlineangle.setter
    def hatchlineangle(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcplaneanglemeasure):
            self._hatchlineangle = ifcplaneanglemeasure(value)
        else:
            self._hatchlineangle = value

    def patternstart2d(self):
        eval_patternstart2d_wr = ((not EXISTS(self.patternstart)) or (self.patternstart.self.dim == 2))
        if not eval_patternstart2d_wr:
            raise AssertionError('Rule patternstart2d violated')
        else:
            return eval_patternstart2d_wr

    def refhatchline2d(self):
        eval_refhatchline2d_wr = (
                    (not EXISTS(self.pointofreferencehatchline)) or (self.pointofreferencehatchline.self.dim == 2))
        if not eval_refhatchline2d_wr:
            raise AssertionError('Rule refhatchline2d violated')
        else:
            return eval_refhatchline2d_wr


####################
# ENTITY ifccostitem #
####################
class ifccostitem(ifccontrol):
    '''Entity ifccostitem definition.

	:param predefinedtype
	:type predefinedtype:ifccostitemtypeenum

	:param costvalues
	:type costvalues:LIST(1,None,'ifccostvalue', scope = schema_scope)

	:param costquantities
	:type costquantities:LIST(1,None,'ifcphysicalquantity', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, predefinedtype, costvalues, costquantities, ):
        ifccontrol.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__identification, )
        self._predefinedtype = predefinedtype
        self._costvalues = costvalues
        self._costquantities = costquantities

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccostitemtypeenum):
                self._predefinedtype = ifccostitemtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def costvalues(self):
        return self._costvalues

    @costvalues.setter
    def costvalues(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifccostvalue', scope=schema_scope)):
                self._costvalues = LIST(value)
            else:
                self._costvalues = value
        else:
            self._costvalues = value

    @property
    def costquantities(self):
        return self._costquantities

    @costquantities.setter
    def costquantities(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcphysicalquantity', scope=schema_scope)):
                self._costquantities = LIST(value)
            else:
                self._costquantities = value
        else:
            self._costquantities = value


####################
# ENTITY ifcdeepfoundation #
####################
class ifcdeepfoundation(ifcbuildingelement):
    '''Entity ifcdeepfoundation definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCDEEPFOUNDATIONTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcdoortype #
####################
class ifcdoortype(ifcbuildingelementtype):
    '''Entity ifcdoortype definition.

	:param predefinedtype
	:type predefinedtype:ifcdoortypeenum

	:param operationtype
	:type operationtype:ifcdoortypeoperationenum

	:param parametertakesprecedence
	:type parametertakesprecedence:ifcboolean

	:param userdefinedoperationtype
	:type userdefinedoperationtype:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, operationtype, parametertakesprecedence,
                 userdefinedoperationtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype
        self._operationtype = operationtype
        self._parametertakesprecedence = parametertakesprecedence
        self._userdefinedoperationtype = userdefinedoperationtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdoortypeenum):
            self._predefinedtype = ifcdoortypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def operationtype(self):
        return self._operationtype

    @operationtype.setter
    def operationtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdoortypeoperationenum):
            self._operationtype = ifcdoortypeoperationenum(value)
        else:
            self._operationtype = value

    @property
    def parametertakesprecedence(self):
        return self._parametertakesprecedence

    @parametertakesprecedence.setter
    def parametertakesprecedence(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._parametertakesprecedence = ifcboolean(value)
            else:
                self._parametertakesprecedence = value
        else:
            self._parametertakesprecedence = value

    @property
    def userdefinedoperationtype(self):
        return self._userdefinedoperationtype

    @userdefinedoperationtype.setter
    def userdefinedoperationtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefinedoperationtype = ifclabel(value)
            else:
                self._userdefinedoperationtype = value
        else:
            self._userdefinedoperationtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcdoortypeenum.userdefined) or (
                    (self.predefinedtype == ifcdoortypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcfacebasedsurfacemodel #
####################
class ifcfacebasedsurfacemodel(ifcgeometricrepresentationitem):
    '''Entity ifcfacebasedsurfacemodel definition.

	:param fbsmfaces
	:type fbsmfaces:SET(1,None,'ifcconnectedfaceset', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, fbsmfaces, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._fbsmfaces = fbsmfaces

    @property
    def fbsmfaces(self):
        return self._fbsmfaces

    @fbsmfaces.setter
    def fbsmfaces(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcconnectedfaceset', scope=schema_scope)):
            self._fbsmfaces = SET(value)
        else:
            self._fbsmfaces = value

    @property
    def dim(self):
        attribute_eval = 3
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcsurfacetexture #
####################
class ifcsurfacetexture(ifcpresentationitem):
    '''Entity ifcsurfacetexture definition.

	:param repeats
	:type repeats:ifcboolean

	:param repeatt
	:type repeatt:ifcboolean

	:param mode
	:type mode:ifcidentifier

	:param texturetransform
	:type texturetransform:ifccartesiantransformationoperator2d

	:param parameter
	:type parameter:LIST(1,None,'STRING', scope = schema_scope)

	:param ismappedby
	:type ismappedby:SET(0,None,'ifctexturecoordinate', scope = schema_scope)

	:param usedinstyles
	:type usedinstyles:SET(0,None,'ifcsurfacestylewithtextures', scope = schema_scope)
	'''

    def __init__(self, repeats, repeatt, mode, texturetransform, parameter, ):
        ifcpresentationitem.__init__(self, )
        self._repeats = repeats
        self._repeatt = repeatt
        self._mode = mode
        self._texturetransform = texturetransform
        self._parameter = parameter

    @property
    def repeats(self):
        return self._repeats

    @repeats.setter
    def repeats(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._repeats = ifcboolean(value)
        else:
            self._repeats = value

    @property
    def repeatt(self):
        return self._repeatt

    @repeatt.setter
    def repeatt(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._repeatt = ifcboolean(value)
        else:
            self._repeatt = value

    @property
    def mode(self):
        return self._mode

    @mode.setter
    def mode(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._mode = ifcidentifier(value)
            else:
                self._mode = value
        else:
            self._mode = value

    @property
    def texturetransform(self):
        return self._texturetransform

    @texturetransform.setter
    def texturetransform(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccartesiantransformationoperator2d):
                self._texturetransform = ifccartesiantransformationoperator2d(value)
            else:
                self._texturetransform = value
        else:
            self._texturetransform = value

    @property
    def parameter(self):
        return self._parameter

    @parameter.setter
    def parameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'STRING', scope=schema_scope)):
                self._parameter = LIST(value)
            else:
                self._parameter = value
        else:
            self._parameter = value

    @property
    def ismappedby(self):
        return self._ismappedby

    @ismappedby.setter
    def ismappedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument ismappedby is INVERSE. It is computed and can not be set to any value')

    @property
    def usedinstyles(self):
        return self._usedinstyles

    @usedinstyles.setter
    def usedinstyles(self, value):
        # INVERSE argument
        raise AssertionError('Argument usedinstyles is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcpixeltexture #
####################
class ifcpixeltexture(ifcsurfacetexture):
    '''Entity ifcpixeltexture definition.

	:param width
	:type width:ifcinteger

	:param height
	:type height:ifcinteger

	:param colourcomponents
	:type colourcomponents:ifcinteger

	:param pixel
	:type pixel:LIST(1,None,'ifcbinary', scope = schema_scope)
	'''

    def __init__(self, inherited0__repeats, inherited1__repeatt, inherited2__mode, inherited3__texturetransform,
                 inherited4__parameter, width, height, colourcomponents, pixel, ):
        ifcsurfacetexture.__init__(self, inherited0__repeats, inherited1__repeatt, inherited2__mode,
                                   inherited3__texturetransform, inherited4__parameter, )
        self._width = width
        self._height = height
        self._colourcomponents = colourcomponents
        self._pixel = pixel

    @property
    def width(self):
        return self._width

    @width.setter
    def width(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcinteger):
            self._width = ifcinteger(value)
        else:
            self._width = value

    @property
    def height(self):
        return self._height

    @height.setter
    def height(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcinteger):
            self._height = ifcinteger(value)
        else:
            self._height = value

    @property
    def colourcomponents(self):
        return self._colourcomponents

    @colourcomponents.setter
    def colourcomponents(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcinteger):
            self._colourcomponents = ifcinteger(value)
        else:
            self._colourcomponents = value

    @property
    def pixel(self):
        return self._pixel

    @pixel.setter
    def pixel(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcbinary', scope=schema_scope)):
            self._pixel = LIST(value)
        else:
            self._pixel = value

    def minpixelins(self):
        eval_minpixelins_wr = (self.width >= 1)
        if not eval_minpixelins_wr:
            raise AssertionError('Rule minpixelins violated')
        else:
            return eval_minpixelins_wr

    def minpixelint(self):
        eval_minpixelint_wr = (self.height >= 1)
        if not eval_minpixelint_wr:
            raise AssertionError('Rule minpixelint violated')
        else:
            return eval_minpixelint_wr

    def numberofcolours(self):
        eval_numberofcolours_wr = ((1 <= self.colourcomponents) and (self.colourcomponents <= 4))
        if not eval_numberofcolours_wr:
            raise AssertionError('Rule numberofcolours violated')
        else:
            return eval_numberofcolours_wr

    def sizeofpixellist(self):
        eval_sizeofpixellist_wr = (SIZEOF(self.pixel) == (self.width * self.height))
        if not eval_sizeofpixellist_wr:
            raise AssertionError('Rule sizeofpixellist violated')
        else:
            return eval_sizeofpixellist_wr

    def pixelasbyteandsamelength(self):
        eval_pixelasbyteandsamelength_wr = (SIZEOF(None) == SIZEOF(self.pixel))
        if not eval_pixelasbyteandsamelength_wr:
            raise AssertionError('Rule pixelasbyteandsamelength violated')
        else:
            return eval_pixelasbyteandsamelength_wr


####################
# ENTITY ifctextliteral #
####################
class ifctextliteral(ifcgeometricrepresentationitem):
    '''Entity ifctextliteral definition.

	:param literal
	:type literal:ifcpresentabletext

	:param placement
	:type placement:ifcaxis2placement

	:param path
	:type path:ifctextpath
	'''

    def __init__(self, literal, placement, path, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._literal = literal
        self._placement = placement
        self._path = path

    @property
    def literal(self):
        return self._literal

    @literal.setter
    def literal(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpresentabletext):
            self._literal = ifcpresentabletext(value)
        else:
            self._literal = value

    @property
    def placement(self):
        return self._placement

    @placement.setter
    def placement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcaxis2placement):
            self._placement = ifcaxis2placement(value)
        else:
            self._placement = value

    @property
    def path(self):
        return self._path

    @path.setter
    def path(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctextpath):
            self._path = ifctextpath(value)
        else:
            self._path = value


####################
# ENTITY ifcunitaryequipmenttype #
####################
class ifcunitaryequipmenttype(ifcenergyconversiondevicetype):
    '''Entity ifcunitaryequipmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifcunitaryequipmenttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcunitaryequipmenttypeenum):
            self._predefinedtype = ifcunitaryequipmenttypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcunitaryequipmenttypeenum.userdefined) or (
                    (self.predefinedtype == ifcunitaryequipmenttypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcresource #
####################
class ifcresource(ifcobject):
    '''Entity ifcresource definition.

	:param identification
	:type identification:ifcidentifier

	:param longdescription
	:type longdescription:ifctext

	:param resourceof
	:type resourceof:SET(0,None,'ifcrelassignstoresource', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, identification, longdescription, ):
        ifcobject.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                           inherited3__description, inherited4__objecttype, )
        self._identification = identification
        self._longdescription = longdescription

    @property
    def identification(self):
        return self._identification

    @identification.setter
    def identification(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._identification = ifcidentifier(value)
            else:
                self._identification = value
        else:
            self._identification = value

    @property
    def longdescription(self):
        return self._longdescription

    @longdescription.setter
    def longdescription(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._longdescription = ifctext(value)
            else:
                self._longdescription = value
        else:
            self._longdescription = value

    @property
    def resourceof(self):
        return self._resourceof

    @resourceof.setter
    def resourceof(self, value):
        # INVERSE argument
        raise AssertionError('Argument resourceof is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcconstructionresource #
####################
class ifcconstructionresource(ifcresource):
    '''Entity ifcconstructionresource definition.

	:param usage
	:type usage:ifcresourcetime

	:param basecosts
	:type basecosts:LIST(1,None,'ifcappliedvalue', scope = schema_scope)

	:param basequantity
	:type basequantity:ifcphysicalquantity
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, inherited6__longdescription, usage, basecosts,
                 basequantity, ):
        ifcresource.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                             inherited3__description, inherited4__objecttype, inherited5__identification,
                             inherited6__longdescription, )
        self._usage = usage
        self._basecosts = basecosts
        self._basequantity = basequantity

    @property
    def usage(self):
        return self._usage

    @usage.setter
    def usage(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcresourcetime):
                self._usage = ifcresourcetime(value)
            else:
                self._usage = value
        else:
            self._usage = value

    @property
    def basecosts(self):
        return self._basecosts

    @basecosts.setter
    def basecosts(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcappliedvalue', scope=schema_scope)):
                self._basecosts = LIST(value)
            else:
                self._basecosts = value
        else:
            self._basecosts = value

    @property
    def basequantity(self):
        return self._basequantity

    @basequantity.setter
    def basequantity(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcphysicalquantity):
                self._basequantity = ifcphysicalquantity(value)
            else:
                self._basequantity = value
        else:
            self._basequantity = value


####################
# ENTITY ifcrepresentationcontext #
####################
class ifcrepresentationcontext(BaseEntityClass):
    '''Entity ifcrepresentationcontext definition.

	:param contextidentifier
	:type contextidentifier:ifclabel

	:param contexttype
	:type contexttype:ifclabel

	:param representationsincontext
	:type representationsincontext:SET(0,None,'ifcrepresentation', scope = schema_scope)
	'''

    def __init__(self, contextidentifier, contexttype, ):
        self._contextidentifier = contextidentifier
        self._contexttype = contexttype

    @property
    def contextidentifier(self):
        return self._contextidentifier

    @contextidentifier.setter
    def contextidentifier(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._contextidentifier = ifclabel(value)
            else:
                self._contextidentifier = value
        else:
            self._contextidentifier = value

    @property
    def contexttype(self):
        return self._contexttype

    @contexttype.setter
    def contexttype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._contexttype = ifclabel(value)
            else:
                self._contexttype = value
        else:
            self._contexttype = value

    @property
    def representationsincontext(self):
        return self._representationsincontext

    @representationsincontext.setter
    def representationsincontext(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument representationsincontext is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcgeometricrepresentationcontext #
####################
class ifcgeometricrepresentationcontext(ifcrepresentationcontext):
    '''Entity ifcgeometricrepresentationcontext definition.

	:param coordinatespacedimension
	:type coordinatespacedimension:ifcdimensioncount

	:param precision
	:type precision:ifcreal

	:param worldcoordinatesystem
	:type worldcoordinatesystem:ifcaxis2placement

	:param truenorth
	:type truenorth:ifcdirection

	:param hassubcontexts
	:type hassubcontexts:SET(0,None,'ifcgeometricrepresentationsubcontext', scope = schema_scope)

	:param hascoordinateoperation
	:type hascoordinateoperation:SET(0,1,'ifccoordinateoperation', scope = schema_scope)
	'''

    def __init__(self, inherited0__contextidentifier, inherited1__contexttype, coordinatespacedimension, precision,
                 worldcoordinatesystem, truenorth, ):
        ifcrepresentationcontext.__init__(self, inherited0__contextidentifier, inherited1__contexttype, )
        self._coordinatespacedimension = coordinatespacedimension
        self._precision = precision
        self._worldcoordinatesystem = worldcoordinatesystem
        self._truenorth = truenorth

    @property
    def coordinatespacedimension(self):
        return self._coordinatespacedimension

    @coordinatespacedimension.setter
    def coordinatespacedimension(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdimensioncount):
            self._coordinatespacedimension = ifcdimensioncount(value)
        else:
            self._coordinatespacedimension = value

    @property
    def precision(self):
        return self._precision

    @precision.setter
    def precision(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreal):
                self._precision = ifcreal(value)
            else:
                self._precision = value
        else:
            self._precision = value

    @property
    def worldcoordinatesystem(self):
        return self._worldcoordinatesystem

    @worldcoordinatesystem.setter
    def worldcoordinatesystem(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcaxis2placement):
            self._worldcoordinatesystem = ifcaxis2placement(value)
        else:
            self._worldcoordinatesystem = value

    @property
    def truenorth(self):
        return self._truenorth

    @truenorth.setter
    def truenorth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdirection):
                self._truenorth = ifcdirection(value)
            else:
                self._truenorth = value
        else:
            self._truenorth = value

    @property
    def hassubcontexts(self):
        return self._hassubcontexts

    @hassubcontexts.setter
    def hassubcontexts(self, value):
        # INVERSE argument
        raise AssertionError('Argument hassubcontexts is INVERSE. It is computed and can not be set to any value')

    @property
    def hascoordinateoperation(self):
        return self._hascoordinateoperation

    @hascoordinateoperation.setter
    def hascoordinateoperation(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument hascoordinateoperation is INVERSE. It is computed and can not be set to any value')

    def north2d(self):
        eval_north2d_wr = ((not EXISTS(self.truenorth)) or (HIINDEX(self.truenorth.self.directionratios) == 2))
        if not eval_north2d_wr:
            raise AssertionError('Rule north2d violated')
        else:
            return eval_north2d_wr


####################
# ENTITY ifcpermit #
####################
class ifcpermit(ifccontrol):
    '''Entity ifcpermit definition.

	:param predefinedtype
	:type predefinedtype:ifcpermittypeenum

	:param status
	:type status:ifclabel

	:param longdescription
	:type longdescription:ifctext
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, predefinedtype, status, longdescription, ):
        ifccontrol.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__identification, )
        self._predefinedtype = predefinedtype
        self._status = status
        self._longdescription = longdescription

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpermittypeenum):
                self._predefinedtype = ifcpermittypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def status(self):
        return self._status

    @status.setter
    def status(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._status = ifclabel(value)
            else:
                self._status = value
        else:
            self._status = value

    @property
    def longdescription(self):
        return self._longdescription

    @longdescription.setter
    def longdescription(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._longdescription = ifctext(value)
            else:
                self._longdescription = value
        else:
            self._longdescription = value


####################
# ENTITY ifcrectangleprofiledef #
####################
class ifcrectangleprofiledef(ifcparameterizedprofiledef):
    '''Entity ifcrectangleprofiledef definition.

	:param xdim
	:type xdim:ifcpositivelengthmeasure

	:param ydim
	:type ydim:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, xdim, ydim, ):
        ifcparameterizedprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename,
                                            inherited2__position, )
        self._xdim = xdim
        self._ydim = ydim

    @property
    def xdim(self):
        return self._xdim

    @xdim.setter
    def xdim(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._xdim = ifcpositivelengthmeasure(value)
        else:
            self._xdim = value

    @property
    def ydim(self):
        return self._ydim

    @ydim.setter
    def ydim(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._ydim = ifcpositivelengthmeasure(value)
        else:
            self._ydim = value


####################
# ENTITY ifcroundedrectangleprofiledef #
####################
class ifcroundedrectangleprofiledef(ifcrectangleprofiledef):
    '''Entity ifcroundedrectangleprofiledef definition.

	:param roundingradius
	:type roundingradius:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, inherited3__xdim,
                 inherited4__ydim, roundingradius, ):
        ifcrectangleprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position,
                                        inherited3__xdim, inherited4__ydim, )
        self._roundingradius = roundingradius

    @property
    def roundingradius(self):
        return self._roundingradius

    @roundingradius.setter
    def roundingradius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._roundingradius = ifcpositivelengthmeasure(value)
        else:
            self._roundingradius = value

    def validradius(self):
        eval_validradius_wr = ((self.roundingradius <= (self.self.ifcrectangleprofiledef.self.xdim / 2)) and (
                    self.roundingradius <= (self.self.ifcrectangleprofiledef.self.ydim / 2)))
        if not eval_validradius_wr:
            raise AssertionError('Rule validradius violated')
        else:
            return eval_validradius_wr


####################
# ENTITY ifcstructuralload #
####################
class ifcstructuralload(BaseEntityClass):
    '''Entity ifcstructuralload definition.

	:param name
	:type name:ifclabel
	'''

    def __init__(self, name, ):
        self._name = name

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value


####################
# ENTITY ifcstructuralloadorresult #
####################
class ifcstructuralloadorresult(ifcstructuralload):
    '''Entity ifcstructuralloadorresult definition.
	'''

    def __init__(self, inherited0__name, ):
        ifcstructuralload.__init__(self, inherited0__name, )


####################
# ENTITY ifcstructuralloadstatic #
####################
class ifcstructuralloadstatic(ifcstructuralloadorresult):
    '''Entity ifcstructuralloadstatic definition.
	'''

    def __init__(self, inherited0__name, ):
        ifcstructuralloadorresult.__init__(self, inherited0__name, )


####################
# ENTITY ifcstructuralloadplanarforce #
####################
class ifcstructuralloadplanarforce(ifcstructuralloadstatic):
    '''Entity ifcstructuralloadplanarforce definition.

	:param planarforcex
	:type planarforcex:ifcplanarforcemeasure

	:param planarforcey
	:type planarforcey:ifcplanarforcemeasure

	:param planarforcez
	:type planarforcez:ifcplanarforcemeasure
	'''

    def __init__(self, inherited0__name, planarforcex, planarforcey, planarforcez, ):
        ifcstructuralloadstatic.__init__(self, inherited0__name, )
        self._planarforcex = planarforcex
        self._planarforcey = planarforcey
        self._planarforcez = planarforcez

    @property
    def planarforcex(self):
        return self._planarforcex

    @planarforcex.setter
    def planarforcex(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplanarforcemeasure):
                self._planarforcex = ifcplanarforcemeasure(value)
            else:
                self._planarforcex = value
        else:
            self._planarforcex = value

    @property
    def planarforcey(self):
        return self._planarforcey

    @planarforcey.setter
    def planarforcey(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplanarforcemeasure):
                self._planarforcey = ifcplanarforcemeasure(value)
            else:
                self._planarforcey = value
        else:
            self._planarforcey = value

    @property
    def planarforcez(self):
        return self._planarforcez

    @planarforcez.setter
    def planarforcez(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplanarforcemeasure):
                self._planarforcez = ifcplanarforcemeasure(value)
            else:
                self._planarforcez = value
        else:
            self._planarforcez = value


####################
# ENTITY ifcflowstoragedevicetype #
####################
class ifcflowstoragedevicetype(ifcdistributionflowelementtype):
    '''Entity ifcflowstoragedevicetype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcdistributionflowelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                                inherited3__description, inherited4__applicableoccurrence,
                                                inherited5__haspropertysets, inherited6__representationmaps,
                                                inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifctanktype #
####################
class ifctanktype(ifcflowstoragedevicetype):
    '''Entity ifctanktype definition.

	:param predefinedtype
	:type predefinedtype:ifctanktypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowstoragedevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, inherited4__applicableoccurrence,
                                          inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                          inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctanktypeenum):
            self._predefinedtype = ifctanktypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifctanktypeenum.userdefined) or (
                    (self.predefinedtype == ifctanktypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcpresentationstyle #
####################
class ifcpresentationstyle(BaseEntityClass):
    '''Entity ifcpresentationstyle definition.

	:param name
	:type name:ifclabel
	'''

    def __init__(self, name, ):
        self._name = name

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value


####################
# ENTITY ifctextstyle #
####################
class ifctextstyle(ifcpresentationstyle):
    '''Entity ifctextstyle definition.

	:param textcharacterappearance
	:type textcharacterappearance:ifctextstylefordefinedfont

	:param textstyle
	:type textstyle:ifctextstyletextmodel

	:param textfontstyle
	:type textfontstyle:ifctextfontselect

	:param modelordraughting
	:type modelordraughting:ifcboolean
	'''

    def __init__(self, inherited0__name, textcharacterappearance, textstyle, textfontstyle, modelordraughting, ):
        ifcpresentationstyle.__init__(self, inherited0__name, )
        self._textcharacterappearance = textcharacterappearance
        self._textstyle = textstyle
        self._textfontstyle = textfontstyle
        self._modelordraughting = modelordraughting

    @property
    def textcharacterappearance(self):
        return self._textcharacterappearance

    @textcharacterappearance.setter
    def textcharacterappearance(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctextstylefordefinedfont):
                self._textcharacterappearance = ifctextstylefordefinedfont(value)
            else:
                self._textcharacterappearance = value
        else:
            self._textcharacterappearance = value

    @property
    def textstyle(self):
        return self._textstyle

    @textstyle.setter
    def textstyle(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctextstyletextmodel):
                self._textstyle = ifctextstyletextmodel(value)
            else:
                self._textstyle = value
        else:
            self._textstyle = value

    @property
    def textfontstyle(self):
        return self._textfontstyle

    @textfontstyle.setter
    def textfontstyle(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctextfontselect):
            self._textfontstyle = ifctextfontselect(value)
        else:
            self._textfontstyle = value

    @property
    def modelordraughting(self):
        return self._modelordraughting

    @modelordraughting.setter
    def modelordraughting(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._modelordraughting = ifcboolean(value)
            else:
                self._modelordraughting = value
        else:
            self._modelordraughting = value


####################
# ENTITY ifctypeprocess #
####################
class ifctypeprocess(ifctypeobject):
    '''Entity ifctypeprocess definition.

	:param identification
	:type identification:ifcidentifier

	:param longdescription
	:type longdescription:ifctext

	:param processtype
	:type processtype:ifclabel

	:param operateson
	:type operateson:SET(0,None,'ifcrelassignstoprocess', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, identification, longdescription,
                 processtype, ):
        ifctypeobject.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                               inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets, )
        self._identification = identification
        self._longdescription = longdescription
        self._processtype = processtype

    @property
    def identification(self):
        return self._identification

    @identification.setter
    def identification(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._identification = ifcidentifier(value)
            else:
                self._identification = value
        else:
            self._identification = value

    @property
    def longdescription(self):
        return self._longdescription

    @longdescription.setter
    def longdescription(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._longdescription = ifctext(value)
            else:
                self._longdescription = value
        else:
            self._longdescription = value

    @property
    def processtype(self):
        return self._processtype

    @processtype.setter
    def processtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._processtype = ifclabel(value)
            else:
                self._processtype = value
        else:
            self._processtype = value

    @property
    def operateson(self):
        return self._operateson

    @operateson.setter
    def operateson(self, value):
        # INVERSE argument
        raise AssertionError('Argument operateson is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifceventtype #
####################
class ifceventtype(ifctypeprocess):
    '''Entity ifceventtype definition.

	:param predefinedtype
	:type predefinedtype:ifceventtypeenum

	:param eventtriggertype
	:type eventtriggertype:ifceventtriggertypeenum

	:param userdefinedeventtriggertype
	:type userdefinedeventtriggertype:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__identification,
                 inherited7__longdescription, inherited8__processtype, predefinedtype, eventtriggertype,
                 userdefinedeventtriggertype, ):
        ifctypeprocess.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__identification, inherited7__longdescription, inherited8__processtype, )
        self._predefinedtype = predefinedtype
        self._eventtriggertype = eventtriggertype
        self._userdefinedeventtriggertype = userdefinedeventtriggertype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifceventtypeenum):
            self._predefinedtype = ifceventtypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def eventtriggertype(self):
        return self._eventtriggertype

    @eventtriggertype.setter
    def eventtriggertype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifceventtriggertypeenum):
            self._eventtriggertype = ifceventtriggertypeenum(value)
        else:
            self._eventtriggertype = value

    @property
    def userdefinedeventtriggertype(self):
        return self._userdefinedeventtriggertype

    @userdefinedeventtriggertype.setter
    def userdefinedeventtriggertype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefinedeventtriggertype = ifclabel(value)
            else:
                self._userdefinedeventtriggertype = value
        else:
            self._userdefinedeventtriggertype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifceventtypeenum.userdefined) or (
                    (self.predefinedtype == ifceventtypeenum.userdefined) and EXISTS(
                self.self.ifctypeprocess.self.processtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcteventtriggertype(self):
        eval_correcteventtriggertype_wr = ((self.eventtriggertype != ifceventtriggertypeenum.userdefined) or (
                    (self.eventtriggertype == ifceventtriggertypeenum.userdefined) and EXISTS(
                self.userdefinedeventtriggertype)))
        if not eval_correcteventtriggertype_wr:
            raise AssertionError('Rule correcteventtriggertype violated')
        else:
            return eval_correcteventtriggertype_wr


####################
# ENTITY ifcexternallydefinedsurfacestyle #
####################
class ifcexternallydefinedsurfacestyle(ifcexternalreference):
    '''Entity ifcexternallydefinedsurfacestyle definition.
	'''

    def __init__(self, inherited0__location, inherited1__identification, inherited2__name, ):
        ifcexternalreference.__init__(self, inherited0__location, inherited1__identification, inherited2__name, )


####################
# ENTITY ifcprocess #
####################
class ifcprocess(ifcobject):
    '''Entity ifcprocess definition.

	:param identification
	:type identification:ifcidentifier

	:param longdescription
	:type longdescription:ifctext

	:param ispredecessorto
	:type ispredecessorto:SET(0,None,'ifcrelsequence', scope = schema_scope)

	:param issuccessorfrom
	:type issuccessorfrom:SET(0,None,'ifcrelsequence', scope = schema_scope)

	:param operateson
	:type operateson:SET(0,None,'ifcrelassignstoprocess', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, identification, longdescription, ):
        ifcobject.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                           inherited3__description, inherited4__objecttype, )
        self._identification = identification
        self._longdescription = longdescription

    @property
    def identification(self):
        return self._identification

    @identification.setter
    def identification(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._identification = ifcidentifier(value)
            else:
                self._identification = value
        else:
            self._identification = value

    @property
    def longdescription(self):
        return self._longdescription

    @longdescription.setter
    def longdescription(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._longdescription = ifctext(value)
            else:
                self._longdescription = value
        else:
            self._longdescription = value

    @property
    def ispredecessorto(self):
        return self._ispredecessorto

    @ispredecessorto.setter
    def ispredecessorto(self, value):
        # INVERSE argument
        raise AssertionError('Argument ispredecessorto is INVERSE. It is computed and can not be set to any value')

    @property
    def issuccessorfrom(self):
        return self._issuccessorfrom

    @issuccessorfrom.setter
    def issuccessorfrom(self, value):
        # INVERSE argument
        raise AssertionError('Argument issuccessorfrom is INVERSE. It is computed and can not be set to any value')

    @property
    def operateson(self):
        return self._operateson

    @operateson.setter
    def operateson(self, value):
        # INVERSE argument
        raise AssertionError('Argument operateson is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifccablesegmenttype #
####################
class ifccablesegmenttype(ifcflowsegmenttype):
    '''Entity ifccablesegmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifccablesegmenttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowsegmenttype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__applicableoccurrence,
                                    inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                    inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccablesegmenttypeenum):
            self._predefinedtype = ifccablesegmenttypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccablesegmenttypeenum.userdefined) or (
                    (self.predefinedtype == ifccablesegmenttypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcderivedunitelement #
####################
class ifcderivedunitelement(BaseEntityClass):
    '''Entity ifcderivedunitelement definition.

	:param unit
	:type unit:ifcnamedunit

	:param exponent
	:type exponent:Integer
	'''

    def __init__(self, unit, exponent, ):
        self._unit = unit
        self._exponent = exponent

    @property
    def unit(self):
        return self._unit

    @unit.setter
    def unit(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcnamedunit):
            self._unit = ifcnamedunit(value)
        else:
            self._unit = value

    @property
    def exponent(self):
        return self._exponent

    @exponent.setter
    def exponent(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, Integer):
            self._exponent = Integer(value)
        else:
            self._exponent = value


####################
# ENTITY ifccartesiantransformationoperator #
####################
class ifccartesiantransformationoperator(ifcgeometricrepresentationitem):
    '''Entity ifccartesiantransformationoperator definition.

	:param axis1
	:type axis1:ifcdirection

	:param axis2
	:type axis2:ifcdirection

	:param localorigin
	:type localorigin:ifccartesianpoint

	:param scale
	:type scale:ifcreal

	:param scl
	:type scl:ifcreal

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, axis1, axis2, localorigin, scale, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._axis1 = axis1
        self._axis2 = axis2
        self._localorigin = localorigin
        self._scale = scale

    @property
    def axis1(self):
        return self._axis1

    @axis1.setter
    def axis1(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdirection):
                self._axis1 = ifcdirection(value)
            else:
                self._axis1 = value
        else:
            self._axis1 = value

    @property
    def axis2(self):
        return self._axis2

    @axis2.setter
    def axis2(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdirection):
                self._axis2 = ifcdirection(value)
            else:
                self._axis2 = value
        else:
            self._axis2 = value

    @property
    def localorigin(self):
        return self._localorigin

    @localorigin.setter
    def localorigin(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccartesianpoint):
            self._localorigin = ifccartesianpoint(value)
        else:
            self._localorigin = value

    @property
    def scale(self):
        return self._scale

    @scale.setter
    def scale(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreal):
                self._scale = ifcreal(value)
            else:
                self._scale = value
        else:
            self._scale = value

    @property
    def scl(self):
        attribute_eval = NVL(self.scale, 1)
        return attribute_eval

    @scl.setter
    def scl(self, value):
        # DERIVED argument
        raise AssertionError('Argument scl is DERIVED. It is computed and can not be set to any value')

    @property
    def dim(self):
        attribute_eval = self.localorigin.self.dim
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')

    def scalegreaterzero(self):
        eval_scalegreaterzero_wr = (self.scl > 0)
        if not eval_scalegreaterzero_wr:
            raise AssertionError('Rule scalegreaterzero violated')
        else:
            return eval_scalegreaterzero_wr


####################
# ENTITY ifccartesiantransformationoperator3d #
####################
class ifccartesiantransformationoperator3d(ifccartesiantransformationoperator):
    '''Entity ifccartesiantransformationoperator3d definition.

	:param axis3
	:type axis3:ifcdirection

	:param u
	:type u:LIST(3,3,'ifcdirection', scope = schema_scope)
	'''

    def __init__(self, inherited0__axis1, inherited1__axis2, inherited2__localorigin, inherited3__scale, axis3, ):
        ifccartesiantransformationoperator.__init__(self, inherited0__axis1, inherited1__axis2, inherited2__localorigin,
                                                    inherited3__scale, )
        self._axis3 = axis3

    @property
    def axis3(self):
        return self._axis3

    @axis3.setter
    def axis3(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdirection):
                self._axis3 = ifcdirection(value)
            else:
                self._axis3 = value
        else:
            self._axis3 = value

    @property
    def u(self):
        attribute_eval = ifcbaseaxis(3, self.self.ifccartesiantransformationoperator.self.axis1,
                                     self.self.ifccartesiantransformationoperator.self.axis2, self.axis3)
        return attribute_eval

    @u.setter
    def u(self, value):
        # DERIVED argument
        raise AssertionError('Argument u is DERIVED. It is computed and can not be set to any value')

    def dimis3d(self):
        eval_dimis3d_wr = (self.self.ifccartesiantransformationoperator.self.dim == 3)
        if not eval_dimis3d_wr:
            raise AssertionError('Rule dimis3d violated')
        else:
            return eval_dimis3d_wr

    def axis1is3d(self):
        eval_axis1is3d_wr = ((not EXISTS(self.self.ifccartesiantransformationoperator.self.axis1)) or (
                    self.self.ifccartesiantransformationoperator.self.axis1.self.dim == 3))
        if not eval_axis1is3d_wr:
            raise AssertionError('Rule axis1is3d violated')
        else:
            return eval_axis1is3d_wr

    def axis2is3d(self):
        eval_axis2is3d_wr = ((not EXISTS(self.self.ifccartesiantransformationoperator.self.axis2)) or (
                    self.self.ifccartesiantransformationoperator.self.axis2.self.dim == 3))
        if not eval_axis2is3d_wr:
            raise AssertionError('Rule axis2is3d violated')
        else:
            return eval_axis2is3d_wr

    def axis3is3d(self):
        eval_axis3is3d_wr = ((not EXISTS(self.axis3)) or (self.axis3.self.dim == 3))
        if not eval_axis3is3d_wr:
            raise AssertionError('Rule axis3is3d violated')
        else:
            return eval_axis3is3d_wr


####################
# ENTITY ifccartesiantransformationoperator3dnonuniform #
####################
class ifccartesiantransformationoperator3dnonuniform(ifccartesiantransformationoperator3d):
    '''Entity ifccartesiantransformationoperator3dnonuniform definition.

	:param scale2
	:type scale2:ifcreal

	:param scale3
	:type scale3:ifcreal

	:param scl2
	:type scl2:ifcreal

	:param scl3
	:type scl3:ifcreal
	'''

    def __init__(self, inherited0__axis1, inherited1__axis2, inherited2__localorigin, inherited3__scale,
                 inherited4__axis3, scale2, scale3, ):
        ifccartesiantransformationoperator3d.__init__(self, inherited0__axis1, inherited1__axis2,
                                                      inherited2__localorigin, inherited3__scale, inherited4__axis3, )
        self._scale2 = scale2
        self._scale3 = scale3

    @property
    def scale2(self):
        return self._scale2

    @scale2.setter
    def scale2(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreal):
                self._scale2 = ifcreal(value)
            else:
                self._scale2 = value
        else:
            self._scale2 = value

    @property
    def scale3(self):
        return self._scale3

    @scale3.setter
    def scale3(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreal):
                self._scale3 = ifcreal(value)
            else:
                self._scale3 = value
        else:
            self._scale3 = value

    @property
    def scl2(self):
        attribute_eval = NVL(self.scale2, self.self.ifccartesiantransformationoperator.self.scl)
        return attribute_eval

    @scl2.setter
    def scl2(self, value):
        # DERIVED argument
        raise AssertionError('Argument scl2 is DERIVED. It is computed and can not be set to any value')

    @property
    def scl3(self):
        attribute_eval = NVL(self.scale3, self.self.ifccartesiantransformationoperator.self.scl)
        return attribute_eval

    @scl3.setter
    def scl3(self, value):
        # DERIVED argument
        raise AssertionError('Argument scl3 is DERIVED. It is computed and can not be set to any value')

    def scale2greaterzero(self):
        eval_scale2greaterzero_wr = (self.scl2 > 0)
        if not eval_scale2greaterzero_wr:
            raise AssertionError('Rule scale2greaterzero violated')
        else:
            return eval_scale2greaterzero_wr

    def scale3greaterzero(self):
        eval_scale3greaterzero_wr = (self.scl3 > 0)
        if not eval_scale3greaterzero_wr:
            raise AssertionError('Rule scale3greaterzero violated')
        else:
            return eval_scale3greaterzero_wr


####################
# ENTITY ifcsurface #
####################
class ifcsurface(ifcgeometricrepresentationitem):
    '''Entity ifcsurface definition.

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, ):
        ifcgeometricrepresentationitem.__init__(self, )

    @property
    def dim(self):
        attribute_eval = 3
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcboundedsurface #
####################
class ifcboundedsurface(ifcsurface):
    '''Entity ifcboundedsurface definition.
	'''

    def __init__(self, ):
        ifcsurface.__init__(self, )


####################
# ENTITY ifccurveboundedplane #
####################
class ifccurveboundedplane(ifcboundedsurface):
    '''Entity ifccurveboundedplane definition.

	:param basissurface
	:type basissurface:ifcplane

	:param outerboundary
	:type outerboundary:ifccurve

	:param innerboundaries
	:type innerboundaries:SET(0,None,'ifccurve', scope = schema_scope)
	'''

    def __init__(self, basissurface, outerboundary, innerboundaries, ):
        ifcboundedsurface.__init__(self, )
        self._basissurface = basissurface
        self._outerboundary = outerboundary
        self._innerboundaries = innerboundaries

    @property
    def basissurface(self):
        return self._basissurface

    @basissurface.setter
    def basissurface(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcplane):
            self._basissurface = ifcplane(value)
        else:
            self._basissurface = value

    @property
    def outerboundary(self):
        return self._outerboundary

    @outerboundary.setter
    def outerboundary(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._outerboundary = ifccurve(value)
        else:
            self._outerboundary = value

    @property
    def innerboundaries(self):
        return self._innerboundaries

    @innerboundaries.setter
    def innerboundaries(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(0, None, 'ifccurve', scope=schema_scope)):
            self._innerboundaries = SET(value)
        else:
            self._innerboundaries = value


####################
# ENTITY ifcrightcircularcylinder #
####################
class ifcrightcircularcylinder(ifccsgprimitive3d):
    '''Entity ifcrightcircularcylinder definition.

	:param height
	:type height:ifcpositivelengthmeasure

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__position, height, radius, ):
        ifccsgprimitive3d.__init__(self, inherited0__position, )
        self._height = height
        self._radius = radius

    @property
    def height(self):
        return self._height

    @height.setter
    def height(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._height = ifcpositivelengthmeasure(value)
        else:
            self._height = value

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._radius = ifcpositivelengthmeasure(value)
        else:
            self._radius = value


####################
# ENTITY ifcvertexloop #
####################
class ifcvertexloop(ifcloop):
    '''Entity ifcvertexloop definition.

	:param loopvertex
	:type loopvertex:ifcvertex
	'''

    def __init__(self, loopvertex, ):
        ifcloop.__init__(self, )
        self._loopvertex = loopvertex

    @property
    def loopvertex(self):
        return self._loopvertex

    @loopvertex.setter
    def loopvertex(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcvertex):
            self._loopvertex = ifcvertex(value)
        else:
            self._loopvertex = value


####################
# ENTITY ifcblock #
####################
class ifcblock(ifccsgprimitive3d):
    '''Entity ifcblock definition.

	:param xlength
	:type xlength:ifcpositivelengthmeasure

	:param ylength
	:type ylength:ifcpositivelengthmeasure

	:param zlength
	:type zlength:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__position, xlength, ylength, zlength, ):
        ifccsgprimitive3d.__init__(self, inherited0__position, )
        self._xlength = xlength
        self._ylength = ylength
        self._zlength = zlength

    @property
    def xlength(self):
        return self._xlength

    @xlength.setter
    def xlength(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._xlength = ifcpositivelengthmeasure(value)
        else:
            self._xlength = value

    @property
    def ylength(self):
        return self._ylength

    @ylength.setter
    def ylength(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._ylength = ifcpositivelengthmeasure(value)
        else:
            self._ylength = value

    @property
    def zlength(self):
        return self._zlength

    @zlength.setter
    def zlength(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._zlength = ifcpositivelengthmeasure(value)
        else:
            self._zlength = value


####################
# ENTITY ifcflowinstrument #
####################
class ifcflowinstrument(ifcdistributioncontrolelement):
    '''Entity ifcflowinstrument definition.

	:param predefinedtype
	:type predefinedtype:ifcflowinstrumenttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcdistributioncontrolelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__objecttype,
                                               inherited5__objectplacement, inherited6__representation,
                                               inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcflowinstrumenttypeenum):
                self._predefinedtype = ifcflowinstrumenttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcflowinstrumenttypeenum.userdefined)) or ((
                                                                                                   self.predefinedtype == ifcflowinstrumenttypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCFLOWINSTRUMENTTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcspatialelement #
####################
class ifcspatialelement(ifcproduct):
    '''Entity ifcspatialelement definition.

	:param longname
	:type longname:ifclabel

	:param containselements
	:type containselements:SET(0,None,'ifcrelcontainedinspatialstructure', scope = schema_scope)

	:param servicedbysystems
	:type servicedbysystems:SET(0,None,'ifcrelservicesbuildings', scope = schema_scope)

	:param referenceselements
	:type referenceselements:SET(0,None,'ifcrelreferencedinspatialstructure', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, longname, ):
        ifcproduct.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, )
        self._longname = longname

    @property
    def longname(self):
        return self._longname

    @longname.setter
    def longname(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._longname = ifclabel(value)
            else:
                self._longname = value
        else:
            self._longname = value

    @property
    def containselements(self):
        return self._containselements

    @containselements.setter
    def containselements(self, value):
        # INVERSE argument
        raise AssertionError('Argument containselements is INVERSE. It is computed and can not be set to any value')

    @property
    def servicedbysystems(self):
        return self._servicedbysystems

    @servicedbysystems.setter
    def servicedbysystems(self, value):
        # INVERSE argument
        raise AssertionError('Argument servicedbysystems is INVERSE. It is computed and can not be set to any value')

    @property
    def referenceselements(self):
        return self._referenceselements

    @referenceselements.setter
    def referenceselements(self, value):
        # INVERSE argument
        raise AssertionError('Argument referenceselements is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcspatialstructureelement #
####################
class ifcspatialstructureelement(ifcspatialelement):
    '''Entity ifcspatialstructureelement definition.

	:param compositiontype
	:type compositiontype:ifcelementcompositionenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__longname,
                 compositiontype, ):
        ifcspatialelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__longname, )
        self._compositiontype = compositiontype

    @property
    def compositiontype(self):
        return self._compositiontype

    @compositiontype.setter
    def compositiontype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcelementcompositionenum):
                self._compositiontype = ifcelementcompositionenum(value)
            else:
                self._compositiontype = value
        else:
            self._compositiontype = value

    def wr41(self):
        eval_wr41_wr = (((HIINDEX(self.self.ifcobjectdefinition.self.decomposes) == 1) and (
                    'IFC4X2.IFCRELAGGREGATES' == TYPEOF(self.self.ifcobjectdefinition.self.decomposes[1]))) and ((
                                                                                                                             'IFC4X2.IFCPROJECT' == TYPEOF(
                                                                                                                         self.self.ifcobjectdefinition.self.decomposes[
                                                                                                                             1].self.relatingobject)) or (
                                                                                                                             'IFC4X2.IFCSPATIALSTRUCTUREELEMENT' == TYPEOF(
                                                                                                                         self.self.ifcobjectdefinition.self.decomposes[
                                                                                                                             1].self.relatingobject))))
        if not eval_wr41_wr:
            raise AssertionError('Rule wr41 violated')
        else:
            return eval_wr41_wr


####################
# ENTITY ifcfacilitypart #
####################
class ifcfacilitypart(ifcspatialstructureelement):
    '''Entity ifcfacilitypart definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__longname,
                 inherited8__compositiontype, ):
        ifcspatialstructureelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation,
                                            inherited7__longname, inherited8__compositiontype, )


####################
# ENTITY ifcbuildingstorey #
####################
class ifcbuildingstorey(ifcfacilitypart):
    '''Entity ifcbuildingstorey definition.

	:param elevation
	:type elevation:ifclengthmeasure
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__longname,
                 inherited8__compositiontype, elevation, ):
        ifcfacilitypart.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__longname, inherited8__compositiontype, )
        self._elevation = elevation

    @property
    def elevation(self):
        return self._elevation

    @elevation.setter
    def elevation(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._elevation = ifclengthmeasure(value)
            else:
                self._elevation = value
        else:
            self._elevation = value


####################
# ENTITY ifccolourspecification #
####################
class ifccolourspecification(ifcpresentationitem):
    '''Entity ifccolourspecification definition.

	:param name
	:type name:ifclabel
	'''

    def __init__(self, name, ):
        ifcpresentationitem.__init__(self, )
        self._name = name

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value


####################
# ENTITY ifccolourrgb #
####################
class ifccolourrgb(ifccolourspecification):
    '''Entity ifccolourrgb definition.

	:param red
	:type red:ifcnormalisedratiomeasure

	:param green
	:type green:ifcnormalisedratiomeasure

	:param blue
	:type blue:ifcnormalisedratiomeasure
	'''

    def __init__(self, inherited0__name, red, green, blue, ):
        ifccolourspecification.__init__(self, inherited0__name, )
        self._red = red
        self._green = green
        self._blue = blue

    @property
    def red(self):
        return self._red

    @red.setter
    def red(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcnormalisedratiomeasure):
            self._red = ifcnormalisedratiomeasure(value)
        else:
            self._red = value

    @property
    def green(self):
        return self._green

    @green.setter
    def green(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcnormalisedratiomeasure):
            self._green = ifcnormalisedratiomeasure(value)
        else:
            self._green = value

    @property
    def blue(self):
        return self._blue

    @blue.setter
    def blue(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcnormalisedratiomeasure):
            self._blue = ifcnormalisedratiomeasure(value)
        else:
            self._blue = value


####################
# ENTITY ifcfiresuppressionterminal #
####################
class ifcfiresuppressionterminal(ifcflowterminal):
    '''Entity ifcfiresuppressionterminal definition.

	:param predefinedtype
	:type predefinedtype:ifcfiresuppressionterminaltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowterminal.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcfiresuppressionterminaltypeenum):
                self._predefinedtype = ifcfiresuppressionterminaltypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcfiresuppressionterminaltypeenum.userdefined)) or ((
                                                                                                            self.predefinedtype == ifcfiresuppressionterminaltypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCFIRESUPPRESSIONTERMINALTYPE' == TYPEOF(
                self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifccoordinateoperation #
####################
class ifccoordinateoperation(BaseEntityClass):
    '''Entity ifccoordinateoperation definition.

	:param sourcecrs
	:type sourcecrs:ifccoordinatereferencesystemselect

	:param targetcrs
	:type targetcrs:ifccoordinatereferencesystem
	'''

    def __init__(self, sourcecrs, targetcrs, ):
        self._sourcecrs = sourcecrs
        self._targetcrs = targetcrs

    @property
    def sourcecrs(self):
        return self._sourcecrs

    @sourcecrs.setter
    def sourcecrs(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccoordinatereferencesystemselect):
            self._sourcecrs = ifccoordinatereferencesystemselect(value)
        else:
            self._sourcecrs = value

    @property
    def targetcrs(self):
        return self._targetcrs

    @targetcrs.setter
    def targetcrs(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccoordinatereferencesystem):
            self._targetcrs = ifccoordinatereferencesystem(value)
        else:
            self._targetcrs = value


####################
# ENTITY ifcmapconversion #
####################
class ifcmapconversion(ifccoordinateoperation):
    '''Entity ifcmapconversion definition.

	:param eastings
	:type eastings:ifclengthmeasure

	:param northings
	:type northings:ifclengthmeasure

	:param orthogonalheight
	:type orthogonalheight:ifclengthmeasure

	:param xaxisabscissa
	:type xaxisabscissa:ifcreal

	:param xaxisordinate
	:type xaxisordinate:ifcreal

	:param scale
	:type scale:ifcreal
	'''

    def __init__(self, inherited0__sourcecrs, inherited1__targetcrs, eastings, northings, orthogonalheight,
                 xaxisabscissa, xaxisordinate, scale, ):
        ifccoordinateoperation.__init__(self, inherited0__sourcecrs, inherited1__targetcrs, )
        self._eastings = eastings
        self._northings = northings
        self._orthogonalheight = orthogonalheight
        self._xaxisabscissa = xaxisabscissa
        self._xaxisordinate = xaxisordinate
        self._scale = scale

    @property
    def eastings(self):
        return self._eastings

    @eastings.setter
    def eastings(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._eastings = ifclengthmeasure(value)
        else:
            self._eastings = value

    @property
    def northings(self):
        return self._northings

    @northings.setter
    def northings(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._northings = ifclengthmeasure(value)
        else:
            self._northings = value

    @property
    def orthogonalheight(self):
        return self._orthogonalheight

    @orthogonalheight.setter
    def orthogonalheight(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._orthogonalheight = ifclengthmeasure(value)
        else:
            self._orthogonalheight = value

    @property
    def xaxisabscissa(self):
        return self._xaxisabscissa

    @xaxisabscissa.setter
    def xaxisabscissa(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreal):
                self._xaxisabscissa = ifcreal(value)
            else:
                self._xaxisabscissa = value
        else:
            self._xaxisabscissa = value

    @property
    def xaxisordinate(self):
        return self._xaxisordinate

    @xaxisordinate.setter
    def xaxisordinate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreal):
                self._xaxisordinate = ifcreal(value)
            else:
                self._xaxisordinate = value
        else:
            self._xaxisordinate = value

    @property
    def scale(self):
        return self._scale

    @scale.setter
    def scale(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreal):
                self._scale = ifcreal(value)
            else:
                self._scale = value
        else:
            self._scale = value


####################
# ENTITY ifcstructuralitem #
####################
class ifcstructuralitem(ifcproduct):
    '''Entity ifcstructuralitem definition.

	:param assignedstructuralactivity
	:type assignedstructuralactivity:SET(0,None,'ifcrelconnectsstructuralactivity', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, ):
        ifcproduct.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, )

    @property
    def assignedstructuralactivity(self):
        return self._assignedstructuralactivity

    @assignedstructuralactivity.setter
    def assignedstructuralactivity(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument assignedstructuralactivity is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcstructuralconnection #
####################
class ifcstructuralconnection(ifcstructuralitem):
    '''Entity ifcstructuralconnection definition.

	:param appliedcondition
	:type appliedcondition:ifcboundarycondition

	:param connectsstructuralmembers
	:type connectsstructuralmembers:SET(1,None,'ifcrelconnectsstructuralmember', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, appliedcondition, ):
        ifcstructuralitem.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, )
        self._appliedcondition = appliedcondition

    @property
    def appliedcondition(self):
        return self._appliedcondition

    @appliedcondition.setter
    def appliedcondition(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboundarycondition):
                self._appliedcondition = ifcboundarycondition(value)
            else:
                self._appliedcondition = value
        else:
            self._appliedcondition = value

    @property
    def connectsstructuralmembers(self):
        return self._connectsstructuralmembers

    @connectsstructuralmembers.setter
    def connectsstructuralmembers(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument connectsstructuralmembers is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcstructuralcurveconnection #
####################
class ifcstructuralcurveconnection(ifcstructuralconnection):
    '''Entity ifcstructuralcurveconnection definition.

	:param axis
	:type axis:ifcdirection
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__appliedcondition, axis, ):
        ifcstructuralconnection.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                         inherited6__representation, inherited7__appliedcondition, )
        self._axis = axis

    @property
    def axis(self):
        return self._axis

    @axis.setter
    def axis(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdirection):
            self._axis = ifcdirection(value)
        else:
            self._axis = value


####################
# ENTITY ifcflowcontroller #
####################
class ifcflowcontroller(ifcdistributionflowelement):
    '''Entity ifcflowcontroller definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcdistributionflowelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation, inherited7__tag, )


####################
# ENTITY ifcairterminalbox #
####################
class ifcairterminalbox(ifcflowcontroller):
    '''Entity ifcairterminalbox definition.

	:param predefinedtype
	:type predefinedtype:ifcairterminalboxtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowcontroller.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcairterminalboxtypeenum):
                self._predefinedtype = ifcairterminalboxtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcairterminalboxtypeenum.userdefined)) or ((
                                                                                                   self.predefinedtype == ifcairterminalboxtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCAIRTERMINALBOXTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifccartesianpointlist #
####################
class ifccartesianpointlist(ifcgeometricrepresentationitem):
    '''Entity ifccartesianpointlist definition.

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, ):
        ifcgeometricrepresentationitem.__init__(self, )

    @property
    def dim(self):
        attribute_eval = ifcpointlistdim(self)
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifccartesianpointlist2d #
####################
class ifccartesianpointlist2d(ifccartesianpointlist):
    '''Entity ifccartesianpointlist2d definition.

	:param coordlist
	:type coordlist:LIST(1,None,LIST(2,2,'REAL', scope = schema_scope))

	:param taglist
	:type taglist:LIST(1,None,'STRING', scope = schema_scope)
	'''

    def __init__(self, coordlist, taglist, ):
        ifccartesianpointlist.__init__(self, )
        self._coordlist = coordlist
        self._taglist = taglist

    @property
    def coordlist(self):
        return self._coordlist

    @coordlist.setter
    def coordlist(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, LIST(2, 2, 'REAL', scope=schema_scope))):
            self._coordlist = LIST(value)
        else:
            self._coordlist = value

    @property
    def taglist(self):
        return self._taglist

    @taglist.setter
    def taglist(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'STRING', scope=schema_scope)):
                self._taglist = LIST(value)
            else:
                self._taglist = value
        else:
            self._taglist = value


####################
# ENTITY ifccoordinatereferencesystem #
####################
class ifccoordinatereferencesystem(BaseEntityClass):
    '''Entity ifccoordinatereferencesystem definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param geodeticdatum
	:type geodeticdatum:ifcidentifier

	:param verticaldatum
	:type verticaldatum:ifcidentifier

	:param hascoordinateoperation
	:type hascoordinateoperation:SET(0,1,'ifccoordinateoperation', scope = schema_scope)
	'''

    def __init__(self, name, description, geodeticdatum, verticaldatum, ):
        self._name = name
        self._description = description
        self._geodeticdatum = geodeticdatum
        self._verticaldatum = verticaldatum

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def geodeticdatum(self):
        return self._geodeticdatum

    @geodeticdatum.setter
    def geodeticdatum(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._geodeticdatum = ifcidentifier(value)
            else:
                self._geodeticdatum = value
        else:
            self._geodeticdatum = value

    @property
    def verticaldatum(self):
        return self._verticaldatum

    @verticaldatum.setter
    def verticaldatum(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._verticaldatum = ifcidentifier(value)
            else:
                self._verticaldatum = value
        else:
            self._verticaldatum = value

    @property
    def hascoordinateoperation(self):
        return self._hascoordinateoperation

    @hascoordinateoperation.setter
    def hascoordinateoperation(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument hascoordinateoperation is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcfacetedbrep #
####################
class ifcfacetedbrep(ifcmanifoldsolidbrep):
    '''Entity ifcfacetedbrep definition.
	'''

    def __init__(self, inherited0__outer, ):
        ifcmanifoldsolidbrep.__init__(self, inherited0__outer, )


####################
# ENTITY ifcfacetedbrepwithvoids #
####################
class ifcfacetedbrepwithvoids(ifcfacetedbrep):
    '''Entity ifcfacetedbrepwithvoids definition.

	:param voids
	:type voids:SET(1,None,'ifcclosedshell', scope = schema_scope)
	'''

    def __init__(self, inherited0__outer, voids, ):
        ifcfacetedbrep.__init__(self, inherited0__outer, )
        self._voids = voids

    @property
    def voids(self):
        return self._voids

    @voids.setter
    def voids(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcclosedshell', scope=schema_scope)):
            self._voids = SET(value)
        else:
            self._voids = value


####################
# ENTITY ifcinventory #
####################
class ifcinventory(ifcgroup):
    '''Entity ifcinventory definition.

	:param predefinedtype
	:type predefinedtype:ifcinventorytypeenum

	:param jurisdiction
	:type jurisdiction:ifcactorselect

	:param responsiblepersons
	:type responsiblepersons:SET(1,None,'ifcperson', scope = schema_scope)

	:param lastupdatedate
	:type lastupdatedate:ifcdate

	:param currentvalue
	:type currentvalue:ifccostvalue

	:param originalvalue
	:type originalvalue:ifccostvalue
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, predefinedtype, jurisdiction, responsiblepersons, lastupdatedate, currentvalue,
                 originalvalue, ):
        ifcgroup.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                          inherited3__description, inherited4__objecttype, )
        self._predefinedtype = predefinedtype
        self._jurisdiction = jurisdiction
        self._responsiblepersons = responsiblepersons
        self._lastupdatedate = lastupdatedate
        self._currentvalue = currentvalue
        self._originalvalue = originalvalue

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcinventorytypeenum):
                self._predefinedtype = ifcinventorytypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def jurisdiction(self):
        return self._jurisdiction

    @jurisdiction.setter
    def jurisdiction(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcactorselect):
                self._jurisdiction = ifcactorselect(value)
            else:
                self._jurisdiction = value
        else:
            self._jurisdiction = value

    @property
    def responsiblepersons(self):
        return self._responsiblepersons

    @responsiblepersons.setter
    def responsiblepersons(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'ifcperson', scope=schema_scope)):
                self._responsiblepersons = SET(value)
            else:
                self._responsiblepersons = value
        else:
            self._responsiblepersons = value

    @property
    def lastupdatedate(self):
        return self._lastupdatedate

    @lastupdatedate.setter
    def lastupdatedate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdate):
                self._lastupdatedate = ifcdate(value)
            else:
                self._lastupdatedate = value
        else:
            self._lastupdatedate = value

    @property
    def currentvalue(self):
        return self._currentvalue

    @currentvalue.setter
    def currentvalue(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccostvalue):
                self._currentvalue = ifccostvalue(value)
            else:
                self._currentvalue = value
        else:
            self._currentvalue = value

    @property
    def originalvalue(self):
        return self._originalvalue

    @originalvalue.setter
    def originalvalue(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccostvalue):
                self._originalvalue = ifccostvalue(value)
            else:
                self._originalvalue = value
        else:
            self._originalvalue = value


####################
# ENTITY ifcfacility #
####################
class ifcfacility(ifcspatialstructureelement):
    '''Entity ifcfacility definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__longname,
                 inherited8__compositiontype, ):
        ifcspatialstructureelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation,
                                            inherited7__longname, inherited8__compositiontype, )


####################
# ENTITY ifcrelsequence #
####################
class ifcrelsequence(ifcrelconnects):
    '''Entity ifcrelsequence definition.

	:param relatingprocess
	:type relatingprocess:ifcprocess

	:param relatedprocess
	:type relatedprocess:ifcprocess

	:param timelag
	:type timelag:ifclagtime

	:param sequencetype
	:type sequencetype:ifcsequenceenum

	:param userdefinedsequencetype
	:type userdefinedsequencetype:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingprocess, relatedprocess, timelag, sequencetype, userdefinedsequencetype, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatingprocess = relatingprocess
        self._relatedprocess = relatedprocess
        self._timelag = timelag
        self._sequencetype = sequencetype
        self._userdefinedsequencetype = userdefinedsequencetype

    @property
    def relatingprocess(self):
        return self._relatingprocess

    @relatingprocess.setter
    def relatingprocess(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprocess):
            self._relatingprocess = ifcprocess(value)
        else:
            self._relatingprocess = value

    @property
    def relatedprocess(self):
        return self._relatedprocess

    @relatedprocess.setter
    def relatedprocess(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprocess):
            self._relatedprocess = ifcprocess(value)
        else:
            self._relatedprocess = value

    @property
    def timelag(self):
        return self._timelag

    @timelag.setter
    def timelag(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclagtime):
                self._timelag = ifclagtime(value)
            else:
                self._timelag = value
        else:
            self._timelag = value

    @property
    def sequencetype(self):
        return self._sequencetype

    @sequencetype.setter
    def sequencetype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsequenceenum):
                self._sequencetype = ifcsequenceenum(value)
            else:
                self._sequencetype = value
        else:
            self._sequencetype = value

    @property
    def userdefinedsequencetype(self):
        return self._userdefinedsequencetype

    @userdefinedsequencetype.setter
    def userdefinedsequencetype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefinedsequencetype = ifclabel(value)
            else:
                self._userdefinedsequencetype = value
        else:
            self._userdefinedsequencetype = value

    def avoidinconsistentsequence(self):
        eval_avoidinconsistentsequence_wr = (self.relatingprocess != self.relatedprocess)
        if not eval_avoidinconsistentsequence_wr:
            raise AssertionError('Rule avoidinconsistentsequence violated')
        else:
            return eval_avoidinconsistentsequence_wr

    def correctsequencetype(self):
        eval_correctsequencetype_wr = ((self.sequencetype != ifcsequenceenum.userdefined) or (
                    (self.sequencetype == ifcsequenceenum.userdefined) and EXISTS(self.userdefinedsequencetype)))
        if not eval_correctsequencetype_wr:
            raise AssertionError('Rule correctsequencetype violated')
        else:
            return eval_correctsequencetype_wr


####################
# ENTITY ifcwall #
####################
class ifcwall(ifcbuildingelement):
    '''Entity ifcwall definition.

	:param predefinedtype
	:type predefinedtype:ifcwalltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcwalltypeenum):
                self._predefinedtype = ifcwalltypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcwalltypeenum.userdefined)) or (
                        (self.predefinedtype == ifcwalltypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCWALLTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifccostschedule #
####################
class ifccostschedule(ifccontrol):
    '''Entity ifccostschedule definition.

	:param predefinedtype
	:type predefinedtype:ifccostscheduletypeenum

	:param status
	:type status:ifclabel

	:param submittedon
	:type submittedon:ifcdatetime

	:param updatedate
	:type updatedate:ifcdatetime
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, predefinedtype, status, submittedon, updatedate, ):
        ifccontrol.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__identification, )
        self._predefinedtype = predefinedtype
        self._status = status
        self._submittedon = submittedon
        self._updatedate = updatedate

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccostscheduletypeenum):
                self._predefinedtype = ifccostscheduletypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def status(self):
        return self._status

    @status.setter
    def status(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._status = ifclabel(value)
            else:
                self._status = value
        else:
            self._status = value

    @property
    def submittedon(self):
        return self._submittedon

    @submittedon.setter
    def submittedon(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._submittedon = ifcdatetime(value)
            else:
                self._submittedon = value
        else:
            self._submittedon = value

    @property
    def updatedate(self):
        return self._updatedate

    @updatedate.setter
    def updatedate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._updatedate = ifcdatetime(value)
            else:
                self._updatedate = value
        else:
            self._updatedate = value


####################
# ENTITY ifccondensertype #
####################
class ifccondensertype(ifcenergyconversiondevicetype):
    '''Entity ifccondensertype definition.

	:param predefinedtype
	:type predefinedtype:ifccondensertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccondensertypeenum):
            self._predefinedtype = ifccondensertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccondensertypeenum.userdefined) or (
                    (self.predefinedtype == ifccondensertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcconstraint #
####################
class ifcconstraint(BaseEntityClass):
    '''Entity ifcconstraint definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param constraintgrade
	:type constraintgrade:ifcconstraintenum

	:param constraintsource
	:type constraintsource:ifclabel

	:param creatingactor
	:type creatingactor:ifcactorselect

	:param creationtime
	:type creationtime:ifcdatetime

	:param userdefinedgrade
	:type userdefinedgrade:ifclabel

	:param hasexternalreferences
	:type hasexternalreferences:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)

	:param propertiesforconstraint
	:type propertiesforconstraint:SET(0,None,'ifcresourceconstraintrelationship', scope = schema_scope)
	'''

    def __init__(self, name, description, constraintgrade, constraintsource, creatingactor, creationtime,
                 userdefinedgrade, ):
        self._name = name
        self._description = description
        self._constraintgrade = constraintgrade
        self._constraintsource = constraintsource
        self._creatingactor = creatingactor
        self._creationtime = creationtime
        self._userdefinedgrade = userdefinedgrade

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def constraintgrade(self):
        return self._constraintgrade

    @constraintgrade.setter
    def constraintgrade(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcconstraintenum):
            self._constraintgrade = ifcconstraintenum(value)
        else:
            self._constraintgrade = value

    @property
    def constraintsource(self):
        return self._constraintsource

    @constraintsource.setter
    def constraintsource(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._constraintsource = ifclabel(value)
            else:
                self._constraintsource = value
        else:
            self._constraintsource = value

    @property
    def creatingactor(self):
        return self._creatingactor

    @creatingactor.setter
    def creatingactor(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcactorselect):
                self._creatingactor = ifcactorselect(value)
            else:
                self._creatingactor = value
        else:
            self._creatingactor = value

    @property
    def creationtime(self):
        return self._creationtime

    @creationtime.setter
    def creationtime(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._creationtime = ifcdatetime(value)
            else:
                self._creationtime = value
        else:
            self._creationtime = value

    @property
    def userdefinedgrade(self):
        return self._userdefinedgrade

    @userdefinedgrade.setter
    def userdefinedgrade(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefinedgrade = ifclabel(value)
            else:
                self._userdefinedgrade = value
        else:
            self._userdefinedgrade = value

    @property
    def hasexternalreferences(self):
        return self._hasexternalreferences

    @hasexternalreferences.setter
    def hasexternalreferences(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument hasexternalreferences is INVERSE. It is computed and can not be set to any value')

    @property
    def propertiesforconstraint(self):
        return self._propertiesforconstraint

    @propertiesforconstraint.setter
    def propertiesforconstraint(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument propertiesforconstraint is INVERSE. It is computed and can not be set to any value')

    def wr11(self):
        eval_wr11_wr = ((self.constraintgrade != ifcconstraintenum.userdefined) or (
                    (self.constraintgrade == ifcconstraintenum.userdefined) and EXISTS(
                self.self.ifcconstraint.self.userdefinedgrade)))
        if not eval_wr11_wr:
            raise AssertionError('Rule wr11 violated')
        else:
            return eval_wr11_wr


####################
# ENTITY ifcobjective #
####################
class ifcobjective(ifcconstraint):
    '''Entity ifcobjective definition.

	:param benchmarkvalues
	:type benchmarkvalues:LIST(1,None,'ifcconstraint', scope = schema_scope)

	:param logicalaggregator
	:type logicalaggregator:ifclogicaloperatorenum

	:param objectivequalifier
	:type objectivequalifier:ifcobjectiveenum

	:param userdefinedqualifier
	:type userdefinedqualifier:ifclabel
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__constraintgrade,
                 inherited3__constraintsource, inherited4__creatingactor, inherited5__creationtime,
                 inherited6__userdefinedgrade, benchmarkvalues, logicalaggregator, objectivequalifier,
                 userdefinedqualifier, ):
        ifcconstraint.__init__(self, inherited0__name, inherited1__description, inherited2__constraintgrade,
                               inherited3__constraintsource, inherited4__creatingactor, inherited5__creationtime,
                               inherited6__userdefinedgrade, )
        self._benchmarkvalues = benchmarkvalues
        self._logicalaggregator = logicalaggregator
        self._objectivequalifier = objectivequalifier
        self._userdefinedqualifier = userdefinedqualifier

    @property
    def benchmarkvalues(self):
        return self._benchmarkvalues

    @benchmarkvalues.setter
    def benchmarkvalues(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcconstraint', scope=schema_scope)):
                self._benchmarkvalues = LIST(value)
            else:
                self._benchmarkvalues = value
        else:
            self._benchmarkvalues = value

    @property
    def logicalaggregator(self):
        return self._logicalaggregator

    @logicalaggregator.setter
    def logicalaggregator(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclogicaloperatorenum):
                self._logicalaggregator = ifclogicaloperatorenum(value)
            else:
                self._logicalaggregator = value
        else:
            self._logicalaggregator = value

    @property
    def objectivequalifier(self):
        return self._objectivequalifier

    @objectivequalifier.setter
    def objectivequalifier(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcobjectiveenum):
            self._objectivequalifier = ifcobjectiveenum(value)
        else:
            self._objectivequalifier = value

    @property
    def userdefinedqualifier(self):
        return self._userdefinedqualifier

    @userdefinedqualifier.setter
    def userdefinedqualifier(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefinedqualifier = ifclabel(value)
            else:
                self._userdefinedqualifier = value
        else:
            self._userdefinedqualifier = value

    def wr21(self):
        eval_wr21_wr = ((self.objectivequalifier != ifcobjectiveenum.userdefined) or (
                    (self.objectivequalifier == ifcobjectiveenum.userdefined) and EXISTS(
                self.self.ifcobjective.self.userdefinedqualifier)))
        if not eval_wr21_wr:
            raise AssertionError('Rule wr21 violated')
        else:
            return eval_wr21_wr


####################
# ENTITY ifcishapeprofiledef #
####################
class ifcishapeprofiledef(ifcparameterizedprofiledef):
    '''Entity ifcishapeprofiledef definition.

	:param overallwidth
	:type overallwidth:ifcpositivelengthmeasure

	:param overalldepth
	:type overalldepth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param flangethickness
	:type flangethickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcnonnegativelengthmeasure

	:param flangeedgeradius
	:type flangeedgeradius:ifcnonnegativelengthmeasure

	:param flangeslope
	:type flangeslope:ifcplaneanglemeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, overallwidth,
                 overalldepth, webthickness, flangethickness, filletradius, flangeedgeradius, flangeslope, ):
        ifcparameterizedprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename,
                                            inherited2__position, )
        self._overallwidth = overallwidth
        self._overalldepth = overalldepth
        self._webthickness = webthickness
        self._flangethickness = flangethickness
        self._filletradius = filletradius
        self._flangeedgeradius = flangeedgeradius
        self._flangeslope = flangeslope

    @property
    def overallwidth(self):
        return self._overallwidth

    @overallwidth.setter
    def overallwidth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._overallwidth = ifcpositivelengthmeasure(value)
        else:
            self._overallwidth = value

    @property
    def overalldepth(self):
        return self._overalldepth

    @overalldepth.setter
    def overalldepth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._overalldepth = ifcpositivelengthmeasure(value)
        else:
            self._overalldepth = value

    @property
    def webthickness(self):
        return self._webthickness

    @webthickness.setter
    def webthickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._webthickness = ifcpositivelengthmeasure(value)
        else:
            self._webthickness = value

    @property
    def flangethickness(self):
        return self._flangethickness

    @flangethickness.setter
    def flangethickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._flangethickness = ifcpositivelengthmeasure(value)
        else:
            self._flangethickness = value

    @property
    def filletradius(self):
        return self._filletradius

    @filletradius.setter
    def filletradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._filletradius = ifcnonnegativelengthmeasure(value)
            else:
                self._filletradius = value
        else:
            self._filletradius = value

    @property
    def flangeedgeradius(self):
        return self._flangeedgeradius

    @flangeedgeradius.setter
    def flangeedgeradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._flangeedgeradius = ifcnonnegativelengthmeasure(value)
            else:
                self._flangeedgeradius = value
        else:
            self._flangeedgeradius = value

    @property
    def flangeslope(self):
        return self._flangeslope

    @flangeslope.setter
    def flangeslope(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplaneanglemeasure):
                self._flangeslope = ifcplaneanglemeasure(value)
            else:
                self._flangeslope = value
        else:
            self._flangeslope = value

    def validflangethickness(self):
        eval_validflangethickness_wr = ((2 * self.flangethickness) < self.overalldepth)
        if not eval_validflangethickness_wr:
            raise AssertionError('Rule validflangethickness violated')
        else:
            return eval_validflangethickness_wr

    def validwebthickness(self):
        eval_validwebthickness_wr = (self.webthickness < self.overallwidth)
        if not eval_validwebthickness_wr:
            raise AssertionError('Rule validwebthickness violated')
        else:
            return eval_validwebthickness_wr

    def validfilletradius(self):
        eval_validfilletradius_wr = ((not EXISTS(self.filletradius)) or (
                    (self.filletradius <= ((self.overallwidth - self.webthickness) / 2)) and (
                        self.filletradius <= ((self.overalldepth - (2 * self.flangethickness)) / 2))))
        if not eval_validfilletradius_wr:
            raise AssertionError('Rule validfilletradius violated')
        else:
            return eval_validfilletradius_wr


####################
# ENTITY ifclamptype #
####################
class ifclamptype(ifcflowterminaltype):
    '''Entity ifclamptype definition.

	:param predefinedtype
	:type predefinedtype:ifclamptypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowterminaltype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__applicableoccurrence,
                                     inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                     inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclamptypeenum):
            self._predefinedtype = ifclamptypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifclamptypeenum.userdefined) or (
                    (self.predefinedtype == ifclamptypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcpcurve #
####################
class ifcpcurve(ifccurve):
    '''Entity ifcpcurve definition.

	:param basissurface
	:type basissurface:ifcsurface

	:param referencecurve
	:type referencecurve:ifccurve
	'''

    def __init__(self, basissurface, referencecurve, ):
        ifccurve.__init__(self, )
        self._basissurface = basissurface
        self._referencecurve = referencecurve

    @property
    def basissurface(self):
        return self._basissurface

    @basissurface.setter
    def basissurface(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsurface):
            self._basissurface = ifcsurface(value)
        else:
            self._basissurface = value

    @property
    def referencecurve(self):
        return self._referencecurve

    @referencecurve.setter
    def referencecurve(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._referencecurve = ifccurve(value)
        else:
            self._referencecurve = value

    def dimis2d(self):
        eval_dimis2d_wr = (self.referencecurve.self.dim == 2)
        if not eval_dimis2d_wr:
            raise AssertionError('Rule dimis2d violated')
        else:
            return eval_dimis2d_wr


####################
# ENTITY ifcfacebound #
####################
class ifcfacebound(ifctopologicalrepresentationitem):
    '''Entity ifcfacebound definition.

	:param bound
	:type bound:ifcloop

	:param orientation
	:type orientation:ifcboolean
	'''

    def __init__(self, bound, orientation, ):
        ifctopologicalrepresentationitem.__init__(self, )
        self._bound = bound
        self._orientation = orientation

    @property
    def bound(self):
        return self._bound

    @bound.setter
    def bound(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcloop):
            self._bound = ifcloop(value)
        else:
            self._bound = value

    @property
    def orientation(self):
        return self._orientation

    @orientation.setter
    def orientation(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._orientation = ifcboolean(value)
        else:
            self._orientation = value


####################
# ENTITY ifcfaceouterbound #
####################
class ifcfaceouterbound(ifcfacebound):
    '''Entity ifcfaceouterbound definition.
	'''

    def __init__(self, inherited0__bound, inherited1__orientation, ):
        ifcfacebound.__init__(self, inherited0__bound, inherited1__orientation, )


####################
# ENTITY ifcreinforcementbarproperties #
####################
class ifcreinforcementbarproperties(ifcpredefinedproperties):
    '''Entity ifcreinforcementbarproperties definition.

	:param totalcrosssectionarea
	:type totalcrosssectionarea:ifcareameasure

	:param steelgrade
	:type steelgrade:ifclabel

	:param barsurface
	:type barsurface:ifcreinforcingbarsurfaceenum

	:param effectivedepth
	:type effectivedepth:ifclengthmeasure

	:param nominalbardiameter
	:type nominalbardiameter:ifcpositivelengthmeasure

	:param barcount
	:type barcount:ifccountmeasure
	'''

    def __init__(self, totalcrosssectionarea, steelgrade, barsurface, effectivedepth, nominalbardiameter, barcount, ):
        ifcpredefinedproperties.__init__(self, )
        self._totalcrosssectionarea = totalcrosssectionarea
        self._steelgrade = steelgrade
        self._barsurface = barsurface
        self._effectivedepth = effectivedepth
        self._nominalbardiameter = nominalbardiameter
        self._barcount = barcount

    @property
    def totalcrosssectionarea(self):
        return self._totalcrosssectionarea

    @totalcrosssectionarea.setter
    def totalcrosssectionarea(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcareameasure):
            self._totalcrosssectionarea = ifcareameasure(value)
        else:
            self._totalcrosssectionarea = value

    @property
    def steelgrade(self):
        return self._steelgrade

    @steelgrade.setter
    def steelgrade(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._steelgrade = ifclabel(value)
        else:
            self._steelgrade = value

    @property
    def barsurface(self):
        return self._barsurface

    @barsurface.setter
    def barsurface(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreinforcingbarsurfaceenum):
                self._barsurface = ifcreinforcingbarsurfaceenum(value)
            else:
                self._barsurface = value
        else:
            self._barsurface = value

    @property
    def effectivedepth(self):
        return self._effectivedepth

    @effectivedepth.setter
    def effectivedepth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._effectivedepth = ifclengthmeasure(value)
            else:
                self._effectivedepth = value
        else:
            self._effectivedepth = value

    @property
    def nominalbardiameter(self):
        return self._nominalbardiameter

    @nominalbardiameter.setter
    def nominalbardiameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._nominalbardiameter = ifcpositivelengthmeasure(value)
            else:
                self._nominalbardiameter = value
        else:
            self._nominalbardiameter = value

    @property
    def barcount(self):
        return self._barcount

    @barcount.setter
    def barcount(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccountmeasure):
                self._barcount = ifccountmeasure(value)
            else:
                self._barcount = value
        else:
            self._barcount = value


####################
# ENTITY ifcwindowtype #
####################
class ifcwindowtype(ifcbuildingelementtype):
    '''Entity ifcwindowtype definition.

	:param predefinedtype
	:type predefinedtype:ifcwindowtypeenum

	:param partitioningtype
	:type partitioningtype:ifcwindowtypepartitioningenum

	:param parametertakesprecedence
	:type parametertakesprecedence:ifcboolean

	:param userdefinedpartitioningtype
	:type userdefinedpartitioningtype:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, partitioningtype, parametertakesprecedence,
                 userdefinedpartitioningtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype
        self._partitioningtype = partitioningtype
        self._parametertakesprecedence = parametertakesprecedence
        self._userdefinedpartitioningtype = userdefinedpartitioningtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcwindowtypeenum):
            self._predefinedtype = ifcwindowtypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def partitioningtype(self):
        return self._partitioningtype

    @partitioningtype.setter
    def partitioningtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcwindowtypepartitioningenum):
            self._partitioningtype = ifcwindowtypepartitioningenum(value)
        else:
            self._partitioningtype = value

    @property
    def parametertakesprecedence(self):
        return self._parametertakesprecedence

    @parametertakesprecedence.setter
    def parametertakesprecedence(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._parametertakesprecedence = ifcboolean(value)
            else:
                self._parametertakesprecedence = value
        else:
            self._parametertakesprecedence = value

    @property
    def userdefinedpartitioningtype(self):
        return self._userdefinedpartitioningtype

    @userdefinedpartitioningtype.setter
    def userdefinedpartitioningtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefinedpartitioningtype = ifclabel(value)
            else:
                self._userdefinedpartitioningtype = value
        else:
            self._userdefinedpartitioningtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcwindowtypeenum.userdefined) or (
                    (self.predefinedtype == ifcwindowtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcasset #
####################
class ifcasset(ifcgroup):
    '''Entity ifcasset definition.

	:param identification
	:type identification:ifcidentifier

	:param originalvalue
	:type originalvalue:ifccostvalue

	:param currentvalue
	:type currentvalue:ifccostvalue

	:param totalreplacementcost
	:type totalreplacementcost:ifccostvalue

	:param owner
	:type owner:ifcactorselect

	:param user
	:type user:ifcactorselect

	:param responsibleperson
	:type responsibleperson:ifcperson

	:param incorporationdate
	:type incorporationdate:ifcdate

	:param depreciatedvalue
	:type depreciatedvalue:ifccostvalue
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, identification, originalvalue, currentvalue, totalreplacementcost, owner, user,
                 responsibleperson, incorporationdate, depreciatedvalue, ):
        ifcgroup.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                          inherited3__description, inherited4__objecttype, )
        self._identification = identification
        self._originalvalue = originalvalue
        self._currentvalue = currentvalue
        self._totalreplacementcost = totalreplacementcost
        self._owner = owner
        self._user = user
        self._responsibleperson = responsibleperson
        self._incorporationdate = incorporationdate
        self._depreciatedvalue = depreciatedvalue

    @property
    def identification(self):
        return self._identification

    @identification.setter
    def identification(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._identification = ifcidentifier(value)
            else:
                self._identification = value
        else:
            self._identification = value

    @property
    def originalvalue(self):
        return self._originalvalue

    @originalvalue.setter
    def originalvalue(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccostvalue):
                self._originalvalue = ifccostvalue(value)
            else:
                self._originalvalue = value
        else:
            self._originalvalue = value

    @property
    def currentvalue(self):
        return self._currentvalue

    @currentvalue.setter
    def currentvalue(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccostvalue):
                self._currentvalue = ifccostvalue(value)
            else:
                self._currentvalue = value
        else:
            self._currentvalue = value

    @property
    def totalreplacementcost(self):
        return self._totalreplacementcost

    @totalreplacementcost.setter
    def totalreplacementcost(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccostvalue):
                self._totalreplacementcost = ifccostvalue(value)
            else:
                self._totalreplacementcost = value
        else:
            self._totalreplacementcost = value

    @property
    def owner(self):
        return self._owner

    @owner.setter
    def owner(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcactorselect):
                self._owner = ifcactorselect(value)
            else:
                self._owner = value
        else:
            self._owner = value

    @property
    def user(self):
        return self._user

    @user.setter
    def user(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcactorselect):
                self._user = ifcactorselect(value)
            else:
                self._user = value
        else:
            self._user = value

    @property
    def responsibleperson(self):
        return self._responsibleperson

    @responsibleperson.setter
    def responsibleperson(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcperson):
                self._responsibleperson = ifcperson(value)
            else:
                self._responsibleperson = value
        else:
            self._responsibleperson = value

    @property
    def incorporationdate(self):
        return self._incorporationdate

    @incorporationdate.setter
    def incorporationdate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdate):
                self._incorporationdate = ifcdate(value)
            else:
                self._incorporationdate = value
        else:
            self._incorporationdate = value

    @property
    def depreciatedvalue(self):
        return self._depreciatedvalue

    @depreciatedvalue.setter
    def depreciatedvalue(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccostvalue):
                self._depreciatedvalue = ifccostvalue(value)
            else:
                self._depreciatedvalue = value
        else:
            self._depreciatedvalue = value


####################
# ENTITY ifcexternalspatialstructureelement #
####################
class ifcexternalspatialstructureelement(ifcspatialelement):
    '''Entity ifcexternalspatialstructureelement definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__longname, ):
        ifcspatialelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__longname, )


####################
# ENTITY ifcroof #
####################
class ifcroof(ifcbuildingelement):
    '''Entity ifcroof definition.

	:param predefinedtype
	:type predefinedtype:ifcrooftypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcrooftypeenum):
                self._predefinedtype = ifcrooftypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcrooftypeenum.userdefined)) or (
                        (self.predefinedtype == ifcrooftypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCROOFTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcsurfacestyle #
####################
class ifcsurfacestyle(ifcpresentationstyle):
    '''Entity ifcsurfacestyle definition.

	:param side
	:type side:ifcsurfaceside

	:param styles
	:type styles:SET(1,5,'ifcsurfacestyleelementselect', scope = schema_scope)
	'''

    def __init__(self, inherited0__name, side, styles, ):
        ifcpresentationstyle.__init__(self, inherited0__name, )
        self._side = side
        self._styles = styles

    @property
    def side(self):
        return self._side

    @side.setter
    def side(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsurfaceside):
            self._side = ifcsurfaceside(value)
        else:
            self._side = value

    @property
    def styles(self):
        return self._styles

    @styles.setter
    def styles(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, 5, 'ifcsurfacestyleelementselect', scope=schema_scope)):
            self._styles = SET(value)
        else:
            self._styles = value

    def maxoneshading(self):
        eval_maxoneshading_wr = (SIZEOF(None) <= 1)
        if not eval_maxoneshading_wr:
            raise AssertionError('Rule maxoneshading violated')
        else:
            return eval_maxoneshading_wr

    def maxonelighting(self):
        eval_maxonelighting_wr = (SIZEOF(None) <= 1)
        if not eval_maxonelighting_wr:
            raise AssertionError('Rule maxonelighting violated')
        else:
            return eval_maxonelighting_wr

    def maxonerefraction(self):
        eval_maxonerefraction_wr = (SIZEOF(None) <= 1)
        if not eval_maxonerefraction_wr:
            raise AssertionError('Rule maxonerefraction violated')
        else:
            return eval_maxonerefraction_wr

    def maxonetextures(self):
        eval_maxonetextures_wr = (SIZEOF(None) <= 1)
        if not eval_maxonetextures_wr:
            raise AssertionError('Rule maxonetextures violated')
        else:
            return eval_maxonetextures_wr

    def maxoneextdefined(self):
        eval_maxoneextdefined_wr = (SIZEOF(None) <= 1)
        if not eval_maxoneextdefined_wr:
            raise AssertionError('Rule maxoneextdefined violated')
        else:
            return eval_maxoneextdefined_wr


####################
# ENTITY ifcaddress #
####################
class ifcaddress(BaseEntityClass):
    '''Entity ifcaddress definition.

	:param purpose
	:type purpose:ifcaddresstypeenum

	:param description
	:type description:ifctext

	:param userdefinedpurpose
	:type userdefinedpurpose:ifclabel

	:param ofperson
	:type ofperson:SET(0,None,'ifcperson', scope = schema_scope)

	:param oforganization
	:type oforganization:SET(0,None,'ifcorganization', scope = schema_scope)
	'''

    def __init__(self, purpose, description, userdefinedpurpose, ):
        self._purpose = purpose
        self._description = description
        self._userdefinedpurpose = userdefinedpurpose

    @property
    def purpose(self):
        return self._purpose

    @purpose.setter
    def purpose(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcaddresstypeenum):
                self._purpose = ifcaddresstypeenum(value)
            else:
                self._purpose = value
        else:
            self._purpose = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def userdefinedpurpose(self):
        return self._userdefinedpurpose

    @userdefinedpurpose.setter
    def userdefinedpurpose(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefinedpurpose = ifclabel(value)
            else:
                self._userdefinedpurpose = value
        else:
            self._userdefinedpurpose = value

    @property
    def ofperson(self):
        return self._ofperson

    @ofperson.setter
    def ofperson(self, value):
        # INVERSE argument
        raise AssertionError('Argument ofperson is INVERSE. It is computed and can not be set to any value')

    @property
    def oforganization(self):
        return self._oforganization

    @oforganization.setter
    def oforganization(self, value):
        # INVERSE argument
        raise AssertionError('Argument oforganization is INVERSE. It is computed and can not be set to any value')

    def wr1(self):
        eval_wr1_wr = ((not EXISTS(self.purpose)) or ((self.purpose != ifcaddresstypeenum.userdefined) or (
                    (self.purpose == ifcaddresstypeenum.userdefined) and EXISTS(self.self.userdefinedpurpose))))
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


####################
# ENTITY ifctelecomaddress #
####################
class ifctelecomaddress(ifcaddress):
    '''Entity ifctelecomaddress definition.

	:param telephonenumbers
	:type telephonenumbers:LIST(1,None,'STRING', scope = schema_scope)

	:param facsimilenumbers
	:type facsimilenumbers:LIST(1,None,'STRING', scope = schema_scope)

	:param pagernumber
	:type pagernumber:ifclabel

	:param electronicmailaddresses
	:type electronicmailaddresses:LIST(1,None,'STRING', scope = schema_scope)

	:param wwwhomepageurl
	:type wwwhomepageurl:ifcurireference

	:param messagingids
	:type messagingids:LIST(1,None,'STRING', scope = schema_scope)
	'''

    def __init__(self, inherited0__purpose, inherited1__description, inherited2__userdefinedpurpose, telephonenumbers,
                 facsimilenumbers, pagernumber, electronicmailaddresses, wwwhomepageurl, messagingids, ):
        ifcaddress.__init__(self, inherited0__purpose, inherited1__description, inherited2__userdefinedpurpose, )
        self._telephonenumbers = telephonenumbers
        self._facsimilenumbers = facsimilenumbers
        self._pagernumber = pagernumber
        self._electronicmailaddresses = electronicmailaddresses
        self._wwwhomepageurl = wwwhomepageurl
        self._messagingids = messagingids

    @property
    def telephonenumbers(self):
        return self._telephonenumbers

    @telephonenumbers.setter
    def telephonenumbers(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'STRING', scope=schema_scope)):
                self._telephonenumbers = LIST(value)
            else:
                self._telephonenumbers = value
        else:
            self._telephonenumbers = value

    @property
    def facsimilenumbers(self):
        return self._facsimilenumbers

    @facsimilenumbers.setter
    def facsimilenumbers(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'STRING', scope=schema_scope)):
                self._facsimilenumbers = LIST(value)
            else:
                self._facsimilenumbers = value
        else:
            self._facsimilenumbers = value

    @property
    def pagernumber(self):
        return self._pagernumber

    @pagernumber.setter
    def pagernumber(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._pagernumber = ifclabel(value)
            else:
                self._pagernumber = value
        else:
            self._pagernumber = value

    @property
    def electronicmailaddresses(self):
        return self._electronicmailaddresses

    @electronicmailaddresses.setter
    def electronicmailaddresses(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'STRING', scope=schema_scope)):
                self._electronicmailaddresses = LIST(value)
            else:
                self._electronicmailaddresses = value
        else:
            self._electronicmailaddresses = value

    @property
    def wwwhomepageurl(self):
        return self._wwwhomepageurl

    @wwwhomepageurl.setter
    def wwwhomepageurl(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcurireference):
                self._wwwhomepageurl = ifcurireference(value)
            else:
                self._wwwhomepageurl = value
        else:
            self._wwwhomepageurl = value

    @property
    def messagingids(self):
        return self._messagingids

    @messagingids.setter
    def messagingids(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'STRING', scope=schema_scope)):
                self._messagingids = LIST(value)
            else:
                self._messagingids = value
        else:
            self._messagingids = value

    def minimumdataprovided(self):
        eval_minimumdataprovided_wr = (((((EXISTS(self.telephonenumbers) or EXISTS(self.facsimilenumbers)) or EXISTS(
            self.pagernumber)) or EXISTS(self.electronicmailaddresses)) or EXISTS(self.wwwhomepageurl)) or EXISTS(
            self.messagingids))
        if not eval_minimumdataprovided_wr:
            raise AssertionError('Rule minimumdataprovided violated')
        else:
            return eval_minimumdataprovided_wr


####################
# ENTITY ifcarbitraryopenprofiledef #
####################
class ifcarbitraryopenprofiledef(ifcprofiledef):
    '''Entity ifcarbitraryopenprofiledef definition.

	:param curve
	:type curve:ifcboundedcurve
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, curve, ):
        ifcprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename, )
        self._curve = curve

    @property
    def curve(self):
        return self._curve

    @curve.setter
    def curve(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboundedcurve):
            self._curve = ifcboundedcurve(value)
        else:
            self._curve = value

    def wr11(self):
        eval_wr11_wr = (('IFC4X2.IFCCENTERLINEPROFILEDEF' == TYPEOF(self)) or (
                    self.self.ifcprofiledef.self.profiletype == ifcprofiletypeenum.curve))
        if not eval_wr11_wr:
            raise AssertionError('Rule wr11 violated')
        else:
            return eval_wr11_wr

    def wr12(self):
        eval_wr12_wr = (self.curve.self.dim == 2)
        if not eval_wr12_wr:
            raise AssertionError('Rule wr12 violated')
        else:
            return eval_wr12_wr


####################
# ENTITY ifcboilertype #
####################
class ifcboilertype(ifcenergyconversiondevicetype):
    '''Entity ifcboilertype definition.

	:param predefinedtype
	:type predefinedtype:ifcboilertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboilertypeenum):
            self._predefinedtype = ifcboilertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcboilertypeenum.userdefined) or (
                    (self.predefinedtype == ifcboilertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcactor #
####################
class ifcactor(ifcobject):
    '''Entity ifcactor definition.

	:param theactor
	:type theactor:ifcactorselect

	:param isactingupon
	:type isactingupon:SET(0,None,'ifcrelassignstoactor', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, theactor, ):
        ifcobject.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                           inherited3__description, inherited4__objecttype, )
        self._theactor = theactor

    @property
    def theactor(self):
        return self._theactor

    @theactor.setter
    def theactor(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcactorselect):
            self._theactor = ifcactorselect(value)
        else:
            self._theactor = value

    @property
    def isactingupon(self):
        return self._isactingupon

    @isactingupon.setter
    def isactingupon(self, value):
        # INVERSE argument
        raise AssertionError('Argument isactingupon is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcelectrictimecontrol #
####################
class ifcelectrictimecontrol(ifcflowcontroller):
    '''Entity ifcelectrictimecontrol definition.

	:param predefinedtype
	:type predefinedtype:ifcelectrictimecontroltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowcontroller.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcelectrictimecontroltypeenum):
                self._predefinedtype = ifcelectrictimecontroltypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcelectrictimecontroltypeenum.userdefined)) or ((
                                                                                                        self.predefinedtype == ifcelectrictimecontroltypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCELECTRICTIMECONTROLTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcmaterialclassificationrelationship #
####################
class ifcmaterialclassificationrelationship(BaseEntityClass):
    '''Entity ifcmaterialclassificationrelationship definition.

	:param materialclassifications
	:type materialclassifications:SET(1,None,'ifcclassificationselect', scope = schema_scope)

	:param classifiedmaterial
	:type classifiedmaterial:ifcmaterial
	'''

    def __init__(self, materialclassifications, classifiedmaterial, ):
        self._materialclassifications = materialclassifications
        self._classifiedmaterial = classifiedmaterial

    @property
    def materialclassifications(self):
        return self._materialclassifications

    @materialclassifications.setter
    def materialclassifications(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcclassificationselect', scope=schema_scope)):
            self._materialclassifications = SET(value)
        else:
            self._materialclassifications = value

    @property
    def classifiedmaterial(self):
        return self._classifiedmaterial

    @classifiedmaterial.setter
    def classifiedmaterial(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmaterial):
            self._classifiedmaterial = ifcmaterial(value)
        else:
            self._classifiedmaterial = value


####################
# ENTITY ifcunitarycontrolelement #
####################
class ifcunitarycontrolelement(ifcdistributioncontrolelement):
    '''Entity ifcunitarycontrolelement definition.

	:param predefinedtype
	:type predefinedtype:ifcunitarycontrolelementtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcdistributioncontrolelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__objecttype,
                                               inherited5__objectplacement, inherited6__representation,
                                               inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcunitarycontrolelementtypeenum):
                self._predefinedtype = ifcunitarycontrolelementtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcunitarycontrolelementtypeenum.userdefined)) or ((
                                                                                                          self.predefinedtype == ifcunitarycontrolelementtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCUNITARYCONTROLELEMENTTYPE' == TYPEOF(
                self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcmaterialusagedefinition #
####################
class ifcmaterialusagedefinition(BaseEntityClass):
    '''Entity ifcmaterialusagedefinition definition.

	:param associatedto
	:type associatedto:SET(1,None,'ifcrelassociatesmaterial', scope = schema_scope)
	'''
    # This class does not define any attribute.
    pass

    @property
    def associatedto(self):
        return self._associatedto

    @associatedto.setter
    def associatedto(self, value):
        # INVERSE argument
        raise AssertionError('Argument associatedto is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcmateriallayersetusage #
####################
class ifcmateriallayersetusage(ifcmaterialusagedefinition):
    '''Entity ifcmateriallayersetusage definition.

	:param forlayerset
	:type forlayerset:ifcmateriallayerset

	:param layersetdirection
	:type layersetdirection:ifclayersetdirectionenum

	:param directionsense
	:type directionsense:ifcdirectionsenseenum

	:param offsetfromreferenceline
	:type offsetfromreferenceline:ifclengthmeasure

	:param referenceextent
	:type referenceextent:ifcpositivelengthmeasure
	'''

    def __init__(self, forlayerset, layersetdirection, directionsense, offsetfromreferenceline, referenceextent, ):
        ifcmaterialusagedefinition.__init__(self, )
        self._forlayerset = forlayerset
        self._layersetdirection = layersetdirection
        self._directionsense = directionsense
        self._offsetfromreferenceline = offsetfromreferenceline
        self._referenceextent = referenceextent

    @property
    def forlayerset(self):
        return self._forlayerset

    @forlayerset.setter
    def forlayerset(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmateriallayerset):
            self._forlayerset = ifcmateriallayerset(value)
        else:
            self._forlayerset = value

    @property
    def layersetdirection(self):
        return self._layersetdirection

    @layersetdirection.setter
    def layersetdirection(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclayersetdirectionenum):
            self._layersetdirection = ifclayersetdirectionenum(value)
        else:
            self._layersetdirection = value

    @property
    def directionsense(self):
        return self._directionsense

    @directionsense.setter
    def directionsense(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdirectionsenseenum):
            self._directionsense = ifcdirectionsenseenum(value)
        else:
            self._directionsense = value

    @property
    def offsetfromreferenceline(self):
        return self._offsetfromreferenceline

    @offsetfromreferenceline.setter
    def offsetfromreferenceline(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._offsetfromreferenceline = ifclengthmeasure(value)
        else:
            self._offsetfromreferenceline = value

    @property
    def referenceextent(self):
        return self._referenceextent

    @referenceextent.setter
    def referenceextent(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._referenceextent = ifcpositivelengthmeasure(value)
            else:
                self._referenceextent = value
        else:
            self._referenceextent = value


####################
# ENTITY ifccsgsolid #
####################
class ifccsgsolid(ifcsolidmodel):
    '''Entity ifccsgsolid definition.

	:param treerootexpression
	:type treerootexpression:ifccsgselect
	'''

    def __init__(self, treerootexpression, ):
        ifcsolidmodel.__init__(self, )
        self._treerootexpression = treerootexpression

    @property
    def treerootexpression(self):
        return self._treerootexpression

    @treerootexpression.setter
    def treerootexpression(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccsgselect):
            self._treerootexpression = ifccsgselect(value)
        else:
            self._treerootexpression = value


####################
# ENTITY ifcspatialzone #
####################
class ifcspatialzone(ifcspatialelement):
    '''Entity ifcspatialzone definition.

	:param predefinedtype
	:type predefinedtype:ifcspatialzonetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__longname,
                 predefinedtype, ):
        ifcspatialelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__longname, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcspatialzonetypeenum):
                self._predefinedtype = ifcspatialzonetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcspatialzonetypeenum.userdefined)) or ((
                                                                                                self.predefinedtype == ifcspatialzonetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCSPATIALZONETYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcquantityset #
####################
class ifcquantityset(ifcpropertysetdefinition):
    '''Entity ifcquantityset definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description, ):
        ifcpropertysetdefinition.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, )


####################
# ENTITY ifcelementquantity #
####################
class ifcelementquantity(ifcquantityset):
    '''Entity ifcelementquantity definition.

	:param methodofmeasurement
	:type methodofmeasurement:ifclabel

	:param quantities
	:type quantities:SET(1,None,'ifcphysicalquantity', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 methodofmeasurement, quantities, ):
        ifcquantityset.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._methodofmeasurement = methodofmeasurement
        self._quantities = quantities

    @property
    def methodofmeasurement(self):
        return self._methodofmeasurement

    @methodofmeasurement.setter
    def methodofmeasurement(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._methodofmeasurement = ifclabel(value)
            else:
                self._methodofmeasurement = value
        else:
            self._methodofmeasurement = value

    @property
    def quantities(self):
        return self._quantities

    @quantities.setter
    def quantities(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcphysicalquantity', scope=schema_scope)):
            self._quantities = SET(value)
        else:
            self._quantities = value

    def uniquequantitynames(self):
        eval_uniquequantitynames_wr = ifcuniquequantitynames(self.quantities)
        if not eval_uniquequantitynames_wr:
            raise AssertionError('Rule uniquequantitynames violated')
        else:
            return eval_uniquequantitynames_wr


####################
# ENTITY ifcproceduretype #
####################
class ifcproceduretype(ifctypeprocess):
    '''Entity ifcproceduretype definition.

	:param predefinedtype
	:type predefinedtype:ifcproceduretypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__identification,
                 inherited7__longdescription, inherited8__processtype, predefinedtype, ):
        ifctypeprocess.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__identification, inherited7__longdescription, inherited8__processtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcproceduretypeenum):
            self._predefinedtype = ifcproceduretypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcproceduretypeenum.userdefined) or (
                    (self.predefinedtype == ifcproceduretypeenum.userdefined) and EXISTS(
                self.self.ifctypeprocess.self.processtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcrampflight #
####################
class ifcrampflight(ifcbuildingelement):
    '''Entity ifcrampflight definition.

	:param predefinedtype
	:type predefinedtype:ifcrampflighttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcrampflighttypeenum):
                self._predefinedtype = ifcrampflighttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcrampflighttypeenum.userdefined)) or ((
                                                                                               self.predefinedtype == ifcrampflighttypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCRAMPFLIGHTTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcreferent #
####################
class ifcreferent(ifcpositioningelement):
    '''Entity ifcreferent definition.

	:param predefinedtype
	:type predefinedtype:ifcreferenttypeenum

	:param restartdistance
	:type restartdistance:ifclengthmeasure
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, predefinedtype,
                 restartdistance, ):
        ifcpositioningelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                       inherited6__representation, )
        self._predefinedtype = predefinedtype
        self._restartdistance = restartdistance

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreferenttypeenum):
                self._predefinedtype = ifcreferenttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def restartdistance(self):
        return self._restartdistance

    @restartdistance.setter
    def restartdistance(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._restartdistance = ifclengthmeasure(value)
            else:
                self._restartdistance = value
        else:
            self._restartdistance = value


####################
# ENTITY ifcorganizationrelationship #
####################
class ifcorganizationrelationship(ifcresourcelevelrelationship):
    '''Entity ifcorganizationrelationship definition.

	:param relatingorganization
	:type relatingorganization:ifcorganization

	:param relatedorganizations
	:type relatedorganizations:SET(1,None,'ifcorganization', scope = schema_scope)
	'''

    def __init__(self, inherited0__name, inherited1__description, relatingorganization, relatedorganizations, ):
        ifcresourcelevelrelationship.__init__(self, inherited0__name, inherited1__description, )
        self._relatingorganization = relatingorganization
        self._relatedorganizations = relatedorganizations

    @property
    def relatingorganization(self):
        return self._relatingorganization

    @relatingorganization.setter
    def relatingorganization(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcorganization):
            self._relatingorganization = ifcorganization(value)
        else:
            self._relatingorganization = value

    @property
    def relatedorganizations(self):
        return self._relatedorganizations

    @relatedorganizations.setter
    def relatedorganizations(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcorganization', scope=schema_scope)):
            self._relatedorganizations = SET(value)
        else:
            self._relatedorganizations = value


####################
# ENTITY ifcshapeaspect #
####################
class ifcshapeaspect(BaseEntityClass):
    '''Entity ifcshapeaspect definition.

	:param shaperepresentations
	:type shaperepresentations:LIST(1,None,'ifcshapemodel', scope = schema_scope)

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param productdefinitional
	:type productdefinitional:ifclogical

	:param partofproductdefinitionshape
	:type partofproductdefinitionshape:ifcproductrepresentationselect

	:param hasexternalreferences
	:type hasexternalreferences:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''

    def __init__(self, shaperepresentations, name, description, productdefinitional, partofproductdefinitionshape, ):
        self._shaperepresentations = shaperepresentations
        self._name = name
        self._description = description
        self._productdefinitional = productdefinitional
        self._partofproductdefinitionshape = partofproductdefinitionshape

    @property
    def shaperepresentations(self):
        return self._shaperepresentations

    @shaperepresentations.setter
    def shaperepresentations(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcshapemodel', scope=schema_scope)):
            self._shaperepresentations = LIST(value)
        else:
            self._shaperepresentations = value

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def productdefinitional(self):
        return self._productdefinitional

    @productdefinitional.setter
    def productdefinitional(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclogical):
            self._productdefinitional = ifclogical(value)
        else:
            self._productdefinitional = value

    @property
    def partofproductdefinitionshape(self):
        return self._partofproductdefinitionshape

    @partofproductdefinitionshape.setter
    def partofproductdefinitionshape(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcproductrepresentationselect):
                self._partofproductdefinitionshape = ifcproductrepresentationselect(value)
            else:
                self._partofproductdefinitionshape = value
        else:
            self._partofproductdefinitionshape = value

    @property
    def hasexternalreferences(self):
        return self._hasexternalreferences

    @hasexternalreferences.setter
    def hasexternalreferences(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument hasexternalreferences is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifctendonanchortype #
####################
class ifctendonanchortype(ifcreinforcingelementtype):
    '''Entity ifctendonanchortype definition.

	:param predefinedtype
	:type predefinedtype:ifctendonanchortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcreinforcingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__applicableoccurrence,
                                           inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                           inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctendonanchortypeenum):
            self._predefinedtype = ifctendonanchortypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifctendonanchortypeenum.userdefined) or (
                    (self.predefinedtype == ifctendonanchortypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcalignment #
####################
class ifcalignment(ifclinearpositioningelement):
    '''Entity ifcalignment definition.

	:param predefinedtype
	:type predefinedtype:ifcalignmenttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__axis,
                 predefinedtype, ):
        ifclinearpositioningelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                             inherited3__description, inherited4__objecttype,
                                             inherited5__objectplacement, inherited6__representation,
                                             inherited7__axis, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcalignmenttypeenum):
                self._predefinedtype = ifcalignmenttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value


####################
# ENTITY ifcreldeclares #
####################
class ifcreldeclares(ifcrelationship):
    '''Entity ifcreldeclares definition.

	:param relatingcontext
	:type relatingcontext:ifccontext

	:param relateddefinitions
	:type relateddefinitions:SET(1,None,'ifcdefinitionselect', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingcontext, relateddefinitions, ):
        ifcrelationship.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, )
        self._relatingcontext = relatingcontext
        self._relateddefinitions = relateddefinitions

    @property
    def relatingcontext(self):
        return self._relatingcontext

    @relatingcontext.setter
    def relatingcontext(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccontext):
            self._relatingcontext = ifccontext(value)
        else:
            self._relatingcontext = value

    @property
    def relateddefinitions(self):
        return self._relateddefinitions

    @relateddefinitions.setter
    def relateddefinitions(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcdefinitionselect', scope=schema_scope)):
            self._relateddefinitions = SET(value)
        else:
            self._relateddefinitions = value

    def noselfreference(self):
        eval_noselfreference_wr = (SIZEOF(None) == 0)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifcpipefitting #
####################
class ifcpipefitting(ifcflowfitting):
    '''Entity ifcpipefitting definition.

	:param predefinedtype
	:type predefinedtype:ifcpipefittingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowfitting.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpipefittingtypeenum):
                self._predefinedtype = ifcpipefittingtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcpipefittingtypeenum.userdefined)) or ((
                                                                                                self.predefinedtype == ifcpipefittingtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCPIPEFITTINGTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcrelcoversbldgelements #
####################
class ifcrelcoversbldgelements(ifcrelconnects):
    '''Entity ifcrelcoversbldgelements definition.

	:param relatingbuildingelement
	:type relatingbuildingelement:ifcelement

	:param relatedcoverings
	:type relatedcoverings:SET(1,None,'ifccovering', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingbuildingelement, relatedcoverings, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatingbuildingelement = relatingbuildingelement
        self._relatedcoverings = relatedcoverings

    @property
    def relatingbuildingelement(self):
        return self._relatingbuildingelement

    @relatingbuildingelement.setter
    def relatingbuildingelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelement):
            self._relatingbuildingelement = ifcelement(value)
        else:
            self._relatingbuildingelement = value

    @property
    def relatedcoverings(self):
        return self._relatedcoverings

    @relatedcoverings.setter
    def relatedcoverings(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifccovering', scope=schema_scope)):
            self._relatedcoverings = SET(value)
        else:
            self._relatedcoverings = value


####################
# ENTITY ifcflowtreatmentdevice #
####################
class ifcflowtreatmentdevice(ifcdistributionflowelement):
    '''Entity ifcflowtreatmentdevice definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcdistributionflowelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation, inherited7__tag, )


####################
# ENTITY ifcductsilencer #
####################
class ifcductsilencer(ifcflowtreatmentdevice):
    '''Entity ifcductsilencer definition.

	:param predefinedtype
	:type predefinedtype:ifcductsilencertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowtreatmentdevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                        inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcductsilencertypeenum):
                self._predefinedtype = ifcductsilencertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcductsilencertypeenum.userdefined)) or ((
                                                                                                 self.predefinedtype == ifcductsilencertypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCDUCTSILENCERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifclaborresource #
####################
class ifclaborresource(ifcconstructionresource):
    '''Entity ifclaborresource definition.

	:param predefinedtype
	:type predefinedtype:ifclaborresourcetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, inherited6__longdescription, inherited7__usage,
                 inherited8__basecosts, inherited9__basequantity, predefinedtype, ):
        ifcconstructionresource.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__objecttype, inherited5__identification,
                                         inherited6__longdescription, inherited7__usage, inherited8__basecosts,
                                         inherited9__basequantity, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclaborresourcetypeenum):
                self._predefinedtype = ifclaborresourcetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifclaborresourcetypeenum.userdefined)) or ((
                                                                                                  self.predefinedtype == ifclaborresourcetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcphysicalquantity #
####################
class ifcphysicalquantity(BaseEntityClass):
    '''Entity ifcphysicalquantity definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param hasexternalreferences
	:type hasexternalreferences:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)

	:param partofcomplex
	:type partofcomplex:SET(0,1,'ifcphysicalcomplexquantity', scope = schema_scope)
	'''

    def __init__(self, name, description, ):
        self._name = name
        self._description = description

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def hasexternalreferences(self):
        return self._hasexternalreferences

    @hasexternalreferences.setter
    def hasexternalreferences(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument hasexternalreferences is INVERSE. It is computed and can not be set to any value')

    @property
    def partofcomplex(self):
        return self._partofcomplex

    @partofcomplex.setter
    def partofcomplex(self, value):
        # INVERSE argument
        raise AssertionError('Argument partofcomplex is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcphysicalsimplequantity #
####################
class ifcphysicalsimplequantity(ifcphysicalquantity):
    '''Entity ifcphysicalsimplequantity definition.

	:param unit
	:type unit:ifcnamedunit
	'''

    def __init__(self, inherited0__name, inherited1__description, unit, ):
        ifcphysicalquantity.__init__(self, inherited0__name, inherited1__description, )
        self._unit = unit

    @property
    def unit(self):
        return self._unit

    @unit.setter
    def unit(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnamedunit):
                self._unit = ifcnamedunit(value)
            else:
                self._unit = value
        else:
            self._unit = value


####################
# ENTITY ifcquantitycount #
####################
class ifcquantitycount(ifcphysicalsimplequantity):
    '''Entity ifcquantitycount definition.

	:param countvalue
	:type countvalue:ifccountmeasure

	:param formula
	:type formula:ifclabel
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__unit, countvalue, formula, ):
        ifcphysicalsimplequantity.__init__(self, inherited0__name, inherited1__description, inherited2__unit, )
        self._countvalue = countvalue
        self._formula = formula

    @property
    def countvalue(self):
        return self._countvalue

    @countvalue.setter
    def countvalue(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccountmeasure):
            self._countvalue = ifccountmeasure(value)
        else:
            self._countvalue = value

    @property
    def formula(self):
        return self._formula

    @formula.setter
    def formula(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._formula = ifclabel(value)
            else:
                self._formula = value
        else:
            self._formula = value

    def wr21(self):
        eval_wr21_wr = (self.countvalue >= 0)
        if not eval_wr21_wr:
            raise AssertionError('Rule wr21 violated')
        else:
            return eval_wr21_wr


####################
# ENTITY ifcquantitylength #
####################
class ifcquantitylength(ifcphysicalsimplequantity):
    '''Entity ifcquantitylength definition.

	:param lengthvalue
	:type lengthvalue:ifclengthmeasure

	:param formula
	:type formula:ifclabel
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__unit, lengthvalue, formula, ):
        ifcphysicalsimplequantity.__init__(self, inherited0__name, inherited1__description, inherited2__unit, )
        self._lengthvalue = lengthvalue
        self._formula = formula

    @property
    def lengthvalue(self):
        return self._lengthvalue

    @lengthvalue.setter
    def lengthvalue(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._lengthvalue = ifclengthmeasure(value)
        else:
            self._lengthvalue = value

    @property
    def formula(self):
        return self._formula

    @formula.setter
    def formula(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._formula = ifclabel(value)
            else:
                self._formula = value
        else:
            self._formula = value

    def wr21(self):
        eval_wr21_wr = ((not EXISTS(self.self.ifcphysicalsimplequantity.self.unit)) or (
                    self.self.ifcphysicalsimplequantity.self.unit.self.unittype == ifcunitenum.lengthunit))
        if not eval_wr21_wr:
            raise AssertionError('Rule wr21 violated')
        else:
            return eval_wr21_wr

    def wr22(self):
        eval_wr22_wr = (self.lengthvalue >= 0)
        if not eval_wr22_wr:
            raise AssertionError('Rule wr22 violated')
        else:
            return eval_wr22_wr


####################
# ENTITY ifcrelconnectsstructuralmember #
####################
class ifcrelconnectsstructuralmember(ifcrelconnects):
    '''Entity ifcrelconnectsstructuralmember definition.

	:param relatingstructuralmember
	:type relatingstructuralmember:ifcstructuralmember

	:param relatedstructuralconnection
	:type relatedstructuralconnection:ifcstructuralconnection

	:param appliedcondition
	:type appliedcondition:ifcboundarycondition

	:param additionalconditions
	:type additionalconditions:ifcstructuralconnectioncondition

	:param supportedlength
	:type supportedlength:ifclengthmeasure

	:param conditioncoordinatesystem
	:type conditioncoordinatesystem:ifcaxis2placement3d
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingstructuralmember, relatedstructuralconnection, appliedcondition, additionalconditions,
                 supportedlength, conditioncoordinatesystem, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatingstructuralmember = relatingstructuralmember
        self._relatedstructuralconnection = relatedstructuralconnection
        self._appliedcondition = appliedcondition
        self._additionalconditions = additionalconditions
        self._supportedlength = supportedlength
        self._conditioncoordinatesystem = conditioncoordinatesystem

    @property
    def relatingstructuralmember(self):
        return self._relatingstructuralmember

    @relatingstructuralmember.setter
    def relatingstructuralmember(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstructuralmember):
            self._relatingstructuralmember = ifcstructuralmember(value)
        else:
            self._relatingstructuralmember = value

    @property
    def relatedstructuralconnection(self):
        return self._relatedstructuralconnection

    @relatedstructuralconnection.setter
    def relatedstructuralconnection(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstructuralconnection):
            self._relatedstructuralconnection = ifcstructuralconnection(value)
        else:
            self._relatedstructuralconnection = value

    @property
    def appliedcondition(self):
        return self._appliedcondition

    @appliedcondition.setter
    def appliedcondition(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboundarycondition):
                self._appliedcondition = ifcboundarycondition(value)
            else:
                self._appliedcondition = value
        else:
            self._appliedcondition = value

    @property
    def additionalconditions(self):
        return self._additionalconditions

    @additionalconditions.setter
    def additionalconditions(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcstructuralconnectioncondition):
                self._additionalconditions = ifcstructuralconnectioncondition(value)
            else:
                self._additionalconditions = value
        else:
            self._additionalconditions = value

    @property
    def supportedlength(self):
        return self._supportedlength

    @supportedlength.setter
    def supportedlength(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._supportedlength = ifclengthmeasure(value)
            else:
                self._supportedlength = value
        else:
            self._supportedlength = value

    @property
    def conditioncoordinatesystem(self):
        return self._conditioncoordinatesystem

    @conditioncoordinatesystem.setter
    def conditioncoordinatesystem(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcaxis2placement3d):
                self._conditioncoordinatesystem = ifcaxis2placement3d(value)
            else:
                self._conditioncoordinatesystem = value
        else:
            self._conditioncoordinatesystem = value


####################
# ENTITY ifcrelconnectswitheccentricity #
####################
class ifcrelconnectswitheccentricity(ifcrelconnectsstructuralmember):
    '''Entity ifcrelconnectswitheccentricity definition.

	:param connectionconstraint
	:type connectionconstraint:ifcconnectiongeometry
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatingstructuralmember, inherited5__relatedstructuralconnection,
                 inherited6__appliedcondition, inherited7__additionalconditions, inherited8__supportedlength,
                 inherited9__conditioncoordinatesystem, connectionconstraint, ):
        ifcrelconnectsstructuralmember.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                                inherited3__description, inherited4__relatingstructuralmember,
                                                inherited5__relatedstructuralconnection, inherited6__appliedcondition,
                                                inherited7__additionalconditions, inherited8__supportedlength,
                                                inherited9__conditioncoordinatesystem, )
        self._connectionconstraint = connectionconstraint

    @property
    def connectionconstraint(self):
        return self._connectionconstraint

    @connectionconstraint.setter
    def connectionconstraint(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcconnectiongeometry):
            self._connectionconstraint = ifcconnectiongeometry(value)
        else:
            self._connectionconstraint = value


####################
# ENTITY ifcrelflowcontrolelements #
####################
class ifcrelflowcontrolelements(ifcrelconnects):
    '''Entity ifcrelflowcontrolelements definition.

	:param relatedcontrolelements
	:type relatedcontrolelements:SET(1,None,'ifcdistributioncontrolelement', scope = schema_scope)

	:param relatingflowelement
	:type relatingflowelement:ifcdistributionflowelement
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatedcontrolelements, relatingflowelement, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatedcontrolelements = relatedcontrolelements
        self._relatingflowelement = relatingflowelement

    @property
    def relatedcontrolelements(self):
        return self._relatedcontrolelements

    @relatedcontrolelements.setter
    def relatedcontrolelements(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcdistributioncontrolelement', scope=schema_scope)):
            self._relatedcontrolelements = SET(value)
        else:
            self._relatedcontrolelements = value

    @property
    def relatingflowelement(self):
        return self._relatingflowelement

    @relatingflowelement.setter
    def relatingflowelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdistributionflowelement):
            self._relatingflowelement = ifcdistributionflowelement(value)
        else:
            self._relatingflowelement = value


####################
# ENTITY ifcstructuralreaction #
####################
class ifcstructuralreaction(ifcstructuralactivity):
    '''Entity ifcstructuralreaction definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__appliedload, inherited8__globalorlocal, ):
        ifcstructuralactivity.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                       inherited6__representation, inherited7__appliedload, inherited8__globalorlocal, )


####################
# ENTITY ifcstructuralpointreaction #
####################
class ifcstructuralpointreaction(ifcstructuralreaction):
    '''Entity ifcstructuralpointreaction definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__appliedload, inherited8__globalorlocal, ):
        ifcstructuralreaction.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                       inherited6__representation, inherited7__appliedload, inherited8__globalorlocal, )

    def suitableloadtype(self):
        eval_suitableloadtype_wr = (SIZEOF(
            ['IFC4X2.IFCSTRUCTURALLOADSINGLEFORCE', 'IFC4X2.IFCSTRUCTURALLOADSINGLEDISPLACEMENT'] * TYPEOF(
                self.self.ifcstructuralactivity.self.appliedload)) == 1)
        if not eval_suitableloadtype_wr:
            raise AssertionError('Rule suitableloadtype violated')
        else:
            return eval_suitableloadtype_wr


####################
# ENTITY ifcsanitaryterminal #
####################
class ifcsanitaryterminal(ifcflowterminal):
    '''Entity ifcsanitaryterminal definition.

	:param predefinedtype
	:type predefinedtype:ifcsanitaryterminaltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowterminal.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsanitaryterminaltypeenum):
                self._predefinedtype = ifcsanitaryterminaltypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcsanitaryterminaltypeenum.userdefined)) or ((
                                                                                                     self.predefinedtype == ifcsanitaryterminaltypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCSANITARYTERMINALTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcproperty #
####################
class ifcproperty(ifcpropertyabstraction):
    '''Entity ifcproperty definition.

	:param name
	:type name:ifcidentifier

	:param description
	:type description:ifctext

	:param partofpset
	:type partofpset:SET(0,None,'ifcpropertyset', scope = schema_scope)

	:param propertyfordependance
	:type propertyfordependance:SET(0,None,'ifcpropertydependencyrelationship', scope = schema_scope)

	:param propertydependson
	:type propertydependson:SET(0,None,'ifcpropertydependencyrelationship', scope = schema_scope)

	:param partofcomplex
	:type partofcomplex:SET(0,None,'ifccomplexproperty', scope = schema_scope)

	:param hasconstraints
	:type hasconstraints:SET(0,None,'ifcresourceconstraintrelationship', scope = schema_scope)

	:param hasapprovals
	:type hasapprovals:SET(0,None,'ifcresourceapprovalrelationship', scope = schema_scope)
	'''

    def __init__(self, name, description, ):
        ifcpropertyabstraction.__init__(self, )
        self._name = name
        self._description = description

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcidentifier):
            self._name = ifcidentifier(value)
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def partofpset(self):
        return self._partofpset

    @partofpset.setter
    def partofpset(self, value):
        # INVERSE argument
        raise AssertionError('Argument partofpset is INVERSE. It is computed and can not be set to any value')

    @property
    def propertyfordependance(self):
        return self._propertyfordependance

    @propertyfordependance.setter
    def propertyfordependance(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument propertyfordependance is INVERSE. It is computed and can not be set to any value')

    @property
    def propertydependson(self):
        return self._propertydependson

    @propertydependson.setter
    def propertydependson(self, value):
        # INVERSE argument
        raise AssertionError('Argument propertydependson is INVERSE. It is computed and can not be set to any value')

    @property
    def partofcomplex(self):
        return self._partofcomplex

    @partofcomplex.setter
    def partofcomplex(self, value):
        # INVERSE argument
        raise AssertionError('Argument partofcomplex is INVERSE. It is computed and can not be set to any value')

    @property
    def hasconstraints(self):
        return self._hasconstraints

    @hasconstraints.setter
    def hasconstraints(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasconstraints is INVERSE. It is computed and can not be set to any value')

    @property
    def hasapprovals(self):
        return self._hasapprovals

    @hasapprovals.setter
    def hasapprovals(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasapprovals is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcsimpleproperty #
####################
class ifcsimpleproperty(ifcproperty):
    '''Entity ifcsimpleproperty definition.
	'''

    def __init__(self, inherited0__name, inherited1__description, ):
        ifcproperty.__init__(self, inherited0__name, inherited1__description, )


####################
# ENTITY ifcunitassignment #
####################
class ifcunitassignment(BaseEntityClass):
    '''Entity ifcunitassignment definition.

	:param units
	:type units:SET(1,None,'ifcunit', scope = schema_scope)
	'''

    def __init__(self, units, ):
        self._units = units

    @property
    def units(self):
        return self._units

    @units.setter
    def units(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcunit', scope=schema_scope)):
            self._units = SET(value)
        else:
            self._units = value

    def wr01(self):
        eval_wr01_wr = ifccorrectunitassignment(self.units)
        if not eval_wr01_wr:
            raise AssertionError('Rule wr01 violated')
        else:
            return eval_wr01_wr


####################
# ENTITY ifcindexedpolycurve #
####################
class ifcindexedpolycurve(ifcboundedcurve):
    '''Entity ifcindexedpolycurve definition.

	:param points
	:type points:ifccartesianpointlist

	:param segments
	:type segments:LIST(1,None,'ifcsegmentindexselect', scope = schema_scope)

	:param selfintersect
	:type selfintersect:ifcboolean
	'''

    def __init__(self, points, segments, selfintersect, ):
        ifcboundedcurve.__init__(self, )
        self._points = points
        self._segments = segments
        self._selfintersect = selfintersect

    @property
    def points(self):
        return self._points

    @points.setter
    def points(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccartesianpointlist):
            self._points = ifccartesianpointlist(value)
        else:
            self._points = value

    @property
    def segments(self):
        return self._segments

    @segments.setter
    def segments(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcsegmentindexselect', scope=schema_scope)):
                self._segments = LIST(value)
            else:
                self._segments = value
        else:
            self._segments = value

    @property
    def selfintersect(self):
        return self._selfintersect

    @selfintersect.setter
    def selfintersect(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._selfintersect = ifcboolean(value)
            else:
                self._selfintersect = value
        else:
            self._selfintersect = value

    def consecutive(self):
        eval_consecutive_wr = ((SIZEOF(self.segments) == 0) or ifcconsecutivesegments(self.segments))
        if not eval_consecutive_wr:
            raise AssertionError('Rule consecutive violated')
        else:
            return eval_consecutive_wr


####################
# ENTITY ifcsurfacecurve #
####################
class ifcsurfacecurve(ifccurve):
    '''Entity ifcsurfacecurve definition.

	:param curve3d
	:type curve3d:ifccurve

	:param associatedgeometry
	:type associatedgeometry:LIST(1,2,'ifcpcurve', scope = schema_scope)

	:param masterrepresentation
	:type masterrepresentation:ifcpreferredsurfacecurverepresentation

	:param basissurface
	:type basissurface:SET(1,2,'ifcsurface', scope = schema_scope)
	'''

    def __init__(self, curve3d, associatedgeometry, masterrepresentation, ):
        ifccurve.__init__(self, )
        self._curve3d = curve3d
        self._associatedgeometry = associatedgeometry
        self._masterrepresentation = masterrepresentation

    @property
    def curve3d(self):
        return self._curve3d

    @curve3d.setter
    def curve3d(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._curve3d = ifccurve(value)
        else:
            self._curve3d = value

    @property
    def associatedgeometry(self):
        return self._associatedgeometry

    @associatedgeometry.setter
    def associatedgeometry(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, 2, 'ifcpcurve', scope=schema_scope)):
            self._associatedgeometry = LIST(value)
        else:
            self._associatedgeometry = value

    @property
    def masterrepresentation(self):
        return self._masterrepresentation

    @masterrepresentation.setter
    def masterrepresentation(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpreferredsurfacecurverepresentation):
            self._masterrepresentation = ifcpreferredsurfacecurverepresentation(value)
        else:
            self._masterrepresentation = value

    @property
    def basissurface(self):
        attribute_eval = ifcgetbasissurface(self)
        return attribute_eval

    @basissurface.setter
    def basissurface(self, value):
        # DERIVED argument
        raise AssertionError('Argument basissurface is DERIVED. It is computed and can not be set to any value')

    def curveis3d(self):
        eval_curveis3d_wr = (self.curve3d.self.dim == 3)
        if not eval_curveis3d_wr:
            raise AssertionError('Rule curveis3d violated')
        else:
            return eval_curveis3d_wr

    def curveisnotpcurve(self):
        eval_curveisnotpcurve_wr = (not ('IFC4X2.IFCPCURVE' == TYPEOF(self.curve3d)))
        if not eval_curveisnotpcurve_wr:
            raise AssertionError('Rule curveisnotpcurve violated')
        else:
            return eval_curveisnotpcurve_wr


####################
# ENTITY ifcalignment2dvertical #
####################
class ifcalignment2dvertical(ifcgeometricrepresentationitem):
    '''Entity ifcalignment2dvertical definition.

	:param segments
	:type segments:LIST(1,None,'ifcalignment2dverticalsegment', scope = schema_scope)

	:param toalignmentcurve
	:type toalignmentcurve:SET(1,1,'ifcalignmentcurve', scope = schema_scope)
	'''

    def __init__(self, segments, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._segments = segments

    @property
    def segments(self):
        return self._segments

    @segments.setter
    def segments(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcalignment2dverticalsegment', scope=schema_scope)):
            self._segments = LIST(value)
        else:
            self._segments = value

    @property
    def toalignmentcurve(self):
        return self._toalignmentcurve

    @toalignmentcurve.setter
    def toalignmentcurve(self, value):
        # INVERSE argument
        raise AssertionError('Argument toalignmentcurve is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcappliedvalue #
####################
class ifcappliedvalue(BaseEntityClass):
    '''Entity ifcappliedvalue definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param appliedvalue
	:type appliedvalue:ifcappliedvalueselect

	:param unitbasis
	:type unitbasis:ifcmeasurewithunit

	:param applicabledate
	:type applicabledate:ifcdate

	:param fixeduntildate
	:type fixeduntildate:ifcdate

	:param category
	:type category:ifclabel

	:param condition
	:type condition:ifclabel

	:param arithmeticoperator
	:type arithmeticoperator:ifcarithmeticoperatorenum

	:param components
	:type components:LIST(1,None,'ifcappliedvalue', scope = schema_scope)

	:param hasexternalreference
	:type hasexternalreference:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''

    def __init__(self, name, description, appliedvalue, unitbasis, applicabledate, fixeduntildate, category, condition,
                 arithmeticoperator, components, ):
        self._name = name
        self._description = description
        self._appliedvalue = appliedvalue
        self._unitbasis = unitbasis
        self._applicabledate = applicabledate
        self._fixeduntildate = fixeduntildate
        self._category = category
        self._condition = condition
        self._arithmeticoperator = arithmeticoperator
        self._components = components

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def appliedvalue(self):
        return self._appliedvalue

    @appliedvalue.setter
    def appliedvalue(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcappliedvalueselect):
                self._appliedvalue = ifcappliedvalueselect(value)
            else:
                self._appliedvalue = value
        else:
            self._appliedvalue = value

    @property
    def unitbasis(self):
        return self._unitbasis

    @unitbasis.setter
    def unitbasis(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmeasurewithunit):
                self._unitbasis = ifcmeasurewithunit(value)
            else:
                self._unitbasis = value
        else:
            self._unitbasis = value

    @property
    def applicabledate(self):
        return self._applicabledate

    @applicabledate.setter
    def applicabledate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdate):
                self._applicabledate = ifcdate(value)
            else:
                self._applicabledate = value
        else:
            self._applicabledate = value

    @property
    def fixeduntildate(self):
        return self._fixeduntildate

    @fixeduntildate.setter
    def fixeduntildate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdate):
                self._fixeduntildate = ifcdate(value)
            else:
                self._fixeduntildate = value
        else:
            self._fixeduntildate = value

    @property
    def category(self):
        return self._category

    @category.setter
    def category(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._category = ifclabel(value)
            else:
                self._category = value
        else:
            self._category = value

    @property
    def condition(self):
        return self._condition

    @condition.setter
    def condition(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._condition = ifclabel(value)
            else:
                self._condition = value
        else:
            self._condition = value

    @property
    def arithmeticoperator(self):
        return self._arithmeticoperator

    @arithmeticoperator.setter
    def arithmeticoperator(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcarithmeticoperatorenum):
                self._arithmeticoperator = ifcarithmeticoperatorenum(value)
            else:
                self._arithmeticoperator = value
        else:
            self._arithmeticoperator = value

    @property
    def components(self):
        return self._components

    @components.setter
    def components(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcappliedvalue', scope=schema_scope)):
                self._components = LIST(value)
            else:
                self._components = value
        else:
            self._components = value

    @property
    def hasexternalreference(self):
        return self._hasexternalreference

    @hasexternalreference.setter
    def hasexternalreference(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasexternalreference is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifccostvalue #
####################
class ifccostvalue(ifcappliedvalue):
    '''Entity ifccostvalue definition.
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__appliedvalue, inherited3__unitbasis,
                 inherited4__applicabledate, inherited5__fixeduntildate, inherited6__category, inherited7__condition,
                 inherited8__arithmeticoperator, inherited9__components, ):
        ifcappliedvalue.__init__(self, inherited0__name, inherited1__description, inherited2__appliedvalue,
                                 inherited3__unitbasis, inherited4__applicabledate, inherited5__fixeduntildate,
                                 inherited6__category, inherited7__condition, inherited8__arithmeticoperator,
                                 inherited9__components, )


####################
# ENTITY ifcstructuralloadconfiguration #
####################
class ifcstructuralloadconfiguration(ifcstructuralload):
    '''Entity ifcstructuralloadconfiguration definition.

	:param values
	:type values:LIST(1,None,'ifcstructuralloadorresult', scope = schema_scope)

	:param locations
	:type locations:LIST(1,None,LIST(1,2,'REAL', scope = schema_scope))
	'''

    def __init__(self, inherited0__name, values, locations, ):
        ifcstructuralload.__init__(self, inherited0__name, )
        self._values = values
        self._locations = locations

    @property
    def values(self):
        return self._values

    @values.setter
    def values(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcstructuralloadorresult', scope=schema_scope)):
            self._values = LIST(value)
        else:
            self._values = value

    @property
    def locations(self):
        return self._locations

    @locations.setter
    def locations(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, LIST(1, 2, 'REAL', scope=schema_scope))):
                self._locations = LIST(value)
            else:
                self._locations = value
        else:
            self._locations = value

    def validlistsize(self):
        eval_validlistsize_wr = ((not EXISTS(self.locations)) or (SIZEOF(self.locations) == SIZEOF(self.values)))
        if not eval_validlistsize_wr:
            raise AssertionError('Rule validlistsize violated')
        else:
            return eval_validlistsize_wr


####################
# ENTITY ifcmember #
####################
class ifcmember(ifcbuildingelement):
    '''Entity ifcmember definition.

	:param predefinedtype
	:type predefinedtype:ifcmembertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmembertypeenum):
                self._predefinedtype = ifcmembertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcmembertypeenum.userdefined)) or (
                        (self.predefinedtype == ifcmembertypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCMEMBERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcmemberstandardcase #
####################
class ifcmemberstandardcase(ifcmember):
    '''Entity ifcmemberstandardcase definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__predefinedtype, ):
        ifcmember.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                           inherited6__representation, inherited7__tag, inherited8__predefinedtype, )

    def hasmaterialprofilesetusage(self):
        eval_hasmaterialprofilesetusage_wr = (SIZEOF(None) == 1)
        if not eval_hasmaterialprofilesetusage_wr:
            raise AssertionError('Rule hasmaterialprofilesetusage violated')
        else:
            return eval_hasmaterialprofilesetusage_wr


####################
# ENTITY ifcpermeablecoveringproperties #
####################
class ifcpermeablecoveringproperties(ifcpredefinedpropertyset):
    '''Entity ifcpermeablecoveringproperties definition.

	:param operationtype
	:type operationtype:ifcpermeablecoveringoperationenum

	:param panelposition
	:type panelposition:ifcwindowpanelpositionenum

	:param framedepth
	:type framedepth:ifcpositivelengthmeasure

	:param framethickness
	:type framethickness:ifcpositivelengthmeasure

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 operationtype, panelposition, framedepth, framethickness, shapeaspectstyle, ):
        ifcpredefinedpropertyset.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, )
        self._operationtype = operationtype
        self._panelposition = panelposition
        self._framedepth = framedepth
        self._framethickness = framethickness
        self._shapeaspectstyle = shapeaspectstyle

    @property
    def operationtype(self):
        return self._operationtype

    @operationtype.setter
    def operationtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpermeablecoveringoperationenum):
            self._operationtype = ifcpermeablecoveringoperationenum(value)
        else:
            self._operationtype = value

    @property
    def panelposition(self):
        return self._panelposition

    @panelposition.setter
    def panelposition(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcwindowpanelpositionenum):
            self._panelposition = ifcwindowpanelpositionenum(value)
        else:
            self._panelposition = value

    @property
    def framedepth(self):
        return self._framedepth

    @framedepth.setter
    def framedepth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._framedepth = ifcpositivelengthmeasure(value)
            else:
                self._framedepth = value
        else:
            self._framedepth = value

    @property
    def framethickness(self):
        return self._framethickness

    @framethickness.setter
    def framethickness(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._framethickness = ifcpositivelengthmeasure(value)
            else:
                self._framethickness = value
        else:
            self._framethickness = value

    @property
    def shapeaspectstyle(self):
        return self._shapeaspectstyle

    @shapeaspectstyle.setter
    def shapeaspectstyle(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcshapeaspect):
                self._shapeaspectstyle = ifcshapeaspect(value)
            else:
                self._shapeaspectstyle = value
        else:
            self._shapeaspectstyle = value


####################
# ENTITY ifcpipefittingtype #
####################
class ifcpipefittingtype(ifcflowfittingtype):
    '''Entity ifcpipefittingtype definition.

	:param predefinedtype
	:type predefinedtype:ifcpipefittingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowfittingtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__applicableoccurrence,
                                    inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                    inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpipefittingtypeenum):
            self._predefinedtype = ifcpipefittingtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcpipefittingtypeenum.userdefined) or (
                    (self.predefinedtype == ifcpipefittingtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcfeatureelementaddition #
####################
class ifcfeatureelementaddition(ifcfeatureelement):
    '''Entity ifcfeatureelementaddition definition.

	:param projectselements
	:type projectselements:ifcrelprojectselement
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcfeatureelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, )

    @property
    def projectselements(self):
        return self._projectselements

    @projectselements.setter
    def projectselements(self, value):
        # INVERSE argument
        raise AssertionError('Argument projectselements is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcprojectionelement #
####################
class ifcprojectionelement(ifcfeatureelementaddition):
    '''Entity ifcprojectionelement definition.

	:param predefinedtype
	:type predefinedtype:ifcprojectionelementtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcfeatureelementaddition.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcprojectionelementtypeenum):
                self._predefinedtype = ifcprojectionelementtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value


####################
# ENTITY ifcarbitraryclosedprofiledef #
####################
class ifcarbitraryclosedprofiledef(ifcprofiledef):
    '''Entity ifcarbitraryclosedprofiledef definition.

	:param outercurve
	:type outercurve:ifccurve
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, outercurve, ):
        ifcprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename, )
        self._outercurve = outercurve

    @property
    def outercurve(self):
        return self._outercurve

    @outercurve.setter
    def outercurve(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._outercurve = ifccurve(value)
        else:
            self._outercurve = value

    def wr1(self):
        eval_wr1_wr = (self.outercurve.self.dim == 2)
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr

    def wr2(self):
        eval_wr2_wr = (not ('IFC4X2.IFCLINE' == TYPEOF(self.outercurve)))
        if not eval_wr2_wr:
            raise AssertionError('Rule wr2 violated')
        else:
            return eval_wr2_wr

    def wr3(self):
        eval_wr3_wr = (not ('IFC4X2.IFCOFFSETCURVE2D' == TYPEOF(self.outercurve)))
        if not eval_wr3_wr:
            raise AssertionError('Rule wr3 violated')
        else:
            return eval_wr3_wr


####################
# ENTITY ifcarbitraryprofiledefwithvoids #
####################
class ifcarbitraryprofiledefwithvoids(ifcarbitraryclosedprofiledef):
    '''Entity ifcarbitraryprofiledefwithvoids definition.

	:param innercurves
	:type innercurves:SET(1,None,'ifccurve', scope = schema_scope)
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__outercurve, innercurves, ):
        ifcarbitraryclosedprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename,
                                              inherited2__outercurve, )
        self._innercurves = innercurves

    @property
    def innercurves(self):
        return self._innercurves

    @innercurves.setter
    def innercurves(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifccurve', scope=schema_scope)):
            self._innercurves = SET(value)
        else:
            self._innercurves = value

    def wr1(self):
        eval_wr1_wr = (self.self.ifcprofiledef.self.profiletype == ifcprofiletypeenum.area)
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr

    def wr2(self):
        eval_wr2_wr = (SIZEOF(None) == 0)
        if not eval_wr2_wr:
            raise AssertionError('Rule wr2 violated')
        else:
            return eval_wr2_wr

    def wr3(self):
        eval_wr3_wr = (SIZEOF(None) == 0)
        if not eval_wr3_wr:
            raise AssertionError('Rule wr3 violated')
        else:
            return eval_wr3_wr


####################
# ENTITY ifcgeometricset #
####################
class ifcgeometricset(ifcgeometricrepresentationitem):
    '''Entity ifcgeometricset definition.

	:param elements
	:type elements:SET(1,None,'ifcgeometricsetselect', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, elements, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._elements = elements

    @property
    def elements(self):
        return self._elements

    @elements.setter
    def elements(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcgeometricsetselect', scope=schema_scope)):
            self._elements = SET(value)
        else:
            self._elements = value

    @property
    def dim(self):
        attribute_eval = self.elements[1].self.dim
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')

    def consistentdim(self):
        eval_consistentdim_wr = (SIZEOF(None) == 0)
        if not eval_consistentdim_wr:
            raise AssertionError('Rule consistentdim violated')
        else:
            return eval_consistentdim_wr


####################
# ENTITY ifcgeometriccurveset #
####################
class ifcgeometriccurveset(ifcgeometricset):
    '''Entity ifcgeometriccurveset definition.
	'''

    def __init__(self, inherited0__elements, ):
        ifcgeometricset.__init__(self, inherited0__elements, )

    def nosurfaces(self):
        eval_nosurfaces_wr = (SIZEOF(None) == 0)
        if not eval_nosurfaces_wr:
            raise AssertionError('Rule nosurfaces violated')
        else:
            return eval_nosurfaces_wr


####################
# ENTITY ifcmaterialprofilesetusage #
####################
class ifcmaterialprofilesetusage(ifcmaterialusagedefinition):
    '''Entity ifcmaterialprofilesetusage definition.

	:param forprofileset
	:type forprofileset:ifcmaterialprofileset

	:param cardinalpoint
	:type cardinalpoint:ifccardinalpointreference

	:param referenceextent
	:type referenceextent:ifcpositivelengthmeasure
	'''

    def __init__(self, forprofileset, cardinalpoint, referenceextent, ):
        ifcmaterialusagedefinition.__init__(self, )
        self._forprofileset = forprofileset
        self._cardinalpoint = cardinalpoint
        self._referenceextent = referenceextent

    @property
    def forprofileset(self):
        return self._forprofileset

    @forprofileset.setter
    def forprofileset(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmaterialprofileset):
            self._forprofileset = ifcmaterialprofileset(value)
        else:
            self._forprofileset = value

    @property
    def cardinalpoint(self):
        return self._cardinalpoint

    @cardinalpoint.setter
    def cardinalpoint(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccardinalpointreference):
                self._cardinalpoint = ifccardinalpointreference(value)
            else:
                self._cardinalpoint = value
        else:
            self._cardinalpoint = value

    @property
    def referenceextent(self):
        return self._referenceextent

    @referenceextent.setter
    def referenceextent(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._referenceextent = ifcpositivelengthmeasure(value)
            else:
                self._referenceextent = value
        else:
            self._referenceextent = value


####################
# ENTITY ifcreinforcingmesh #
####################
class ifcreinforcingmesh(ifcreinforcingelement):
    '''Entity ifcreinforcingmesh definition.

	:param meshlength
	:type meshlength:ifcpositivelengthmeasure

	:param meshwidth
	:type meshwidth:ifcpositivelengthmeasure

	:param longitudinalbarnominaldiameter
	:type longitudinalbarnominaldiameter:ifcpositivelengthmeasure

	:param transversebarnominaldiameter
	:type transversebarnominaldiameter:ifcpositivelengthmeasure

	:param longitudinalbarcrosssectionarea
	:type longitudinalbarcrosssectionarea:ifcareameasure

	:param transversebarcrosssectionarea
	:type transversebarcrosssectionarea:ifcareameasure

	:param longitudinalbarspacing
	:type longitudinalbarspacing:ifcpositivelengthmeasure

	:param transversebarspacing
	:type transversebarspacing:ifcpositivelengthmeasure

	:param predefinedtype
	:type predefinedtype:ifcreinforcingmeshtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__steelgrade, meshlength, meshwidth, longitudinalbarnominaldiameter,
                 transversebarnominaldiameter, longitudinalbarcrosssectionarea, transversebarcrosssectionarea,
                 longitudinalbarspacing, transversebarspacing, predefinedtype, ):
        ifcreinforcingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                       inherited6__representation, inherited7__tag, inherited8__steelgrade, )
        self._meshlength = meshlength
        self._meshwidth = meshwidth
        self._longitudinalbarnominaldiameter = longitudinalbarnominaldiameter
        self._transversebarnominaldiameter = transversebarnominaldiameter
        self._longitudinalbarcrosssectionarea = longitudinalbarcrosssectionarea
        self._transversebarcrosssectionarea = transversebarcrosssectionarea
        self._longitudinalbarspacing = longitudinalbarspacing
        self._transversebarspacing = transversebarspacing
        self._predefinedtype = predefinedtype

    @property
    def meshlength(self):
        return self._meshlength

    @meshlength.setter
    def meshlength(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._meshlength = ifcpositivelengthmeasure(value)
            else:
                self._meshlength = value
        else:
            self._meshlength = value

    @property
    def meshwidth(self):
        return self._meshwidth

    @meshwidth.setter
    def meshwidth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._meshwidth = ifcpositivelengthmeasure(value)
            else:
                self._meshwidth = value
        else:
            self._meshwidth = value

    @property
    def longitudinalbarnominaldiameter(self):
        return self._longitudinalbarnominaldiameter

    @longitudinalbarnominaldiameter.setter
    def longitudinalbarnominaldiameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._longitudinalbarnominaldiameter = ifcpositivelengthmeasure(value)
            else:
                self._longitudinalbarnominaldiameter = value
        else:
            self._longitudinalbarnominaldiameter = value

    @property
    def transversebarnominaldiameter(self):
        return self._transversebarnominaldiameter

    @transversebarnominaldiameter.setter
    def transversebarnominaldiameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._transversebarnominaldiameter = ifcpositivelengthmeasure(value)
            else:
                self._transversebarnominaldiameter = value
        else:
            self._transversebarnominaldiameter = value

    @property
    def longitudinalbarcrosssectionarea(self):
        return self._longitudinalbarcrosssectionarea

    @longitudinalbarcrosssectionarea.setter
    def longitudinalbarcrosssectionarea(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcareameasure):
                self._longitudinalbarcrosssectionarea = ifcareameasure(value)
            else:
                self._longitudinalbarcrosssectionarea = value
        else:
            self._longitudinalbarcrosssectionarea = value

    @property
    def transversebarcrosssectionarea(self):
        return self._transversebarcrosssectionarea

    @transversebarcrosssectionarea.setter
    def transversebarcrosssectionarea(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcareameasure):
                self._transversebarcrosssectionarea = ifcareameasure(value)
            else:
                self._transversebarcrosssectionarea = value
        else:
            self._transversebarcrosssectionarea = value

    @property
    def longitudinalbarspacing(self):
        return self._longitudinalbarspacing

    @longitudinalbarspacing.setter
    def longitudinalbarspacing(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._longitudinalbarspacing = ifcpositivelengthmeasure(value)
            else:
                self._longitudinalbarspacing = value
        else:
            self._longitudinalbarspacing = value

    @property
    def transversebarspacing(self):
        return self._transversebarspacing

    @transversebarspacing.setter
    def transversebarspacing(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._transversebarspacing = ifcpositivelengthmeasure(value)
            else:
                self._transversebarspacing = value
        else:
            self._transversebarspacing = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreinforcingmeshtypeenum):
                self._predefinedtype = ifcreinforcingmeshtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcreinforcingmeshtypeenum.userdefined)) or ((
                                                                                                    self.predefinedtype == ifcreinforcingmeshtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCREINFORCINGMESHTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcrepresentation #
####################
class ifcrepresentation(BaseEntityClass):
    '''Entity ifcrepresentation definition.

	:param contextofitems
	:type contextofitems:ifcrepresentationcontext

	:param representationidentifier
	:type representationidentifier:ifclabel

	:param representationtype
	:type representationtype:ifclabel

	:param items
	:type items:SET(1,None,'ifcrepresentationitem', scope = schema_scope)

	:param representationmap
	:type representationmap:SET(0,1,'ifcrepresentationmap', scope = schema_scope)

	:param layerassignments
	:type layerassignments:SET(0,None,'ifcpresentationlayerassignment', scope = schema_scope)

	:param ofproductrepresentation
	:type ofproductrepresentation:SET(0,None,'ifcproductrepresentation', scope = schema_scope)
	'''

    def __init__(self, contextofitems, representationidentifier, representationtype, items, ):
        self._contextofitems = contextofitems
        self._representationidentifier = representationidentifier
        self._representationtype = representationtype
        self._items = items

    @property
    def contextofitems(self):
        return self._contextofitems

    @contextofitems.setter
    def contextofitems(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcrepresentationcontext):
            self._contextofitems = ifcrepresentationcontext(value)
        else:
            self._contextofitems = value

    @property
    def representationidentifier(self):
        return self._representationidentifier

    @representationidentifier.setter
    def representationidentifier(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._representationidentifier = ifclabel(value)
            else:
                self._representationidentifier = value
        else:
            self._representationidentifier = value

    @property
    def representationtype(self):
        return self._representationtype

    @representationtype.setter
    def representationtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._representationtype = ifclabel(value)
            else:
                self._representationtype = value
        else:
            self._representationtype = value

    @property
    def items(self):
        return self._items

    @items.setter
    def items(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcrepresentationitem', scope=schema_scope)):
            self._items = SET(value)
        else:
            self._items = value

    @property
    def representationmap(self):
        return self._representationmap

    @representationmap.setter
    def representationmap(self, value):
        # INVERSE argument
        raise AssertionError('Argument representationmap is INVERSE. It is computed and can not be set to any value')

    @property
    def layerassignments(self):
        return self._layerassignments

    @layerassignments.setter
    def layerassignments(self, value):
        # INVERSE argument
        raise AssertionError('Argument layerassignments is INVERSE. It is computed and can not be set to any value')

    @property
    def ofproductrepresentation(self):
        return self._ofproductrepresentation

    @ofproductrepresentation.setter
    def ofproductrepresentation(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument ofproductrepresentation is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcstylemodel #
####################
class ifcstylemodel(ifcrepresentation):
    '''Entity ifcstylemodel definition.
	'''

    def __init__(self, inherited0__contextofitems, inherited1__representationidentifier, inherited2__representationtype,
                 inherited3__items, ):
        ifcrepresentation.__init__(self, inherited0__contextofitems, inherited1__representationidentifier,
                                   inherited2__representationtype, inherited3__items, )


####################
# ENTITY ifcheatexchanger #
####################
class ifcheatexchanger(ifcenergyconversiondevice):
    '''Entity ifcheatexchanger definition.

	:param predefinedtype
	:type predefinedtype:ifcheatexchangertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcheatexchangertypeenum):
                self._predefinedtype = ifcheatexchangertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcheatexchangertypeenum.userdefined)) or ((
                                                                                                  self.predefinedtype == ifcheatexchangertypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCHEATEXCHANGERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcdistributioncontrolelementtype #
####################
class ifcdistributioncontrolelementtype(ifcdistributionelementtype):
    '''Entity ifcdistributioncontrolelementtype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcdistributionelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__applicableoccurrence,
                                            inherited5__haspropertysets, inherited6__representationmaps,
                                            inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcsensortype #
####################
class ifcsensortype(ifcdistributioncontrolelementtype):
    '''Entity ifcsensortype definition.

	:param predefinedtype
	:type predefinedtype:ifcsensortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcdistributioncontrolelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory,
                                                   inherited2__name, inherited3__description,
                                                   inherited4__applicableoccurrence, inherited5__haspropertysets,
                                                   inherited6__representationmaps, inherited7__tag,
                                                   inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsensortypeenum):
            self._predefinedtype = ifcsensortypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcsensortypeenum.userdefined) or (
                    (self.predefinedtype == ifcsensortypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcstructuralcurveaction #
####################
class ifcstructuralcurveaction(ifcstructuralaction):
    '''Entity ifcstructuralcurveaction definition.

	:param projectedortrue
	:type projectedortrue:ifcprojectedortruelengthenum

	:param predefinedtype
	:type predefinedtype:ifcstructuralcurveactivitytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__appliedload, inherited8__globalorlocal, inherited9__destabilizingload, projectedortrue,
                 predefinedtype, ):
        ifcstructuralaction.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, inherited7__appliedload, inherited8__globalorlocal,
                                     inherited9__destabilizingload, )
        self._projectedortrue = projectedortrue
        self._predefinedtype = predefinedtype

    @property
    def projectedortrue(self):
        return self._projectedortrue

    @projectedortrue.setter
    def projectedortrue(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcprojectedortruelengthenum):
                self._projectedortrue = ifcprojectedortruelengthenum(value)
            else:
                self._projectedortrue = value
        else:
            self._projectedortrue = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstructuralcurveactivitytypeenum):
            self._predefinedtype = ifcstructuralcurveactivitytypeenum(value)
        else:
            self._predefinedtype = value

    def projectedisglobal(self):
        eval_projectedisglobal_wr = ((not EXISTS(self.projectedortrue)) or (
                    (self.projectedortrue != ifcprojectedortruelengthenum.projected_length) or (
                        self.self.ifcstructuralactivity.self.globalorlocal == ifcglobalorlocalenum.global_coords)))
        if not eval_projectedisglobal_wr:
            raise AssertionError('Rule projectedisglobal violated')
        else:
            return eval_projectedisglobal_wr

    def hasobjecttype(self):
        eval_hasobjecttype_wr = ((self.predefinedtype != ifcstructuralcurveactivitytypeenum.userdefined) or EXISTS(
            self.self.ifcobject.self.objecttype))
        if not eval_hasobjecttype_wr:
            raise AssertionError('Rule hasobjecttype violated')
        else:
            return eval_hasobjecttype_wr

    def suitablepredefinedtype(self):
        eval_suitablepredefinedtype_wr = (self.predefinedtype != ifcstructuralcurveactivitytypeenum.equidistant)
        if not eval_suitablepredefinedtype_wr:
            raise AssertionError('Rule suitablepredefinedtype violated')
        else:
            return eval_suitablepredefinedtype_wr


####################
# ENTITY ifcstructurallinearaction #
####################
class ifcstructurallinearaction(ifcstructuralcurveaction):
    '''Entity ifcstructurallinearaction definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__appliedload, inherited8__globalorlocal, inherited9__destabilizingload,
                 inherited10__projectedortrue, inherited11__predefinedtype, ):
        ifcstructuralcurveaction.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                          inherited6__representation, inherited7__appliedload,
                                          inherited8__globalorlocal, inherited9__destabilizingload,
                                          inherited10__projectedortrue, inherited11__predefinedtype, )

    def suitableloadtype(self):
        eval_suitableloadtype_wr = (SIZEOF(
            ['IFC4X2.IFCSTRUCTURALLOADLINEARFORCE', 'IFC4X2.IFCSTRUCTURALLOADTEMPERATURE'] * TYPEOF(
                self.self.ifcstructuralactivity.self.appliedload)) == 1)
        if not eval_suitableloadtype_wr:
            raise AssertionError('Rule suitableloadtype violated')
        else:
            return eval_suitableloadtype_wr

    def constpredefinedtype(self):
        eval_constpredefinedtype_wr = (
                    self.self.ifcstructuralcurveaction.self.predefinedtype == ifcstructuralcurveactivitytypeenum.const)
        if not eval_constpredefinedtype_wr:
            raise AssertionError('Rule constpredefinedtype violated')
        else:
            return eval_constpredefinedtype_wr


####################
# ENTITY ifcexternallydefinedhatchstyle #
####################
class ifcexternallydefinedhatchstyle(ifcexternalreference):
    '''Entity ifcexternallydefinedhatchstyle definition.
	'''

    def __init__(self, inherited0__location, inherited1__identification, inherited2__name, ):
        ifcexternalreference.__init__(self, inherited0__location, inherited1__identification, inherited2__name, )


####################
# ENTITY ifcflowmetertype #
####################
class ifcflowmetertype(ifcflowcontrollertype):
    '''Entity ifcflowmetertype definition.

	:param predefinedtype
	:type predefinedtype:ifcflowmetertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowcontrollertype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__applicableoccurrence,
                                       inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                       inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcflowmetertypeenum):
            self._predefinedtype = ifcflowmetertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcflowmetertypeenum.userdefined) or (
                    (self.predefinedtype == ifcflowmetertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcreldefines #
####################
class ifcreldefines(ifcrelationship):
    '''Entity ifcreldefines definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description, ):
        ifcrelationship.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, )


####################
# ENTITY ifctablecolumn #
####################
class ifctablecolumn(BaseEntityClass):
    '''Entity ifctablecolumn definition.

	:param identifier
	:type identifier:ifcidentifier

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param unit
	:type unit:ifcunit

	:param referencepath
	:type referencepath:ifcreference
	'''

    def __init__(self, identifier, name, description, unit, referencepath, ):
        self._identifier = identifier
        self._name = name
        self._description = description
        self._unit = unit
        self._referencepath = referencepath

    @property
    def identifier(self):
        return self._identifier

    @identifier.setter
    def identifier(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._identifier = ifcidentifier(value)
            else:
                self._identifier = value
        else:
            self._identifier = value

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def unit(self):
        return self._unit

    @unit.setter
    def unit(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcunit):
                self._unit = ifcunit(value)
            else:
                self._unit = value
        else:
            self._unit = value

    @property
    def referencepath(self):
        return self._referencepath

    @referencepath.setter
    def referencepath(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreference):
                self._referencepath = ifcreference(value)
            else:
                self._referencepath = value
        else:
            self._referencepath = value


####################
# ENTITY ifctexturecoordinate #
####################
class ifctexturecoordinate(ifcpresentationitem):
    '''Entity ifctexturecoordinate definition.

	:param maps
	:type maps:LIST(1,None,'ifcsurfacetexture', scope = schema_scope)
	'''

    def __init__(self, maps, ):
        ifcpresentationitem.__init__(self, )
        self._maps = maps

    @property
    def maps(self):
        return self._maps

    @maps.setter
    def maps(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcsurfacetexture', scope=schema_scope)):
            self._maps = LIST(value)
        else:
            self._maps = value


####################
# ENTITY ifctexturecoordinategenerator #
####################
class ifctexturecoordinategenerator(ifctexturecoordinate):
    '''Entity ifctexturecoordinategenerator definition.

	:param mode
	:type mode:ifclabel

	:param parameter
	:type parameter:LIST(1,None,'REAL', scope = schema_scope)
	'''

    def __init__(self, inherited0__maps, mode, parameter, ):
        ifctexturecoordinate.__init__(self, inherited0__maps, )
        self._mode = mode
        self._parameter = parameter

    @property
    def mode(self):
        return self._mode

    @mode.setter
    def mode(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._mode = ifclabel(value)
        else:
            self._mode = value

    @property
    def parameter(self):
        return self._parameter

    @parameter.setter
    def parameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'REAL', scope=schema_scope)):
                self._parameter = LIST(value)
            else:
                self._parameter = value
        else:
            self._parameter = value


####################
# ENTITY ifcbuildingelementparttype #
####################
class ifcbuildingelementparttype(ifcelementcomponenttype):
    '''Entity ifcbuildingelementparttype definition.

	:param predefinedtype
	:type predefinedtype:ifcbuildingelementparttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcelementcomponenttype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__applicableoccurrence,
                                         inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                         inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcbuildingelementparttypeenum):
            self._predefinedtype = ifcbuildingelementparttypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcbuildingelementparttypeenum.userdefined) or (
                    (self.predefinedtype == ifcbuildingelementparttypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcrelassociates #
####################
class ifcrelassociates(ifcrelationship):
    '''Entity ifcrelassociates definition.

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcdefinitionselect', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatedobjects, ):
        ifcrelationship.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, )
        self._relatedobjects = relatedobjects

    @property
    def relatedobjects(self):
        return self._relatedobjects

    @relatedobjects.setter
    def relatedobjects(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcdefinitionselect', scope=schema_scope)):
            self._relatedobjects = SET(value)
        else:
            self._relatedobjects = value


####################
# ENTITY ifcrelassociatesconstraint #
####################
class ifcrelassociatesconstraint(ifcrelassociates):
    '''Entity ifcrelassociatesconstraint definition.

	:param intent
	:type intent:ifclabel

	:param relatingconstraint
	:type relatingconstraint:ifcconstraint
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatedobjects, intent, relatingconstraint, ):
        ifcrelassociates.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                  inherited3__description, inherited4__relatedobjects, )
        self._intent = intent
        self._relatingconstraint = relatingconstraint

    @property
    def intent(self):
        return self._intent

    @intent.setter
    def intent(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._intent = ifclabel(value)
            else:
                self._intent = value
        else:
            self._intent = value

    @property
    def relatingconstraint(self):
        return self._relatingconstraint

    @relatingconstraint.setter
    def relatingconstraint(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcconstraint):
            self._relatingconstraint = ifcconstraint(value)
        else:
            self._relatingconstraint = value


####################
# ENTITY ifctubebundletype #
####################
class ifctubebundletype(ifcenergyconversiondevicetype):
    '''Entity ifctubebundletype definition.

	:param predefinedtype
	:type predefinedtype:ifctubebundletypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctubebundletypeenum):
            self._predefinedtype = ifctubebundletypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifctubebundletypeenum.userdefined) or (
                    (self.predefinedtype == ifctubebundletypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcfillareastyle #
####################
class ifcfillareastyle(ifcpresentationstyle):
    '''Entity ifcfillareastyle definition.

	:param fillstyles
	:type fillstyles:SET(1,None,'ifcfillstyleselect', scope = schema_scope)

	:param modelordraughting
	:type modelordraughting:ifcboolean
	'''

    def __init__(self, inherited0__name, fillstyles, modelordraughting, ):
        ifcpresentationstyle.__init__(self, inherited0__name, )
        self._fillstyles = fillstyles
        self._modelordraughting = modelordraughting

    @property
    def fillstyles(self):
        return self._fillstyles

    @fillstyles.setter
    def fillstyles(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcfillstyleselect', scope=schema_scope)):
            self._fillstyles = SET(value)
        else:
            self._fillstyles = value

    @property
    def modelordraughting(self):
        return self._modelordraughting

    @modelordraughting.setter
    def modelordraughting(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._modelordraughting = ifcboolean(value)
            else:
                self._modelordraughting = value
        else:
            self._modelordraughting = value

    def maxonecolour(self):
        eval_maxonecolour_wr = (SIZEOF(None) <= 1)
        if not eval_maxonecolour_wr:
            raise AssertionError('Rule maxonecolour violated')
        else:
            return eval_maxonecolour_wr

    def maxoneexthatchstyle(self):
        eval_maxoneexthatchstyle_wr = (SIZEOF(None) <= 1)
        if not eval_maxoneexthatchstyle_wr:
            raise AssertionError('Rule maxoneexthatchstyle violated')
        else:
            return eval_maxoneexthatchstyle_wr

    def consistenthatchstyledef(self):
        eval_consistenthatchstyledef_wr = ifccorrectfillareastyle(self.self.fillstyles)
        if not eval_consistenthatchstyledef_wr:
            raise AssertionError('Rule consistenthatchstyledef violated')
        else:
            return eval_consistenthatchstyledef_wr


####################
# ENTITY ifcburnertype #
####################
class ifcburnertype(ifcenergyconversiondevicetype):
    '''Entity ifcburnertype definition.

	:param predefinedtype
	:type predefinedtype:ifcburnertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcburnertypeenum):
            self._predefinedtype = ifcburnertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcburnertypeenum.userdefined) or (
                    (self.predefinedtype == ifcburnertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcevaporator #
####################
class ifcevaporator(ifcenergyconversiondevice):
    '''Entity ifcevaporator definition.

	:param predefinedtype
	:type predefinedtype:ifcevaporatortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcevaporatortypeenum):
                self._predefinedtype = ifcevaporatortypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcevaporatortypeenum.userdefined)) or ((
                                                                                               self.predefinedtype == ifcevaporatortypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCEVAPORATORTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcstructuralmember #
####################
class ifcstructuralmember(ifcstructuralitem):
    '''Entity ifcstructuralmember definition.

	:param connectedby
	:type connectedby:SET(0,None,'ifcrelconnectsstructuralmember', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, ):
        ifcstructuralitem.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, )

    @property
    def connectedby(self):
        return self._connectedby

    @connectedby.setter
    def connectedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument connectedby is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcstructuralsurfacemember #
####################
class ifcstructuralsurfacemember(ifcstructuralmember):
    '''Entity ifcstructuralsurfacemember definition.

	:param predefinedtype
	:type predefinedtype:ifcstructuralsurfacemembertypeenum

	:param thickness
	:type thickness:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, predefinedtype,
                 thickness, ):
        ifcstructuralmember.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, )
        self._predefinedtype = predefinedtype
        self._thickness = thickness

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstructuralsurfacemembertypeenum):
            self._predefinedtype = ifcstructuralsurfacemembertypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def thickness(self):
        return self._thickness

    @thickness.setter
    def thickness(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._thickness = ifcpositivelengthmeasure(value)
            else:
                self._thickness = value
        else:
            self._thickness = value

    def hasobjecttype(self):
        eval_hasobjecttype_wr = ((self.predefinedtype != ifcstructuralsurfacemembertypeenum.userdefined) or EXISTS(
            self.self.ifcobject.self.objecttype))
        if not eval_hasobjecttype_wr:
            raise AssertionError('Rule hasobjecttype violated')
        else:
            return eval_hasobjecttype_wr


####################
# ENTITY ifctendonanchor #
####################
class ifctendonanchor(ifcreinforcingelement):
    '''Entity ifctendonanchor definition.

	:param predefinedtype
	:type predefinedtype:ifctendonanchortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__steelgrade, predefinedtype, ):
        ifcreinforcingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                       inherited6__representation, inherited7__tag, inherited8__steelgrade, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctendonanchortypeenum):
                self._predefinedtype = ifctendonanchortypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifctendonanchortypeenum.userdefined)) or ((
                                                                                                 self.predefinedtype == ifctendonanchortypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCTENDONANCHORTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcalignment2dverticalsegment #
####################
class ifcalignment2dverticalsegment(ifcalignment2dsegment):
    '''Entity ifcalignment2dverticalsegment definition.

	:param startdistalong
	:type startdistalong:ifclengthmeasure

	:param horizontallength
	:type horizontallength:ifcpositivelengthmeasure

	:param startheight
	:type startheight:ifclengthmeasure

	:param startgradient
	:type startgradient:ifcratiomeasure

	:param tovertical
	:type tovertical:SET(1,1,'ifcalignment2dvertical', scope = schema_scope)
	'''

    def __init__(self, inherited0__tangentialcontinuity, inherited1__starttag, inherited2__endtag, startdistalong,
                 horizontallength, startheight, startgradient, ):
        ifcalignment2dsegment.__init__(self, inherited0__tangentialcontinuity, inherited1__starttag,
                                       inherited2__endtag, )
        self._startdistalong = startdistalong
        self._horizontallength = horizontallength
        self._startheight = startheight
        self._startgradient = startgradient

    @property
    def startdistalong(self):
        return self._startdistalong

    @startdistalong.setter
    def startdistalong(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._startdistalong = ifclengthmeasure(value)
        else:
            self._startdistalong = value

    @property
    def horizontallength(self):
        return self._horizontallength

    @horizontallength.setter
    def horizontallength(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._horizontallength = ifcpositivelengthmeasure(value)
        else:
            self._horizontallength = value

    @property
    def startheight(self):
        return self._startheight

    @startheight.setter
    def startheight(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._startheight = ifclengthmeasure(value)
        else:
            self._startheight = value

    @property
    def startgradient(self):
        return self._startgradient

    @startgradient.setter
    def startgradient(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcratiomeasure):
            self._startgradient = ifcratiomeasure(value)
        else:
            self._startgradient = value

    @property
    def tovertical(self):
        return self._tovertical

    @tovertical.setter
    def tovertical(self, value):
        # INVERSE argument
        raise AssertionError('Argument tovertical is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcalignment2dversegline #
####################
class ifcalignment2dversegline(ifcalignment2dverticalsegment):
    '''Entity ifcalignment2dversegline definition.
	'''

    def __init__(self, inherited0__tangentialcontinuity, inherited1__starttag, inherited2__endtag,
                 inherited3__startdistalong, inherited4__horizontallength, inherited5__startheight,
                 inherited6__startgradient, ):
        ifcalignment2dverticalsegment.__init__(self, inherited0__tangentialcontinuity, inherited1__starttag,
                                               inherited2__endtag, inherited3__startdistalong,
                                               inherited4__horizontallength, inherited5__startheight,
                                               inherited6__startgradient, )


####################
# ENTITY ifcexternalspatialelement #
####################
class ifcexternalspatialelement(ifcexternalspatialstructureelement):
    '''Entity ifcexternalspatialelement definition.

	:param predefinedtype
	:type predefinedtype:ifcexternalspatialelementtypeenum

	:param boundedby
	:type boundedby:SET(0,None,'ifcrelspaceboundary', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__longname,
                 predefinedtype, ):
        ifcexternalspatialstructureelement.__init__(self, inherited0__globalid, inherited1__ownerhistory,
                                                    inherited2__name, inherited3__description, inherited4__objecttype,
                                                    inherited5__objectplacement, inherited6__representation,
                                                    inherited7__longname, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcexternalspatialelementtypeenum):
                self._predefinedtype = ifcexternalspatialelementtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def boundedby(self):
        return self._boundedby

    @boundedby.setter
    def boundedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument boundedby is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifccompositecurve #
####################
class ifccompositecurve(ifcboundedcurve):
    '''Entity ifccompositecurve definition.

	:param segments
	:type segments:LIST(1,None,'ifccompositecurvesegment', scope = schema_scope)

	:param selfintersect
	:type selfintersect:ifclogical

	:param nsegments
	:type nsegments:ifcinteger

	:param closedcurve
	:type closedcurve:ifclogical
	'''

    def __init__(self, segments, selfintersect, ):
        ifcboundedcurve.__init__(self, )
        self._segments = segments
        self._selfintersect = selfintersect

    @property
    def segments(self):
        return self._segments

    @segments.setter
    def segments(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifccompositecurvesegment', scope=schema_scope)):
            self._segments = LIST(value)
        else:
            self._segments = value

    @property
    def selfintersect(self):
        return self._selfintersect

    @selfintersect.setter
    def selfintersect(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclogical):
            self._selfintersect = ifclogical(value)
        else:
            self._selfintersect = value

    @property
    def nsegments(self):
        attribute_eval = SIZEOF(self.segments)
        return attribute_eval

    @nsegments.setter
    def nsegments(self, value):
        # DERIVED argument
        raise AssertionError('Argument nsegments is DERIVED. It is computed and can not be set to any value')

    @property
    def closedcurve(self):
        attribute_eval = (self.segments[self.nsegments].self.transition != ifctransitioncode.discontinuous)
        return attribute_eval

    @closedcurve.setter
    def closedcurve(self, value):
        # DERIVED argument
        raise AssertionError('Argument closedcurve is DERIVED. It is computed and can not be set to any value')

    def curvecontinuous(self):
        eval_curvecontinuous_wr = (
                    ((not self.closedcurve) and (SIZEOF(None) == 1)) or (self.closedcurve and (SIZEOF(None) == 0)))
        if not eval_curvecontinuous_wr:
            raise AssertionError('Rule curvecontinuous violated')
        else:
            return eval_curvecontinuous_wr

    def samedim(self):
        eval_samedim_wr = (SIZEOF(None) == 0)
        if not eval_samedim_wr:
            raise AssertionError('Rule samedim violated')
        else:
            return eval_samedim_wr


####################
# ENTITY ifccompositecurveonsurface #
####################
class ifccompositecurveonsurface(ifccompositecurve):
    '''Entity ifccompositecurveonsurface definition.

	:param basissurface
	:type basissurface:SET(0,1,'ifcsurface', scope = schema_scope)
	'''

    def __init__(self, inherited0__segments, inherited1__selfintersect, ):
        ifccompositecurve.__init__(self, inherited0__segments, inherited1__selfintersect, )

    @property
    def basissurface(self):
        attribute_eval = ifcgetbasissurface(self)
        return attribute_eval

    @basissurface.setter
    def basissurface(self, value):
        # DERIVED argument
        raise AssertionError('Argument basissurface is DERIVED. It is computed and can not be set to any value')

    def samesurface(self):
        eval_samesurface_wr = (SIZEOF(self.basissurface) > 0)
        if not eval_samesurface_wr:
            raise AssertionError('Rule samesurface violated')
        else:
            return eval_samesurface_wr


####################
# ENTITY ifcboundarycurve #
####################
class ifcboundarycurve(ifccompositecurveonsurface):
    '''Entity ifcboundarycurve definition.
	'''

    def __init__(self, inherited0__segments, inherited1__selfintersect, ):
        ifccompositecurveonsurface.__init__(self, inherited0__segments, inherited1__selfintersect, )

    def isclosed(self):
        eval_isclosed_wr = self.self.ifccompositecurve.self.closedcurve
        if not eval_isclosed_wr:
            raise AssertionError('Rule isclosed violated')
        else:
            return eval_isclosed_wr


####################
# ENTITY ifcouterboundarycurve #
####################
class ifcouterboundarycurve(ifcboundarycurve):
    '''Entity ifcouterboundarycurve definition.
	'''

    def __init__(self, inherited0__segments, inherited1__selfintersect, ):
        ifcboundarycurve.__init__(self, inherited0__segments, inherited1__selfintersect, )


####################
# ENTITY ifcwindowliningproperties #
####################
class ifcwindowliningproperties(ifcpredefinedpropertyset):
    '''Entity ifcwindowliningproperties definition.

	:param liningdepth
	:type liningdepth:ifcpositivelengthmeasure

	:param liningthickness
	:type liningthickness:ifcnonnegativelengthmeasure

	:param transomthickness
	:type transomthickness:ifcnonnegativelengthmeasure

	:param mullionthickness
	:type mullionthickness:ifcnonnegativelengthmeasure

	:param firsttransomoffset
	:type firsttransomoffset:ifcnormalisedratiomeasure

	:param secondtransomoffset
	:type secondtransomoffset:ifcnormalisedratiomeasure

	:param firstmullionoffset
	:type firstmullionoffset:ifcnormalisedratiomeasure

	:param secondmullionoffset
	:type secondmullionoffset:ifcnormalisedratiomeasure

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect

	:param liningoffset
	:type liningoffset:ifclengthmeasure

	:param liningtopaneloffsetx
	:type liningtopaneloffsetx:ifclengthmeasure

	:param liningtopaneloffsety
	:type liningtopaneloffsety:ifclengthmeasure
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 liningdepth, liningthickness, transomthickness, mullionthickness, firsttransomoffset,
                 secondtransomoffset, firstmullionoffset, secondmullionoffset, shapeaspectstyle, liningoffset,
                 liningtopaneloffsetx, liningtopaneloffsety, ):
        ifcpredefinedpropertyset.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, )
        self._liningdepth = liningdepth
        self._liningthickness = liningthickness
        self._transomthickness = transomthickness
        self._mullionthickness = mullionthickness
        self._firsttransomoffset = firsttransomoffset
        self._secondtransomoffset = secondtransomoffset
        self._firstmullionoffset = firstmullionoffset
        self._secondmullionoffset = secondmullionoffset
        self._shapeaspectstyle = shapeaspectstyle
        self._liningoffset = liningoffset
        self._liningtopaneloffsetx = liningtopaneloffsetx
        self._liningtopaneloffsety = liningtopaneloffsety

    @property
    def liningdepth(self):
        return self._liningdepth

    @liningdepth.setter
    def liningdepth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._liningdepth = ifcpositivelengthmeasure(value)
            else:
                self._liningdepth = value
        else:
            self._liningdepth = value

    @property
    def liningthickness(self):
        return self._liningthickness

    @liningthickness.setter
    def liningthickness(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._liningthickness = ifcnonnegativelengthmeasure(value)
            else:
                self._liningthickness = value
        else:
            self._liningthickness = value

    @property
    def transomthickness(self):
        return self._transomthickness

    @transomthickness.setter
    def transomthickness(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._transomthickness = ifcnonnegativelengthmeasure(value)
            else:
                self._transomthickness = value
        else:
            self._transomthickness = value

    @property
    def mullionthickness(self):
        return self._mullionthickness

    @mullionthickness.setter
    def mullionthickness(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._mullionthickness = ifcnonnegativelengthmeasure(value)
            else:
                self._mullionthickness = value
        else:
            self._mullionthickness = value

    @property
    def firsttransomoffset(self):
        return self._firsttransomoffset

    @firsttransomoffset.setter
    def firsttransomoffset(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnormalisedratiomeasure):
                self._firsttransomoffset = ifcnormalisedratiomeasure(value)
            else:
                self._firsttransomoffset = value
        else:
            self._firsttransomoffset = value

    @property
    def secondtransomoffset(self):
        return self._secondtransomoffset

    @secondtransomoffset.setter
    def secondtransomoffset(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnormalisedratiomeasure):
                self._secondtransomoffset = ifcnormalisedratiomeasure(value)
            else:
                self._secondtransomoffset = value
        else:
            self._secondtransomoffset = value

    @property
    def firstmullionoffset(self):
        return self._firstmullionoffset

    @firstmullionoffset.setter
    def firstmullionoffset(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnormalisedratiomeasure):
                self._firstmullionoffset = ifcnormalisedratiomeasure(value)
            else:
                self._firstmullionoffset = value
        else:
            self._firstmullionoffset = value

    @property
    def secondmullionoffset(self):
        return self._secondmullionoffset

    @secondmullionoffset.setter
    def secondmullionoffset(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnormalisedratiomeasure):
                self._secondmullionoffset = ifcnormalisedratiomeasure(value)
            else:
                self._secondmullionoffset = value
        else:
            self._secondmullionoffset = value

    @property
    def shapeaspectstyle(self):
        return self._shapeaspectstyle

    @shapeaspectstyle.setter
    def shapeaspectstyle(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcshapeaspect):
                self._shapeaspectstyle = ifcshapeaspect(value)
            else:
                self._shapeaspectstyle = value
        else:
            self._shapeaspectstyle = value

    @property
    def liningoffset(self):
        return self._liningoffset

    @liningoffset.setter
    def liningoffset(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._liningoffset = ifclengthmeasure(value)
            else:
                self._liningoffset = value
        else:
            self._liningoffset = value

    @property
    def liningtopaneloffsetx(self):
        return self._liningtopaneloffsetx

    @liningtopaneloffsetx.setter
    def liningtopaneloffsetx(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._liningtopaneloffsetx = ifclengthmeasure(value)
            else:
                self._liningtopaneloffsetx = value
        else:
            self._liningtopaneloffsetx = value

    @property
    def liningtopaneloffsety(self):
        return self._liningtopaneloffsety

    @liningtopaneloffsety.setter
    def liningtopaneloffsety(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._liningtopaneloffsety = ifclengthmeasure(value)
            else:
                self._liningtopaneloffsety = value
        else:
            self._liningtopaneloffsety = value

    def wr31(self):
        eval_wr31_wr = (not (EXISTS(self.liningdepth) and (not EXISTS(self.liningthickness))))
        if not eval_wr31_wr:
            raise AssertionError('Rule wr31 violated')
        else:
            return eval_wr31_wr

    def wr32(self):
        eval_wr32_wr = (not ((not EXISTS(self.firsttransomoffset)) and EXISTS(self.secondtransomoffset)))
        if not eval_wr32_wr:
            raise AssertionError('Rule wr32 violated')
        else:
            return eval_wr32_wr

    def wr33(self):
        eval_wr33_wr = (not ((not EXISTS(self.firstmullionoffset)) and EXISTS(self.secondmullionoffset)))
        if not eval_wr33_wr:
            raise AssertionError('Rule wr33 violated')
        else:
            return eval_wr33_wr

    def wr34(self):
        eval_wr34_wr = (EXISTS(self.self.ifcpropertysetdefinition.self.definestype[1]) and (
                    ('IFC4X2.IFCWINDOWTYPE' == TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1])) or (
                        'IFC4X2.IFCWINDOWSTYLE' == TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1]))))
        if not eval_wr34_wr:
            raise AssertionError('Rule wr34 violated')
        else:
            return eval_wr34_wr


####################
# ENTITY ifcexternalinformation #
####################
class ifcexternalinformation(BaseEntityClass):
    '''Entity ifcexternalinformation definition.
	'''
    # This class does not define any attribute.
    pass


####################
# ENTITY ifcfurnishingelement #
####################
class ifcfurnishingelement(ifcelement):
    '''Entity ifcfurnishingelement definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, inherited7__tag, )


####################
# ENTITY ifcgeographicelementtype #
####################
class ifcgeographicelementtype(ifcelementtype):
    '''Entity ifcgeographicelementtype definition.

	:param predefinedtype
	:type predefinedtype:ifcgeographicelementtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__representationmaps, inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcgeographicelementtypeenum):
            self._predefinedtype = ifcgeographicelementtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcgeographicelementtypeenum.userdefined) or (
                    (self.predefinedtype == ifcgeographicelementtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifctimeperiod #
####################
class ifctimeperiod(BaseEntityClass):
    '''Entity ifctimeperiod definition.

	:param starttime
	:type starttime:ifctime

	:param endtime
	:type endtime:ifctime
	'''

    def __init__(self, starttime, endtime, ):
        self._starttime = starttime
        self._endtime = endtime

    @property
    def starttime(self):
        return self._starttime

    @starttime.setter
    def starttime(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctime):
            self._starttime = ifctime(value)
        else:
            self._starttime = value

    @property
    def endtime(self):
        return self._endtime

    @endtime.setter
    def endtime(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctime):
            self._endtime = ifctime(value)
        else:
            self._endtime = value


####################
# ENTITY ifcdoorstyle #
####################
class ifcdoorstyle(ifctypeproduct):
    '''Entity ifcdoorstyle definition.

	:param operationtype
	:type operationtype:ifcdoorstyleoperationenum

	:param constructiontype
	:type constructiontype:ifcdoorstyleconstructionenum

	:param parametertakesprecedence
	:type parametertakesprecedence:ifcboolean

	:param sizeable
	:type sizeable:ifcboolean
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, operationtype, constructiontype, parametertakesprecedence, sizeable, ):
        ifctypeproduct.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__representationmaps, inherited7__tag, )
        self._operationtype = operationtype
        self._constructiontype = constructiontype
        self._parametertakesprecedence = parametertakesprecedence
        self._sizeable = sizeable

    @property
    def operationtype(self):
        return self._operationtype

    @operationtype.setter
    def operationtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdoorstyleoperationenum):
            self._operationtype = ifcdoorstyleoperationenum(value)
        else:
            self._operationtype = value

    @property
    def constructiontype(self):
        return self._constructiontype

    @constructiontype.setter
    def constructiontype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdoorstyleconstructionenum):
            self._constructiontype = ifcdoorstyleconstructionenum(value)
        else:
            self._constructiontype = value

    @property
    def parametertakesprecedence(self):
        return self._parametertakesprecedence

    @parametertakesprecedence.setter
    def parametertakesprecedence(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._parametertakesprecedence = ifcboolean(value)
        else:
            self._parametertakesprecedence = value

    @property
    def sizeable(self):
        return self._sizeable

    @sizeable.setter
    def sizeable(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._sizeable = ifcboolean(value)
        else:
            self._sizeable = value


####################
# ENTITY ifccompositecurvesegment #
####################
class ifccompositecurvesegment(ifcgeometricrepresentationitem):
    '''Entity ifccompositecurvesegment definition.

	:param transition
	:type transition:ifctransitioncode

	:param samesense
	:type samesense:ifcboolean

	:param parentcurve
	:type parentcurve:ifccurve

	:param dim
	:type dim:ifcdimensioncount

	:param usingcurves
	:type usingcurves:SET(1,None,'ifccompositecurve', scope = schema_scope)
	'''

    def __init__(self, transition, samesense, parentcurve, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._transition = transition
        self._samesense = samesense
        self._parentcurve = parentcurve

    @property
    def transition(self):
        return self._transition

    @transition.setter
    def transition(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctransitioncode):
            self._transition = ifctransitioncode(value)
        else:
            self._transition = value

    @property
    def samesense(self):
        return self._samesense

    @samesense.setter
    def samesense(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._samesense = ifcboolean(value)
        else:
            self._samesense = value

    @property
    def parentcurve(self):
        return self._parentcurve

    @parentcurve.setter
    def parentcurve(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._parentcurve = ifccurve(value)
        else:
            self._parentcurve = value

    @property
    def dim(self):
        attribute_eval = self.parentcurve.self.dim
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')

    @property
    def usingcurves(self):
        return self._usingcurves

    @usingcurves.setter
    def usingcurves(self, value):
        # INVERSE argument
        raise AssertionError('Argument usingcurves is INVERSE. It is computed and can not be set to any value')

    def parentisboundedcurve(self):
        eval_parentisboundedcurve_wr = ('IFC4X2.IFCBOUNDEDCURVE' == TYPEOF(self.parentcurve))
        if not eval_parentisboundedcurve_wr:
            raise AssertionError('Rule parentisboundedcurve violated')
        else:
            return eval_parentisboundedcurve_wr


####################
# ENTITY ifcpropertyboundedvalue #
####################
class ifcpropertyboundedvalue(ifcsimpleproperty):
    '''Entity ifcpropertyboundedvalue definition.

	:param upperboundvalue
	:type upperboundvalue:ifcvalue

	:param lowerboundvalue
	:type lowerboundvalue:ifcvalue

	:param unit
	:type unit:ifcunit

	:param setpointvalue
	:type setpointvalue:ifcvalue
	'''

    def __init__(self, inherited0__name, inherited1__description, upperboundvalue, lowerboundvalue, unit,
                 setpointvalue, ):
        ifcsimpleproperty.__init__(self, inherited0__name, inherited1__description, )
        self._upperboundvalue = upperboundvalue
        self._lowerboundvalue = lowerboundvalue
        self._unit = unit
        self._setpointvalue = setpointvalue

    @property
    def upperboundvalue(self):
        return self._upperboundvalue

    @upperboundvalue.setter
    def upperboundvalue(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcvalue):
                self._upperboundvalue = ifcvalue(value)
            else:
                self._upperboundvalue = value
        else:
            self._upperboundvalue = value

    @property
    def lowerboundvalue(self):
        return self._lowerboundvalue

    @lowerboundvalue.setter
    def lowerboundvalue(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcvalue):
                self._lowerboundvalue = ifcvalue(value)
            else:
                self._lowerboundvalue = value
        else:
            self._lowerboundvalue = value

    @property
    def unit(self):
        return self._unit

    @unit.setter
    def unit(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcunit):
                self._unit = ifcunit(value)
            else:
                self._unit = value
        else:
            self._unit = value

    @property
    def setpointvalue(self):
        return self._setpointvalue

    @setpointvalue.setter
    def setpointvalue(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcvalue):
                self._setpointvalue = ifcvalue(value)
            else:
                self._setpointvalue = value
        else:
            self._setpointvalue = value

    def sameunitupperlower(self):
        eval_sameunitupperlower_wr = (((not EXISTS(self.upperboundvalue)) or (not EXISTS(self.lowerboundvalue))) or (
                    TYPEOF(self.upperboundvalue) == TYPEOF(self.lowerboundvalue)))
        if not eval_sameunitupperlower_wr:
            raise AssertionError('Rule sameunitupperlower violated')
        else:
            return eval_sameunitupperlower_wr

    def sameunitupperset(self):
        eval_sameunitupperset_wr = (((not EXISTS(self.upperboundvalue)) or (not EXISTS(self.setpointvalue))) or (
                    TYPEOF(self.upperboundvalue) == TYPEOF(self.setpointvalue)))
        if not eval_sameunitupperset_wr:
            raise AssertionError('Rule sameunitupperset violated')
        else:
            return eval_sameunitupperset_wr

    def sameunitlowerset(self):
        eval_sameunitlowerset_wr = (((not EXISTS(self.lowerboundvalue)) or (not EXISTS(self.setpointvalue))) or (
                    TYPEOF(self.lowerboundvalue) == TYPEOF(self.setpointvalue)))
        if not eval_sameunitlowerset_wr:
            raise AssertionError('Rule sameunitlowerset violated')
        else:
            return eval_sameunitlowerset_wr


####################
# ENTITY ifcflowmovingdevicetype #
####################
class ifcflowmovingdevicetype(ifcdistributionflowelementtype):
    '''Entity ifcflowmovingdevicetype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcdistributionflowelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                                inherited3__description, inherited4__applicableoccurrence,
                                                inherited5__haspropertysets, inherited6__representationmaps,
                                                inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcpumptype #
####################
class ifcpumptype(ifcflowmovingdevicetype):
    '''Entity ifcpumptype definition.

	:param predefinedtype
	:type predefinedtype:ifcpumptypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowmovingdevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__applicableoccurrence,
                                         inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                         inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpumptypeenum):
            self._predefinedtype = ifcpumptypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcpumptypeenum.userdefined) or (
                    (self.predefinedtype == ifcpumptypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcslab #
####################
class ifcslab(ifcbuildingelement):
    '''Entity ifcslab definition.

	:param predefinedtype
	:type predefinedtype:ifcslabtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcslabtypeenum):
                self._predefinedtype = ifcslabtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcslabtypeenum.userdefined)) or (
                        (self.predefinedtype == ifcslabtypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCSLABTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcslabelementedcase #
####################
class ifcslabelementedcase(ifcslab):
    '''Entity ifcslabelementedcase definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__predefinedtype, ):
        ifcslab.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                         inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                         inherited6__representation, inherited7__tag, inherited8__predefinedtype, )

    def hasdecomposition(self):
        eval_hasdecomposition_wr = (HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby) > 0)
        if not eval_hasdecomposition_wr:
            raise AssertionError('Rule hasdecomposition violated')
        else:
            return eval_hasdecomposition_wr


####################
# ENTITY ifcsurfacestylerendering #
####################
class ifcsurfacestylerendering(ifcsurfacestyleshading):
    '''Entity ifcsurfacestylerendering definition.

	:param diffusecolour
	:type diffusecolour:ifccolourorfactor

	:param transmissioncolour
	:type transmissioncolour:ifccolourorfactor

	:param diffusetransmissioncolour
	:type diffusetransmissioncolour:ifccolourorfactor

	:param reflectioncolour
	:type reflectioncolour:ifccolourorfactor

	:param specularcolour
	:type specularcolour:ifccolourorfactor

	:param specularhighlight
	:type specularhighlight:ifcspecularhighlightselect

	:param reflectancemethod
	:type reflectancemethod:ifcreflectancemethodenum
	'''

    def __init__(self, inherited0__surfacecolour, inherited1__transparency, diffusecolour, transmissioncolour,
                 diffusetransmissioncolour, reflectioncolour, specularcolour, specularhighlight, reflectancemethod, ):
        ifcsurfacestyleshading.__init__(self, inherited0__surfacecolour, inherited1__transparency, )
        self._diffusecolour = diffusecolour
        self._transmissioncolour = transmissioncolour
        self._diffusetransmissioncolour = diffusetransmissioncolour
        self._reflectioncolour = reflectioncolour
        self._specularcolour = specularcolour
        self._specularhighlight = specularhighlight
        self._reflectancemethod = reflectancemethod

    @property
    def diffusecolour(self):
        return self._diffusecolour

    @diffusecolour.setter
    def diffusecolour(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccolourorfactor):
                self._diffusecolour = ifccolourorfactor(value)
            else:
                self._diffusecolour = value
        else:
            self._diffusecolour = value

    @property
    def transmissioncolour(self):
        return self._transmissioncolour

    @transmissioncolour.setter
    def transmissioncolour(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccolourorfactor):
                self._transmissioncolour = ifccolourorfactor(value)
            else:
                self._transmissioncolour = value
        else:
            self._transmissioncolour = value

    @property
    def diffusetransmissioncolour(self):
        return self._diffusetransmissioncolour

    @diffusetransmissioncolour.setter
    def diffusetransmissioncolour(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccolourorfactor):
                self._diffusetransmissioncolour = ifccolourorfactor(value)
            else:
                self._diffusetransmissioncolour = value
        else:
            self._diffusetransmissioncolour = value

    @property
    def reflectioncolour(self):
        return self._reflectioncolour

    @reflectioncolour.setter
    def reflectioncolour(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccolourorfactor):
                self._reflectioncolour = ifccolourorfactor(value)
            else:
                self._reflectioncolour = value
        else:
            self._reflectioncolour = value

    @property
    def specularcolour(self):
        return self._specularcolour

    @specularcolour.setter
    def specularcolour(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccolourorfactor):
                self._specularcolour = ifccolourorfactor(value)
            else:
                self._specularcolour = value
        else:
            self._specularcolour = value

    @property
    def specularhighlight(self):
        return self._specularhighlight

    @specularhighlight.setter
    def specularhighlight(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcspecularhighlightselect):
                self._specularhighlight = ifcspecularhighlightselect(value)
            else:
                self._specularhighlight = value
        else:
            self._specularhighlight = value

    @property
    def reflectancemethod(self):
        return self._reflectancemethod

    @reflectancemethod.setter
    def reflectancemethod(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcreflectancemethodenum):
            self._reflectancemethod = ifcreflectancemethodenum(value)
        else:
            self._reflectancemethod = value


####################
# ENTITY ifctexturevertex #
####################
class ifctexturevertex(ifcpresentationitem):
    '''Entity ifctexturevertex definition.

	:param coordinates
	:type coordinates:LIST(2,2,'REAL', scope = schema_scope)
	'''

    def __init__(self, coordinates, ):
        ifcpresentationitem.__init__(self, )
        self._coordinates = coordinates

    @property
    def coordinates(self):
        return self._coordinates

    @coordinates.setter
    def coordinates(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, 2, 'REAL', scope=schema_scope)):
            self._coordinates = LIST(value)
        else:
            self._coordinates = value


####################
# ENTITY ifcbuilding #
####################
class ifcbuilding(ifcfacility):
    '''Entity ifcbuilding definition.

	:param elevationofrefheight
	:type elevationofrefheight:ifclengthmeasure

	:param elevationofterrain
	:type elevationofterrain:ifclengthmeasure

	:param buildingaddress
	:type buildingaddress:ifcpostaladdress
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__longname,
                 inherited8__compositiontype, elevationofrefheight, elevationofterrain, buildingaddress, ):
        ifcfacility.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                             inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                             inherited6__representation, inherited7__longname, inherited8__compositiontype, )
        self._elevationofrefheight = elevationofrefheight
        self._elevationofterrain = elevationofterrain
        self._buildingaddress = buildingaddress

    @property
    def elevationofrefheight(self):
        return self._elevationofrefheight

    @elevationofrefheight.setter
    def elevationofrefheight(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._elevationofrefheight = ifclengthmeasure(value)
            else:
                self._elevationofrefheight = value
        else:
            self._elevationofrefheight = value

    @property
    def elevationofterrain(self):
        return self._elevationofterrain

    @elevationofterrain.setter
    def elevationofterrain(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._elevationofterrain = ifclengthmeasure(value)
            else:
                self._elevationofterrain = value
        else:
            self._elevationofterrain = value

    @property
    def buildingaddress(self):
        return self._buildingaddress

    @buildingaddress.setter
    def buildingaddress(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpostaladdress):
                self._buildingaddress = ifcpostaladdress(value)
            else:
                self._buildingaddress = value
        else:
            self._buildingaddress = value


####################
# ENTITY ifcquantityweight #
####################
class ifcquantityweight(ifcphysicalsimplequantity):
    '''Entity ifcquantityweight definition.

	:param weightvalue
	:type weightvalue:ifcmassmeasure

	:param formula
	:type formula:ifclabel
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__unit, weightvalue, formula, ):
        ifcphysicalsimplequantity.__init__(self, inherited0__name, inherited1__description, inherited2__unit, )
        self._weightvalue = weightvalue
        self._formula = formula

    @property
    def weightvalue(self):
        return self._weightvalue

    @weightvalue.setter
    def weightvalue(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmassmeasure):
            self._weightvalue = ifcmassmeasure(value)
        else:
            self._weightvalue = value

    @property
    def formula(self):
        return self._formula

    @formula.setter
    def formula(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._formula = ifclabel(value)
            else:
                self._formula = value
        else:
            self._formula = value

    def wr21(self):
        eval_wr21_wr = ((not EXISTS(self.self.ifcphysicalsimplequantity.self.unit)) or (
                    self.self.ifcphysicalsimplequantity.self.unit.self.unittype == ifcunitenum.massunit))
        if not eval_wr21_wr:
            raise AssertionError('Rule wr21 violated')
        else:
            return eval_wr21_wr

    def wr22(self):
        eval_wr22_wr = (self.weightvalue >= 0)
        if not eval_wr22_wr:
            raise AssertionError('Rule wr22 violated')
        else:
            return eval_wr22_wr


####################
# ENTITY ifcrelassociatesclassification #
####################
class ifcrelassociatesclassification(ifcrelassociates):
    '''Entity ifcrelassociatesclassification definition.

	:param relatingclassification
	:type relatingclassification:ifcclassificationselect
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatedobjects, relatingclassification, ):
        ifcrelassociates.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                  inherited3__description, inherited4__relatedobjects, )
        self._relatingclassification = relatingclassification

    @property
    def relatingclassification(self):
        return self._relatingclassification

    @relatingclassification.setter
    def relatingclassification(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcclassificationselect):
            self._relatingclassification = ifcclassificationselect(value)
        else:
            self._relatingclassification = value


####################
# ENTITY ifcsystemfurnitureelement #
####################
class ifcsystemfurnitureelement(ifcfurnishingelement):
    '''Entity ifcsystemfurnitureelement definition.

	:param predefinedtype
	:type predefinedtype:ifcsystemfurnitureelementtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcfurnishingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                      inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                      inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsystemfurnitureelementtypeenum):
                self._predefinedtype = ifcsystemfurnitureelementtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcsystemfurnitureelementtypeenum.userdefined)) or ((
                                                                                                           self.predefinedtype == ifcsystemfurnitureelementtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCSYSTEMFURNITUREELEMENTTYPE' == TYPEOF(
                self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcairterminalboxtype #
####################
class ifcairterminalboxtype(ifcflowcontrollertype):
    '''Entity ifcairterminalboxtype definition.

	:param predefinedtype
	:type predefinedtype:ifcairterminalboxtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowcontrollertype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__applicableoccurrence,
                                       inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                       inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcairterminalboxtypeenum):
            self._predefinedtype = ifcairterminalboxtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcairterminalboxtypeenum.userdefined) or (
                    (self.predefinedtype == ifcairterminalboxtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcelementarysurface #
####################
class ifcelementarysurface(ifcsurface):
    '''Entity ifcelementarysurface definition.

	:param position
	:type position:ifcaxis2placement3d
	'''

    def __init__(self, position, ):
        ifcsurface.__init__(self, )
        self._position = position

    @property
    def position(self):
        return self._position

    @position.setter
    def position(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcaxis2placement3d):
            self._position = ifcaxis2placement3d(value)
        else:
            self._position = value


####################
# ENTITY ifccylindricalsurface #
####################
class ifccylindricalsurface(ifcelementarysurface):
    '''Entity ifccylindricalsurface definition.

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__position, radius, ):
        ifcelementarysurface.__init__(self, inherited0__position, )
        self._radius = radius

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._radius = ifcpositivelengthmeasure(value)
        else:
            self._radius = value


####################
# ENTITY ifcvalvetype #
####################
class ifcvalvetype(ifcflowcontrollertype):
    '''Entity ifcvalvetype definition.

	:param predefinedtype
	:type predefinedtype:ifcvalvetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowcontrollertype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__applicableoccurrence,
                                       inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                       inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcvalvetypeenum):
            self._predefinedtype = ifcvalvetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcvalvetypeenum.userdefined) or (
                    (self.predefinedtype == ifcvalvetypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcvibrationisolator #
####################
class ifcvibrationisolator(ifcelementcomponent):
    '''Entity ifcvibrationisolator definition.

	:param predefinedtype
	:type predefinedtype:ifcvibrationisolatortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcelementcomponent.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcvibrationisolatortypeenum):
                self._predefinedtype = ifcvibrationisolatortypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcvibrationisolatortypeenum.userdefined)) or ((
                                                                                                      self.predefinedtype == ifcvibrationisolatortypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCVIBRATIONISOLATORTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcvirtualelement #
####################
class ifcvirtualelement(ifcelement):
    '''Entity ifcvirtualelement definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, inherited7__tag, )


####################
# ENTITY ifccivilelementtype #
####################
class ifccivilelementtype(ifcelementtype):
    '''Entity ifccivilelementtype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__representationmaps, inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcconnectionsurfacegeometry #
####################
class ifcconnectionsurfacegeometry(ifcconnectiongeometry):
    '''Entity ifcconnectionsurfacegeometry definition.

	:param surfaceonrelatingelement
	:type surfaceonrelatingelement:ifcsurfaceorfacesurface

	:param surfaceonrelatedelement
	:type surfaceonrelatedelement:ifcsurfaceorfacesurface
	'''

    def __init__(self, surfaceonrelatingelement, surfaceonrelatedelement, ):
        ifcconnectiongeometry.__init__(self, )
        self._surfaceonrelatingelement = surfaceonrelatingelement
        self._surfaceonrelatedelement = surfaceonrelatedelement

    @property
    def surfaceonrelatingelement(self):
        return self._surfaceonrelatingelement

    @surfaceonrelatingelement.setter
    def surfaceonrelatingelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsurfaceorfacesurface):
            self._surfaceonrelatingelement = ifcsurfaceorfacesurface(value)
        else:
            self._surfaceonrelatingelement = value

    @property
    def surfaceonrelatedelement(self):
        return self._surfaceonrelatedelement

    @surfaceonrelatedelement.setter
    def surfaceonrelatedelement(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsurfaceorfacesurface):
                self._surfaceonrelatedelement = ifcsurfaceorfacesurface(value)
            else:
                self._surfaceonrelatedelement = value
        else:
            self._surfaceonrelatedelement = value


####################
# ENTITY ifcmaterialprofilewithoffsets #
####################
class ifcmaterialprofilewithoffsets(ifcmaterialprofile):
    '''Entity ifcmaterialprofilewithoffsets definition.

	:param offsetvalues
	:type offsetvalues:ARRAY(1,2,'REAL', scope = schema_scope)
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__material, inherited3__profile,
                 inherited4__priority, inherited5__category, offsetvalues, ):
        ifcmaterialprofile.__init__(self, inherited0__name, inherited1__description, inherited2__material,
                                    inherited3__profile, inherited4__priority, inherited5__category, )
        self._offsetvalues = offsetvalues

    @property
    def offsetvalues(self):
        return self._offsetvalues

    @offsetvalues.setter
    def offsetvalues(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ARRAY(1, 2, 'REAL', scope=schema_scope)):
            self._offsetvalues = ARRAY(value)
        else:
            self._offsetvalues = value


####################
# ENTITY ifcmaterialproperties #
####################
class ifcmaterialproperties(ifcextendedproperties):
    '''Entity ifcmaterialproperties definition.

	:param material
	:type material:ifcmaterialdefinition
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__properties, material, ):
        ifcextendedproperties.__init__(self, inherited0__name, inherited1__description, inherited2__properties, )
        self._material = material

    @property
    def material(self):
        return self._material

    @material.setter
    def material(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmaterialdefinition):
            self._material = ifcmaterialdefinition(value)
        else:
            self._material = value


####################
# ENTITY ifcdirection #
####################
class ifcdirection(ifcgeometricrepresentationitem):
    '''Entity ifcdirection definition.

	:param directionratios
	:type directionratios:LIST(2,3,'REAL', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, directionratios, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._directionratios = directionratios

    @property
    def directionratios(self):
        return self._directionratios

    @directionratios.setter
    def directionratios(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, 3, 'REAL', scope=schema_scope)):
            self._directionratios = LIST(value)
        else:
            self._directionratios = value

    @property
    def dim(self):
        attribute_eval = HIINDEX(self.directionratios)
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')

    def magnitudegreaterzero(self):
        eval_magnitudegreaterzero_wr = (SIZEOF(None) > 0)
        if not eval_magnitudegreaterzero_wr:
            raise AssertionError('Rule magnitudegreaterzero violated')
        else:
            return eval_magnitudegreaterzero_wr


####################
# ENTITY ifctrapeziumprofiledef #
####################
class ifctrapeziumprofiledef(ifcparameterizedprofiledef):
    '''Entity ifctrapeziumprofiledef definition.

	:param bottomxdim
	:type bottomxdim:ifcpositivelengthmeasure

	:param topxdim
	:type topxdim:ifcpositivelengthmeasure

	:param ydim
	:type ydim:ifcpositivelengthmeasure

	:param topxoffset
	:type topxoffset:ifclengthmeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, bottomxdim, topxdim,
                 ydim, topxoffset, ):
        ifcparameterizedprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename,
                                            inherited2__position, )
        self._bottomxdim = bottomxdim
        self._topxdim = topxdim
        self._ydim = ydim
        self._topxoffset = topxoffset

    @property
    def bottomxdim(self):
        return self._bottomxdim

    @bottomxdim.setter
    def bottomxdim(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._bottomxdim = ifcpositivelengthmeasure(value)
        else:
            self._bottomxdim = value

    @property
    def topxdim(self):
        return self._topxdim

    @topxdim.setter
    def topxdim(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._topxdim = ifcpositivelengthmeasure(value)
        else:
            self._topxdim = value

    @property
    def ydim(self):
        return self._ydim

    @ydim.setter
    def ydim(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._ydim = ifcpositivelengthmeasure(value)
        else:
            self._ydim = value

    @property
    def topxoffset(self):
        return self._topxoffset

    @topxoffset.setter
    def topxoffset(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._topxoffset = ifclengthmeasure(value)
        else:
            self._topxoffset = value


####################
# ENTITY ifcconnectionvolumegeometry #
####################
class ifcconnectionvolumegeometry(ifcconnectiongeometry):
    '''Entity ifcconnectionvolumegeometry definition.

	:param volumeonrelatingelement
	:type volumeonrelatingelement:ifcsolidorshell

	:param volumeonrelatedelement
	:type volumeonrelatedelement:ifcsolidorshell
	'''

    def __init__(self, volumeonrelatingelement, volumeonrelatedelement, ):
        ifcconnectiongeometry.__init__(self, )
        self._volumeonrelatingelement = volumeonrelatingelement
        self._volumeonrelatedelement = volumeonrelatedelement

    @property
    def volumeonrelatingelement(self):
        return self._volumeonrelatingelement

    @volumeonrelatingelement.setter
    def volumeonrelatingelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsolidorshell):
            self._volumeonrelatingelement = ifcsolidorshell(value)
        else:
            self._volumeonrelatingelement = value

    @property
    def volumeonrelatedelement(self):
        return self._volumeonrelatedelement

    @volumeonrelatedelement.setter
    def volumeonrelatedelement(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsolidorshell):
                self._volumeonrelatedelement = ifcsolidorshell(value)
            else:
                self._volumeonrelatedelement = value
        else:
            self._volumeonrelatedelement = value


####################
# ENTITY ifcductfittingtype #
####################
class ifcductfittingtype(ifcflowfittingtype):
    '''Entity ifcductfittingtype definition.

	:param predefinedtype
	:type predefinedtype:ifcductfittingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowfittingtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__applicableoccurrence,
                                    inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                    inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcductfittingtypeenum):
            self._predefinedtype = ifcductfittingtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcductfittingtypeenum.userdefined) or (
                    (self.predefinedtype == ifcductfittingtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcsectionedsolid #
####################
class ifcsectionedsolid(ifcsolidmodel):
    '''Entity ifcsectionedsolid definition.

	:param directrix
	:type directrix:ifccurve

	:param crosssections
	:type crosssections:LIST(2,None,'ifcprofiledef', scope = schema_scope)
	'''

    def __init__(self, directrix, crosssections, ):
        ifcsolidmodel.__init__(self, )
        self._directrix = directrix
        self._crosssections = crosssections

    @property
    def directrix(self):
        return self._directrix

    @directrix.setter
    def directrix(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._directrix = ifccurve(value)
        else:
            self._directrix = value

    @property
    def crosssections(self):
        return self._crosssections

    @crosssections.setter
    def crosssections(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, 'ifcprofiledef', scope=schema_scope)):
            self._crosssections = LIST(value)
        else:
            self._crosssections = value

    def directrixis3d(self):
        eval_directrixis3d_wr = (self.directrix.self.dim == 3)
        if not eval_directrixis3d_wr:
            raise AssertionError('Rule directrixis3d violated')
        else:
            return eval_directrixis3d_wr

    def consistentprofiletypes(self):
        eval_consistentprofiletypes_wr = (SIZEOF(None) == 0)
        if not eval_consistentprofiletypes_wr:
            raise AssertionError('Rule consistentprofiletypes violated')
        else:
            return eval_consistentprofiletypes_wr

    def sectionssametype(self):
        eval_sectionssametype_wr = (SIZEOF(None) == 0)
        if not eval_sectionssametype_wr:
            raise AssertionError('Rule sectionssametype violated')
        else:
            return eval_sectionssametype_wr


####################
# ENTITY ifcsectionedsolidhorizontal #
####################
class ifcsectionedsolidhorizontal(ifcsectionedsolid):
    '''Entity ifcsectionedsolidhorizontal definition.

	:param crosssectionpositions
	:type crosssectionpositions:LIST(2,None,'ifcdistanceexpression', scope = schema_scope)

	:param fixedaxisvertical
	:type fixedaxisvertical:ifcboolean
	'''

    def __init__(self, inherited0__directrix, inherited1__crosssections, crosssectionpositions, fixedaxisvertical, ):
        ifcsectionedsolid.__init__(self, inherited0__directrix, inherited1__crosssections, )
        self._crosssectionpositions = crosssectionpositions
        self._fixedaxisvertical = fixedaxisvertical

    @property
    def crosssectionpositions(self):
        return self._crosssectionpositions

    @crosssectionpositions.setter
    def crosssectionpositions(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, 'ifcdistanceexpression', scope=schema_scope)):
            self._crosssectionpositions = LIST(value)
        else:
            self._crosssectionpositions = value

    @property
    def fixedaxisvertical(self):
        return self._fixedaxisvertical

    @fixedaxisvertical.setter
    def fixedaxisvertical(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._fixedaxisvertical = ifcboolean(value)
        else:
            self._fixedaxisvertical = value

    def correspondingsectionpositions(self):
        eval_correspondingsectionpositions_wr = (SIZEOF(self.crosssections) == SIZEOF(self.crosssectionpositions))
        if not eval_correspondingsectionpositions_wr:
            raise AssertionError('Rule correspondingsectionpositions violated')
        else:
            return eval_correspondingsectionpositions_wr

    def nolongitudinaloffsets(self):
        eval_nolongitudinaloffsets_wr = (SIZEOF(None) == 0)
        if not eval_nolongitudinaloffsets_wr:
            raise AssertionError('Rule nolongitudinaloffsets violated')
        else:
            return eval_nolongitudinaloffsets_wr


####################
# ENTITY ifcjunctionboxtype #
####################
class ifcjunctionboxtype(ifcflowfittingtype):
    '''Entity ifcjunctionboxtype definition.

	:param predefinedtype
	:type predefinedtype:ifcjunctionboxtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowfittingtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__applicableoccurrence,
                                    inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                    inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcjunctionboxtypeenum):
            self._predefinedtype = ifcjunctionboxtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcjunctionboxtypeenum.userdefined) or (
                    (self.predefinedtype == ifcjunctionboxtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcsiunit #
####################
class ifcsiunit(ifcnamedunit):
    '''Entity ifcsiunit definition.

	:param prefix
	:type prefix:ifcsiprefix

	:param name
	:type name:ifcsiunitname

	:param dimensions
	:type dimensions:ifcdimensionalexponents
	'''

    def __init__(self, inherited0__dimensions, inherited1__unittype, prefix, name, ):
        ifcnamedunit.__init__(self, inherited0__dimensions, inherited1__unittype, )
        self._prefix = prefix
        self._name = name

    @property
    def prefix(self):
        return self._prefix

    @prefix.setter
    def prefix(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsiprefix):
                self._prefix = ifcsiprefix(value)
            else:
                self._prefix = value
        else:
            self._prefix = value

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsiunitname):
            self._name = ifcsiunitname(value)
        else:
            self._name = value

    @property
    def dimensions(self):
        attribute_eval = ifcdimensionsforsiunit(self.self.name)
        return attribute_eval

    @dimensions.setter
    def dimensions(self, value):
        # DERIVED argument
        raise AssertionError('Argument dimensions is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcstackterminaltype #
####################
class ifcstackterminaltype(ifcflowterminaltype):
    '''Entity ifcstackterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcstackterminaltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowterminaltype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__applicableoccurrence,
                                     inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                     inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstackterminaltypeenum):
            self._predefinedtype = ifcstackterminaltypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcstackterminaltypeenum.userdefined) or (
                    (self.predefinedtype == ifcstackterminaltypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifctshapeprofiledef #
####################
class ifctshapeprofiledef(ifcparameterizedprofiledef):
    '''Entity ifctshapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param flangewidth
	:type flangewidth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param flangethickness
	:type flangethickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcnonnegativelengthmeasure

	:param flangeedgeradius
	:type flangeedgeradius:ifcnonnegativelengthmeasure

	:param webedgeradius
	:type webedgeradius:ifcnonnegativelengthmeasure

	:param webslope
	:type webslope:ifcplaneanglemeasure

	:param flangeslope
	:type flangeslope:ifcplaneanglemeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, depth, flangewidth,
                 webthickness, flangethickness, filletradius, flangeedgeradius, webedgeradius, webslope, flangeslope, ):
        ifcparameterizedprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename,
                                            inherited2__position, )
        self._depth = depth
        self._flangewidth = flangewidth
        self._webthickness = webthickness
        self._flangethickness = flangethickness
        self._filletradius = filletradius
        self._flangeedgeradius = flangeedgeradius
        self._webedgeradius = webedgeradius
        self._webslope = webslope
        self._flangeslope = flangeslope

    @property
    def depth(self):
        return self._depth

    @depth.setter
    def depth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._depth = ifcpositivelengthmeasure(value)
        else:
            self._depth = value

    @property
    def flangewidth(self):
        return self._flangewidth

    @flangewidth.setter
    def flangewidth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._flangewidth = ifcpositivelengthmeasure(value)
        else:
            self._flangewidth = value

    @property
    def webthickness(self):
        return self._webthickness

    @webthickness.setter
    def webthickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._webthickness = ifcpositivelengthmeasure(value)
        else:
            self._webthickness = value

    @property
    def flangethickness(self):
        return self._flangethickness

    @flangethickness.setter
    def flangethickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._flangethickness = ifcpositivelengthmeasure(value)
        else:
            self._flangethickness = value

    @property
    def filletradius(self):
        return self._filletradius

    @filletradius.setter
    def filletradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._filletradius = ifcnonnegativelengthmeasure(value)
            else:
                self._filletradius = value
        else:
            self._filletradius = value

    @property
    def flangeedgeradius(self):
        return self._flangeedgeradius

    @flangeedgeradius.setter
    def flangeedgeradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._flangeedgeradius = ifcnonnegativelengthmeasure(value)
            else:
                self._flangeedgeradius = value
        else:
            self._flangeedgeradius = value

    @property
    def webedgeradius(self):
        return self._webedgeradius

    @webedgeradius.setter
    def webedgeradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._webedgeradius = ifcnonnegativelengthmeasure(value)
            else:
                self._webedgeradius = value
        else:
            self._webedgeradius = value

    @property
    def webslope(self):
        return self._webslope

    @webslope.setter
    def webslope(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplaneanglemeasure):
                self._webslope = ifcplaneanglemeasure(value)
            else:
                self._webslope = value
        else:
            self._webslope = value

    @property
    def flangeslope(self):
        return self._flangeslope

    @flangeslope.setter
    def flangeslope(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplaneanglemeasure):
                self._flangeslope = ifcplaneanglemeasure(value)
            else:
                self._flangeslope = value
        else:
            self._flangeslope = value

    def validflangethickness(self):
        eval_validflangethickness_wr = (self.flangethickness < self.depth)
        if not eval_validflangethickness_wr:
            raise AssertionError('Rule validflangethickness violated')
        else:
            return eval_validflangethickness_wr

    def validwebthickness(self):
        eval_validwebthickness_wr = (self.webthickness < self.flangewidth)
        if not eval_validwebthickness_wr:
            raise AssertionError('Rule validwebthickness violated')
        else:
            return eval_validwebthickness_wr


####################
# ENTITY ifcactuatortype #
####################
class ifcactuatortype(ifcdistributioncontrolelementtype):
    '''Entity ifcactuatortype definition.

	:param predefinedtype
	:type predefinedtype:ifcactuatortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcdistributioncontrolelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory,
                                                   inherited2__name, inherited3__description,
                                                   inherited4__applicableoccurrence, inherited5__haspropertysets,
                                                   inherited6__representationmaps, inherited7__tag,
                                                   inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcactuatortypeenum):
            self._predefinedtype = ifcactuatortypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcactuatortypeenum.userdefined) or (
                    (self.predefinedtype == ifcactuatortypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcline #
####################
class ifcline(ifccurve):
    '''Entity ifcline definition.

	:param pnt
	:type pnt:ifccartesianpoint

	:param dir
	:type dir:ifcvector
	'''

    def __init__(self, pnt, dir, ):
        ifccurve.__init__(self, )
        self._pnt = pnt
        self._dir = dir

    @property
    def pnt(self):
        return self._pnt

    @pnt.setter
    def pnt(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccartesianpoint):
            self._pnt = ifccartesianpoint(value)
        else:
            self._pnt = value

    @property
    def dir(self):
        return self._dir

    @dir.setter
    def dir(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcvector):
            self._dir = ifcvector(value)
        else:
            self._dir = value

    def samedim(self):
        eval_samedim_wr = (self.dir.self.dim == self.pnt.self.dim)
        if not eval_samedim_wr:
            raise AssertionError('Rule samedim violated')
        else:
            return eval_samedim_wr


####################
# ENTITY ifcperformancehistory #
####################
class ifcperformancehistory(ifccontrol):
    '''Entity ifcperformancehistory definition.

	:param lifecyclephase
	:type lifecyclephase:ifclabel

	:param predefinedtype
	:type predefinedtype:ifcperformancehistorytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, lifecyclephase, predefinedtype, ):
        ifccontrol.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__identification, )
        self._lifecyclephase = lifecyclephase
        self._predefinedtype = predefinedtype

    @property
    def lifecyclephase(self):
        return self._lifecyclephase

    @lifecyclephase.setter
    def lifecyclephase(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._lifecyclephase = ifclabel(value)
        else:
            self._lifecyclephase = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcperformancehistorytypeenum):
                self._predefinedtype = ifcperformancehistorytypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value


####################
# ENTITY ifcrelassignstocontrol #
####################
class ifcrelassignstocontrol(ifcrelassigns):
    '''Entity ifcrelassignstocontrol definition.

	:param relatingcontrol
	:type relatingcontrol:ifccontrol
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatedobjects, inherited5__relatedobjectstype, relatingcontrol, ):
        ifcrelassigns.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                               inherited3__description, inherited4__relatedobjects, inherited5__relatedobjectstype, )
        self._relatingcontrol = relatingcontrol

    @property
    def relatingcontrol(self):
        return self._relatingcontrol

    @relatingcontrol.setter
    def relatingcontrol(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccontrol):
            self._relatingcontrol = ifccontrol(value)
        else:
            self._relatingcontrol = value

    def noselfreference(self):
        eval_noselfreference_wr = (SIZEOF(None) == 0)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifcshapemodel #
####################
class ifcshapemodel(ifcrepresentation):
    '''Entity ifcshapemodel definition.

	:param ofshapeaspect
	:type ofshapeaspect:SET(0,1,'ifcshapeaspect', scope = schema_scope)
	'''

    def __init__(self, inherited0__contextofitems, inherited1__representationidentifier, inherited2__representationtype,
                 inherited3__items, ):
        ifcrepresentation.__init__(self, inherited0__contextofitems, inherited1__representationidentifier,
                                   inherited2__representationtype, inherited3__items, )

    @property
    def ofshapeaspect(self):
        return self._ofshapeaspect

    @ofshapeaspect.setter
    def ofshapeaspect(self, value):
        # INVERSE argument
        raise AssertionError('Argument ofshapeaspect is INVERSE. It is computed and can not be set to any value')

    def wr11(self):
        eval_wr11_wr = ((SIZEOF(self.self.ifcrepresentation.self.ofproductrepresentation) == 1) != (
                    SIZEOF(self.self.ifcrepresentation.self.representationmap) == 1) != (
                                    SIZEOF(self.ofshapeaspect) == 1))
        if not eval_wr11_wr:
            raise AssertionError('Rule wr11 violated')
        else:
            return eval_wr11_wr


####################
# ENTITY ifcshaperepresentation #
####################
class ifcshaperepresentation(ifcshapemodel):
    '''Entity ifcshaperepresentation definition.
	'''

    def __init__(self, inherited0__contextofitems, inherited1__representationidentifier, inherited2__representationtype,
                 inherited3__items, ):
        ifcshapemodel.__init__(self, inherited0__contextofitems, inherited1__representationidentifier,
                               inherited2__representationtype, inherited3__items, )

    def correctcontext(self):
        eval_correctcontext_wr = ('IFC4X2.IFCGEOMETRICREPRESENTATIONCONTEXT' == TYPEOF(
            self.self.ifcrepresentation.self.contextofitems))
        if not eval_correctcontext_wr:
            raise AssertionError('Rule correctcontext violated')
        else:
            return eval_correctcontext_wr

    def notopologicalitem(self):
        eval_notopologicalitem_wr = (SIZEOF(None) == 0)
        if not eval_notopologicalitem_wr:
            raise AssertionError('Rule notopologicalitem violated')
        else:
            return eval_notopologicalitem_wr

    def hasrepresentationtype(self):
        eval_hasrepresentationtype_wr = EXISTS(self.self.ifcrepresentation.self.representationtype)
        if not eval_hasrepresentationtype_wr:
            raise AssertionError('Rule hasrepresentationtype violated')
        else:
            return eval_hasrepresentationtype_wr

    def hasrepresentationidentifier(self):
        eval_hasrepresentationidentifier_wr = EXISTS(self.self.ifcrepresentation.self.representationidentifier)
        if not eval_hasrepresentationidentifier_wr:
            raise AssertionError('Rule hasrepresentationidentifier violated')
        else:
            return eval_hasrepresentationidentifier_wr

    def correctitemsfortype(self):
        eval_correctitemsfortype_wr = ifcshaperepresentationtypes(self.self.ifcrepresentation.self.representationtype,
                                                                  self.self.ifcrepresentation.self.items)
        if not eval_correctitemsfortype_wr:
            raise AssertionError('Rule correctitemsfortype violated')
        else:
            return eval_correctitemsfortype_wr


####################
# ENTITY ifcclassification #
####################
class ifcclassification(ifcexternalinformation):
    '''Entity ifcclassification definition.

	:param source
	:type source:ifclabel

	:param edition
	:type edition:ifclabel

	:param editiondate
	:type editiondate:ifcdate

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param location
	:type location:ifcurireference

	:param referencetokens
	:type referencetokens:LIST(1,None,'STRING', scope = schema_scope)

	:param classificationforobjects
	:type classificationforobjects:SET(0,None,'ifcrelassociatesclassification', scope = schema_scope)

	:param hasreferences
	:type hasreferences:SET(0,None,'ifcclassificationreference', scope = schema_scope)
	'''

    def __init__(self, source, edition, editiondate, name, description, location, referencetokens, ):
        ifcexternalinformation.__init__(self, )
        self._source = source
        self._edition = edition
        self._editiondate = editiondate
        self._name = name
        self._description = description
        self._location = location
        self._referencetokens = referencetokens

    @property
    def source(self):
        return self._source

    @source.setter
    def source(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._source = ifclabel(value)
            else:
                self._source = value
        else:
            self._source = value

    @property
    def edition(self):
        return self._edition

    @edition.setter
    def edition(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._edition = ifclabel(value)
            else:
                self._edition = value
        else:
            self._edition = value

    @property
    def editiondate(self):
        return self._editiondate

    @editiondate.setter
    def editiondate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdate):
                self._editiondate = ifcdate(value)
            else:
                self._editiondate = value
        else:
            self._editiondate = value

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def location(self):
        return self._location

    @location.setter
    def location(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcurireference):
                self._location = ifcurireference(value)
            else:
                self._location = value
        else:
            self._location = value

    @property
    def referencetokens(self):
        return self._referencetokens

    @referencetokens.setter
    def referencetokens(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'STRING', scope=schema_scope)):
                self._referencetokens = LIST(value)
            else:
                self._referencetokens = value
        else:
            self._referencetokens = value

    @property
    def classificationforobjects(self):
        return self._classificationforobjects

    @classificationforobjects.setter
    def classificationforobjects(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument classificationforobjects is INVERSE. It is computed and can not be set to any value')

    @property
    def hasreferences(self):
        return self._hasreferences

    @hasreferences.setter
    def hasreferences(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasreferences is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcengine #
####################
class ifcengine(ifcenergyconversiondevice):
    '''Entity ifcengine definition.

	:param predefinedtype
	:type predefinedtype:ifcenginetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcenginetypeenum):
                self._predefinedtype = ifcenginetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcenginetypeenum.userdefined)) or (
                        (self.predefinedtype == ifcenginetypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCENGINETYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcpostaladdress #
####################
class ifcpostaladdress(ifcaddress):
    '''Entity ifcpostaladdress definition.

	:param internallocation
	:type internallocation:ifclabel

	:param addresslines
	:type addresslines:LIST(1,None,'STRING', scope = schema_scope)

	:param postalbox
	:type postalbox:ifclabel

	:param town
	:type town:ifclabel

	:param region
	:type region:ifclabel

	:param postalcode
	:type postalcode:ifclabel

	:param country
	:type country:ifclabel
	'''

    def __init__(self, inherited0__purpose, inherited1__description, inherited2__userdefinedpurpose, internallocation,
                 addresslines, postalbox, town, region, postalcode, country, ):
        ifcaddress.__init__(self, inherited0__purpose, inherited1__description, inherited2__userdefinedpurpose, )
        self._internallocation = internallocation
        self._addresslines = addresslines
        self._postalbox = postalbox
        self._town = town
        self._region = region
        self._postalcode = postalcode
        self._country = country

    @property
    def internallocation(self):
        return self._internallocation

    @internallocation.setter
    def internallocation(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._internallocation = ifclabel(value)
            else:
                self._internallocation = value
        else:
            self._internallocation = value

    @property
    def addresslines(self):
        return self._addresslines

    @addresslines.setter
    def addresslines(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'STRING', scope=schema_scope)):
                self._addresslines = LIST(value)
            else:
                self._addresslines = value
        else:
            self._addresslines = value

    @property
    def postalbox(self):
        return self._postalbox

    @postalbox.setter
    def postalbox(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._postalbox = ifclabel(value)
            else:
                self._postalbox = value
        else:
            self._postalbox = value

    @property
    def town(self):
        return self._town

    @town.setter
    def town(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._town = ifclabel(value)
            else:
                self._town = value
        else:
            self._town = value

    @property
    def region(self):
        return self._region

    @region.setter
    def region(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._region = ifclabel(value)
            else:
                self._region = value
        else:
            self._region = value

    @property
    def postalcode(self):
        return self._postalcode

    @postalcode.setter
    def postalcode(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._postalcode = ifclabel(value)
            else:
                self._postalcode = value
        else:
            self._postalcode = value

    @property
    def country(self):
        return self._country

    @country.setter
    def country(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._country = ifclabel(value)
            else:
                self._country = value
        else:
            self._country = value

    def wr1(self):
        eval_wr1_wr = ((((((EXISTS(self.internallocation) or EXISTS(self.addresslines)) or EXISTS(
            self.postalbox)) or EXISTS(self.postalcode)) or EXISTS(self.town)) or EXISTS(self.region)) or EXISTS(
            self.country))
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


####################
# ENTITY ifccurvestylefont #
####################
class ifccurvestylefont(ifcpresentationitem):
    '''Entity ifccurvestylefont definition.

	:param name
	:type name:ifclabel

	:param patternlist
	:type patternlist:LIST(1,None,'ifccurvestylefontpattern', scope = schema_scope)
	'''

    def __init__(self, name, patternlist, ):
        ifcpresentationitem.__init__(self, )
        self._name = name
        self._patternlist = patternlist

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def patternlist(self):
        return self._patternlist

    @patternlist.setter
    def patternlist(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifccurvestylefontpattern', scope=schema_scope)):
            self._patternlist = LIST(value)
        else:
            self._patternlist = value


####################
# ENTITY ifcelectricdistributionboard #
####################
class ifcelectricdistributionboard(ifcflowcontroller):
    '''Entity ifcelectricdistributionboard definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricdistributionboardtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowcontroller.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcelectricdistributionboardtypeenum):
                self._predefinedtype = ifcelectricdistributionboardtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcelectricdistributionboardtypeenum.userdefined)) or ((
                                                                                                              self.predefinedtype == ifcelectricdistributionboardtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCELECTRICDISTRIBUTIONBOARDTYPE' == TYPEOF(
                self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcdiscreteaccessory #
####################
class ifcdiscreteaccessory(ifcelementcomponent):
    '''Entity ifcdiscreteaccessory definition.

	:param predefinedtype
	:type predefinedtype:ifcdiscreteaccessorytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcelementcomponent.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdiscreteaccessorytypeenum):
                self._predefinedtype = ifcdiscreteaccessorytypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcdiscreteaccessorytypeenum.userdefined)) or ((
                                                                                                      self.predefinedtype == ifcdiscreteaccessorytypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCDISCRETEACCESSORYTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcreference #
####################
class ifcreference(BaseEntityClass):
    '''Entity ifcreference definition.

	:param typeidentifier
	:type typeidentifier:ifcidentifier

	:param attributeidentifier
	:type attributeidentifier:ifcidentifier

	:param instancename
	:type instancename:ifclabel

	:param listpositions
	:type listpositions:LIST(1,None,'INTEGER', scope = schema_scope)

	:param innerreference
	:type innerreference:ifcreference
	'''

    def __init__(self, typeidentifier, attributeidentifier, instancename, listpositions, innerreference, ):
        self._typeidentifier = typeidentifier
        self._attributeidentifier = attributeidentifier
        self._instancename = instancename
        self._listpositions = listpositions
        self._innerreference = innerreference

    @property
    def typeidentifier(self):
        return self._typeidentifier

    @typeidentifier.setter
    def typeidentifier(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._typeidentifier = ifcidentifier(value)
            else:
                self._typeidentifier = value
        else:
            self._typeidentifier = value

    @property
    def attributeidentifier(self):
        return self._attributeidentifier

    @attributeidentifier.setter
    def attributeidentifier(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._attributeidentifier = ifcidentifier(value)
            else:
                self._attributeidentifier = value
        else:
            self._attributeidentifier = value

    @property
    def instancename(self):
        return self._instancename

    @instancename.setter
    def instancename(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._instancename = ifclabel(value)
            else:
                self._instancename = value
        else:
            self._instancename = value

    @property
    def listpositions(self):
        return self._listpositions

    @listpositions.setter
    def listpositions(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'INTEGER', scope=schema_scope)):
                self._listpositions = LIST(value)
            else:
                self._listpositions = value
        else:
            self._listpositions = value

    @property
    def innerreference(self):
        return self._innerreference

    @innerreference.setter
    def innerreference(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreference):
                self._innerreference = ifcreference(value)
            else:
                self._innerreference = value
        else:
            self._innerreference = value


####################
# ENTITY ifcbuildingsystem #
####################
class ifcbuildingsystem(ifcsystem):
    '''Entity ifcbuildingsystem definition.

	:param predefinedtype
	:type predefinedtype:ifcbuildingsystemtypeenum

	:param longname
	:type longname:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, predefinedtype, longname, ):
        ifcsystem.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                           inherited3__description, inherited4__objecttype, )
        self._predefinedtype = predefinedtype
        self._longname = longname

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcbuildingsystemtypeenum):
                self._predefinedtype = ifcbuildingsystemtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def longname(self):
        return self._longname

    @longname.setter
    def longname(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._longname = ifclabel(value)
            else:
                self._longname = value
        else:
            self._longname = value


####################
# ENTITY ifcshellbasedsurfacemodel #
####################
class ifcshellbasedsurfacemodel(ifcgeometricrepresentationitem):
    '''Entity ifcshellbasedsurfacemodel definition.

	:param sbsmboundary
	:type sbsmboundary:SET(1,None,'ifcshell', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, sbsmboundary, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._sbsmboundary = sbsmboundary

    @property
    def sbsmboundary(self):
        return self._sbsmboundary

    @sbsmboundary.setter
    def sbsmboundary(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcshell', scope=schema_scope)):
            self._sbsmboundary = SET(value)
        else:
            self._sbsmboundary = value

    @property
    def dim(self):
        attribute_eval = 3
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifctoroidalsurface #
####################
class ifctoroidalsurface(ifcelementarysurface):
    '''Entity ifctoroidalsurface definition.

	:param majorradius
	:type majorradius:ifcpositivelengthmeasure

	:param minorradius
	:type minorradius:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__position, majorradius, minorradius, ):
        ifcelementarysurface.__init__(self, inherited0__position, )
        self._majorradius = majorradius
        self._minorradius = minorradius

    @property
    def majorradius(self):
        return self._majorradius

    @majorradius.setter
    def majorradius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._majorradius = ifcpositivelengthmeasure(value)
        else:
            self._majorradius = value

    @property
    def minorradius(self):
        return self._minorradius

    @minorradius.setter
    def minorradius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._minorradius = ifcpositivelengthmeasure(value)
        else:
            self._minorradius = value

    def majorlargerminor(self):
        eval_majorlargerminor_wr = (self.minorradius < self.majorradius)
        if not eval_majorlargerminor_wr:
            raise AssertionError('Rule majorlargerminor violated')
        else:
            return eval_majorlargerminor_wr


####################
# ENTITY ifccartesiantransformationoperator2d #
####################
class ifccartesiantransformationoperator2d(ifccartesiantransformationoperator):
    '''Entity ifccartesiantransformationoperator2d definition.

	:param u
	:type u:LIST(2,2,'ifcdirection', scope = schema_scope)
	'''

    def __init__(self, inherited0__axis1, inherited1__axis2, inherited2__localorigin, inherited3__scale, ):
        ifccartesiantransformationoperator.__init__(self, inherited0__axis1, inherited1__axis2, inherited2__localorigin,
                                                    inherited3__scale, )

    @property
    def u(self):
        attribute_eval = ifcbaseaxis(2, self.self.ifccartesiantransformationoperator.self.axis1,
                                     self.self.ifccartesiantransformationoperator.self.axis2, None)
        return attribute_eval

    @u.setter
    def u(self, value):
        # DERIVED argument
        raise AssertionError('Argument u is DERIVED. It is computed and can not be set to any value')

    def dimequal2(self):
        eval_dimequal2_wr = (self.self.ifccartesiantransformationoperator.self.dim == 2)
        if not eval_dimequal2_wr:
            raise AssertionError('Rule dimequal2 violated')
        else:
            return eval_dimequal2_wr

    def axis1is2d(self):
        eval_axis1is2d_wr = ((not EXISTS(self.self.ifccartesiantransformationoperator.self.axis1)) or (
                    self.self.ifccartesiantransformationoperator.self.axis1.self.dim == 2))
        if not eval_axis1is2d_wr:
            raise AssertionError('Rule axis1is2d violated')
        else:
            return eval_axis1is2d_wr

    def axis2is2d(self):
        eval_axis2is2d_wr = ((not EXISTS(self.self.ifccartesiantransformationoperator.self.axis2)) or (
                    self.self.ifccartesiantransformationoperator.self.axis2.self.dim == 2))
        if not eval_axis2is2d_wr:
            raise AssertionError('Rule axis2is2d violated')
        else:
            return eval_axis2is2d_wr


####################
# ENTITY ifccontext #
####################
class ifccontext(ifcobjectdefinition):
    '''Entity ifccontext definition.

	:param objecttype
	:type objecttype:ifclabel

	:param longname
	:type longname:ifclabel

	:param phase
	:type phase:ifclabel

	:param representationcontexts
	:type representationcontexts:SET(1,None,'ifcrepresentationcontext', scope = schema_scope)

	:param unitsincontext
	:type unitsincontext:ifcunitassignment

	:param isdefinedby
	:type isdefinedby:SET(0,None,'ifcreldefinesbyproperties', scope = schema_scope)

	:param declares
	:type declares:SET(0,None,'ifcreldeclares', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 objecttype, longname, phase, representationcontexts, unitsincontext, ):
        ifcobjectdefinition.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, )
        self._objecttype = objecttype
        self._longname = longname
        self._phase = phase
        self._representationcontexts = representationcontexts
        self._unitsincontext = unitsincontext

    @property
    def objecttype(self):
        return self._objecttype

    @objecttype.setter
    def objecttype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._objecttype = ifclabel(value)
            else:
                self._objecttype = value
        else:
            self._objecttype = value

    @property
    def longname(self):
        return self._longname

    @longname.setter
    def longname(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._longname = ifclabel(value)
            else:
                self._longname = value
        else:
            self._longname = value

    @property
    def phase(self):
        return self._phase

    @phase.setter
    def phase(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._phase = ifclabel(value)
            else:
                self._phase = value
        else:
            self._phase = value

    @property
    def representationcontexts(self):
        return self._representationcontexts

    @representationcontexts.setter
    def representationcontexts(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'ifcrepresentationcontext', scope=schema_scope)):
                self._representationcontexts = SET(value)
            else:
                self._representationcontexts = value
        else:
            self._representationcontexts = value

    @property
    def unitsincontext(self):
        return self._unitsincontext

    @unitsincontext.setter
    def unitsincontext(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcunitassignment):
                self._unitsincontext = ifcunitassignment(value)
            else:
                self._unitsincontext = value
        else:
            self._unitsincontext = value

    @property
    def isdefinedby(self):
        return self._isdefinedby

    @isdefinedby.setter
    def isdefinedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument isdefinedby is INVERSE. It is computed and can not be set to any value')

    @property
    def declares(self):
        return self._declares

    @declares.setter
    def declares(self, value):
        # INVERSE argument
        raise AssertionError('Argument declares is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcdoorliningproperties #
####################
class ifcdoorliningproperties(ifcpredefinedpropertyset):
    '''Entity ifcdoorliningproperties definition.

	:param liningdepth
	:type liningdepth:ifcpositivelengthmeasure

	:param liningthickness
	:type liningthickness:ifcnonnegativelengthmeasure

	:param thresholddepth
	:type thresholddepth:ifcpositivelengthmeasure

	:param thresholdthickness
	:type thresholdthickness:ifcnonnegativelengthmeasure

	:param transomthickness
	:type transomthickness:ifcnonnegativelengthmeasure

	:param transomoffset
	:type transomoffset:ifclengthmeasure

	:param liningoffset
	:type liningoffset:ifclengthmeasure

	:param thresholdoffset
	:type thresholdoffset:ifclengthmeasure

	:param casingthickness
	:type casingthickness:ifcpositivelengthmeasure

	:param casingdepth
	:type casingdepth:ifcpositivelengthmeasure

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect

	:param liningtopaneloffsetx
	:type liningtopaneloffsetx:ifclengthmeasure

	:param liningtopaneloffsety
	:type liningtopaneloffsety:ifclengthmeasure
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 liningdepth, liningthickness, thresholddepth, thresholdthickness, transomthickness, transomoffset,
                 liningoffset, thresholdoffset, casingthickness, casingdepth, shapeaspectstyle, liningtopaneloffsetx,
                 liningtopaneloffsety, ):
        ifcpredefinedpropertyset.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, )
        self._liningdepth = liningdepth
        self._liningthickness = liningthickness
        self._thresholddepth = thresholddepth
        self._thresholdthickness = thresholdthickness
        self._transomthickness = transomthickness
        self._transomoffset = transomoffset
        self._liningoffset = liningoffset
        self._thresholdoffset = thresholdoffset
        self._casingthickness = casingthickness
        self._casingdepth = casingdepth
        self._shapeaspectstyle = shapeaspectstyle
        self._liningtopaneloffsetx = liningtopaneloffsetx
        self._liningtopaneloffsety = liningtopaneloffsety

    @property
    def liningdepth(self):
        return self._liningdepth

    @liningdepth.setter
    def liningdepth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._liningdepth = ifcpositivelengthmeasure(value)
            else:
                self._liningdepth = value
        else:
            self._liningdepth = value

    @property
    def liningthickness(self):
        return self._liningthickness

    @liningthickness.setter
    def liningthickness(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._liningthickness = ifcnonnegativelengthmeasure(value)
            else:
                self._liningthickness = value
        else:
            self._liningthickness = value

    @property
    def thresholddepth(self):
        return self._thresholddepth

    @thresholddepth.setter
    def thresholddepth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._thresholddepth = ifcpositivelengthmeasure(value)
            else:
                self._thresholddepth = value
        else:
            self._thresholddepth = value

    @property
    def thresholdthickness(self):
        return self._thresholdthickness

    @thresholdthickness.setter
    def thresholdthickness(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._thresholdthickness = ifcnonnegativelengthmeasure(value)
            else:
                self._thresholdthickness = value
        else:
            self._thresholdthickness = value

    @property
    def transomthickness(self):
        return self._transomthickness

    @transomthickness.setter
    def transomthickness(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._transomthickness = ifcnonnegativelengthmeasure(value)
            else:
                self._transomthickness = value
        else:
            self._transomthickness = value

    @property
    def transomoffset(self):
        return self._transomoffset

    @transomoffset.setter
    def transomoffset(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._transomoffset = ifclengthmeasure(value)
            else:
                self._transomoffset = value
        else:
            self._transomoffset = value

    @property
    def liningoffset(self):
        return self._liningoffset

    @liningoffset.setter
    def liningoffset(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._liningoffset = ifclengthmeasure(value)
            else:
                self._liningoffset = value
        else:
            self._liningoffset = value

    @property
    def thresholdoffset(self):
        return self._thresholdoffset

    @thresholdoffset.setter
    def thresholdoffset(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._thresholdoffset = ifclengthmeasure(value)
            else:
                self._thresholdoffset = value
        else:
            self._thresholdoffset = value

    @property
    def casingthickness(self):
        return self._casingthickness

    @casingthickness.setter
    def casingthickness(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._casingthickness = ifcpositivelengthmeasure(value)
            else:
                self._casingthickness = value
        else:
            self._casingthickness = value

    @property
    def casingdepth(self):
        return self._casingdepth

    @casingdepth.setter
    def casingdepth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._casingdepth = ifcpositivelengthmeasure(value)
            else:
                self._casingdepth = value
        else:
            self._casingdepth = value

    @property
    def shapeaspectstyle(self):
        return self._shapeaspectstyle

    @shapeaspectstyle.setter
    def shapeaspectstyle(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcshapeaspect):
                self._shapeaspectstyle = ifcshapeaspect(value)
            else:
                self._shapeaspectstyle = value
        else:
            self._shapeaspectstyle = value

    @property
    def liningtopaneloffsetx(self):
        return self._liningtopaneloffsetx

    @liningtopaneloffsetx.setter
    def liningtopaneloffsetx(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._liningtopaneloffsetx = ifclengthmeasure(value)
            else:
                self._liningtopaneloffsetx = value
        else:
            self._liningtopaneloffsetx = value

    @property
    def liningtopaneloffsety(self):
        return self._liningtopaneloffsety

    @liningtopaneloffsety.setter
    def liningtopaneloffsety(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._liningtopaneloffsety = ifclengthmeasure(value)
            else:
                self._liningtopaneloffsety = value
        else:
            self._liningtopaneloffsety = value

    def wr31(self):
        eval_wr31_wr = (not (EXISTS(self.liningdepth) and (not EXISTS(self.liningthickness))))
        if not eval_wr31_wr:
            raise AssertionError('Rule wr31 violated')
        else:
            return eval_wr31_wr

    def wr32(self):
        eval_wr32_wr = (not (EXISTS(self.thresholddepth) and (not EXISTS(self.thresholdthickness))))
        if not eval_wr32_wr:
            raise AssertionError('Rule wr32 violated')
        else:
            return eval_wr32_wr

    def wr33(self):
        eval_wr33_wr = ((EXISTS(self.transomoffset) and EXISTS(self.transomthickness)) != (
                    (not EXISTS(self.transomoffset)) and (not EXISTS(self.transomthickness))))
        if not eval_wr33_wr:
            raise AssertionError('Rule wr33 violated')
        else:
            return eval_wr33_wr

    def wr34(self):
        eval_wr34_wr = ((EXISTS(self.casingdepth) and EXISTS(self.casingthickness)) != (
                    (not EXISTS(self.casingdepth)) and (not EXISTS(self.casingthickness))))
        if not eval_wr34_wr:
            raise AssertionError('Rule wr34 violated')
        else:
            return eval_wr34_wr

    def wr35(self):
        eval_wr35_wr = (EXISTS(self.self.ifcpropertysetdefinition.self.definestype[1]) and (
                    ('IFC4X2.IFCDOORTYPE' == TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1])) or (
                        'IFC4X2.IFCDOORSTYLE' == TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1]))))
        if not eval_wr35_wr:
            raise AssertionError('Rule wr35 violated')
        else:
            return eval_wr35_wr


####################
# ENTITY ifchalfspacesolid #
####################
class ifchalfspacesolid(ifcgeometricrepresentationitem):
    '''Entity ifchalfspacesolid definition.

	:param basesurface
	:type basesurface:ifcsurface

	:param agreementflag
	:type agreementflag:ifcboolean

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, basesurface, agreementflag, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._basesurface = basesurface
        self._agreementflag = agreementflag

    @property
    def basesurface(self):
        return self._basesurface

    @basesurface.setter
    def basesurface(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsurface):
            self._basesurface = ifcsurface(value)
        else:
            self._basesurface = value

    @property
    def agreementflag(self):
        return self._agreementflag

    @agreementflag.setter
    def agreementflag(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._agreementflag = ifcboolean(value)
        else:
            self._agreementflag = value

    @property
    def dim(self):
        attribute_eval = 3
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifclightsource #
####################
class ifclightsource(ifcgeometricrepresentationitem):
    '''Entity ifclightsource definition.

	:param name
	:type name:ifclabel

	:param lightcolour
	:type lightcolour:ifccolourrgb

	:param ambientintensity
	:type ambientintensity:ifcnormalisedratiomeasure

	:param intensity
	:type intensity:ifcnormalisedratiomeasure
	'''

    def __init__(self, name, lightcolour, ambientintensity, intensity, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._name = name
        self._lightcolour = lightcolour
        self._ambientintensity = ambientintensity
        self._intensity = intensity

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def lightcolour(self):
        return self._lightcolour

    @lightcolour.setter
    def lightcolour(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccolourrgb):
            self._lightcolour = ifccolourrgb(value)
        else:
            self._lightcolour = value

    @property
    def ambientintensity(self):
        return self._ambientintensity

    @ambientintensity.setter
    def ambientintensity(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnormalisedratiomeasure):
                self._ambientintensity = ifcnormalisedratiomeasure(value)
            else:
                self._ambientintensity = value
        else:
            self._ambientintensity = value

    @property
    def intensity(self):
        return self._intensity

    @intensity.setter
    def intensity(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnormalisedratiomeasure):
                self._intensity = ifcnormalisedratiomeasure(value)
            else:
                self._intensity = value
        else:
            self._intensity = value


####################
# ENTITY ifclightsourceambient #
####################
class ifclightsourceambient(ifclightsource):
    '''Entity ifclightsourceambient definition.
	'''

    def __init__(self, inherited0__name, inherited1__lightcolour, inherited2__ambientintensity,
                 inherited3__intensity, ):
        ifclightsource.__init__(self, inherited0__name, inherited1__lightcolour, inherited2__ambientintensity,
                                inherited3__intensity, )


####################
# ENTITY ifcmembertype #
####################
class ifcmembertype(ifcbuildingelementtype):
    '''Entity ifcmembertype definition.

	:param predefinedtype
	:type predefinedtype:ifcmembertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmembertypeenum):
            self._predefinedtype = ifcmembertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcmembertypeenum.userdefined) or (
                    (self.predefinedtype == ifcmembertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifctransformertype #
####################
class ifctransformertype(ifcenergyconversiondevicetype):
    '''Entity ifctransformertype definition.

	:param predefinedtype
	:type predefinedtype:ifctransformertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctransformertypeenum):
            self._predefinedtype = ifctransformertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifctransformertypeenum.userdefined) or (
                    (self.predefinedtype == ifctransformertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcchimney #
####################
class ifcchimney(ifcbuildingelement):
    '''Entity ifcchimney definition.

	:param predefinedtype
	:type predefinedtype:ifcchimneytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcchimneytypeenum):
                self._predefinedtype = ifcchimneytypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcchimneytypeenum.userdefined)) or (
                        (self.predefinedtype == ifcchimneytypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCHIMNEYTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcmechanicalfastener #
####################
class ifcmechanicalfastener(ifcelementcomponent):
    '''Entity ifcmechanicalfastener definition.

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param nominallength
	:type nominallength:ifcpositivelengthmeasure

	:param predefinedtype
	:type predefinedtype:ifcmechanicalfastenertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 nominaldiameter, nominallength, predefinedtype, ):
        ifcelementcomponent.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, inherited7__tag, )
        self._nominaldiameter = nominaldiameter
        self._nominallength = nominallength
        self._predefinedtype = predefinedtype

    @property
    def nominaldiameter(self):
        return self._nominaldiameter

    @nominaldiameter.setter
    def nominaldiameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._nominaldiameter = ifcpositivelengthmeasure(value)
            else:
                self._nominaldiameter = value
        else:
            self._nominaldiameter = value

    @property
    def nominallength(self):
        return self._nominallength

    @nominallength.setter
    def nominallength(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._nominallength = ifcpositivelengthmeasure(value)
            else:
                self._nominallength = value
        else:
            self._nominallength = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmechanicalfastenertypeenum):
                self._predefinedtype = ifcmechanicalfastenertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcmechanicalfastenertypeenum.userdefined)) or ((
                                                                                                       self.predefinedtype == ifcmechanicalfastenertypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCMECHANICALFASTENERTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcbooleanresult #
####################
class ifcbooleanresult(ifcgeometricrepresentationitem):
    '''Entity ifcbooleanresult definition.

	:param operator
	:type operator:ifcbooleanoperator

	:param firstoperand
	:type firstoperand:ifcbooleanoperand

	:param secondoperand
	:type secondoperand:ifcbooleanoperand

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, operator, firstoperand, secondoperand, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._operator = operator
        self._firstoperand = firstoperand
        self._secondoperand = secondoperand

    @property
    def operator(self):
        return self._operator

    @operator.setter
    def operator(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcbooleanoperator):
            self._operator = ifcbooleanoperator(value)
        else:
            self._operator = value

    @property
    def firstoperand(self):
        return self._firstoperand

    @firstoperand.setter
    def firstoperand(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcbooleanoperand):
            self._firstoperand = ifcbooleanoperand(value)
        else:
            self._firstoperand = value

    @property
    def secondoperand(self):
        return self._secondoperand

    @secondoperand.setter
    def secondoperand(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcbooleanoperand):
            self._secondoperand = ifcbooleanoperand(value)
        else:
            self._secondoperand = value

    @property
    def dim(self):
        attribute_eval = self.firstoperand.self.dim
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')

    def samedim(self):
        eval_samedim_wr = (self.firstoperand.self.dim == self.secondoperand.self.dim)
        if not eval_samedim_wr:
            raise AssertionError('Rule samedim violated')
        else:
            return eval_samedim_wr

    def firstoperandclosed(self):
        eval_firstoperandclosed_wr = ((not ('IFC4X2.IFCTESSELLATEDFACESET' == TYPEOF(self.firstoperand))) or (
                    EXISTS(self.firstoperand.self.closed) and self.firstoperand.self.closed))
        if not eval_firstoperandclosed_wr:
            raise AssertionError('Rule firstoperandclosed violated')
        else:
            return eval_firstoperandclosed_wr

    def secondoperandclosed(self):
        eval_secondoperandclosed_wr = ((not ('IFC4X2.IFCTESSELLATEDFACESET' == TYPEOF(self.secondoperand))) or (
                    EXISTS(self.secondoperand.self.closed) and self.secondoperand.self.closed))
        if not eval_secondoperandclosed_wr:
            raise AssertionError('Rule secondoperandclosed violated')
        else:
            return eval_secondoperandclosed_wr


####################
# ENTITY ifcindexedtexturemap #
####################
class ifcindexedtexturemap(ifctexturecoordinate):
    '''Entity ifcindexedtexturemap definition.

	:param mappedto
	:type mappedto:ifctessellatedfaceset

	:param texcoords
	:type texcoords:ifctexturevertexlist
	'''

    def __init__(self, inherited0__maps, mappedto, texcoords, ):
        ifctexturecoordinate.__init__(self, inherited0__maps, )
        self._mappedto = mappedto
        self._texcoords = texcoords

    @property
    def mappedto(self):
        return self._mappedto

    @mappedto.setter
    def mappedto(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctessellatedfaceset):
            self._mappedto = ifctessellatedfaceset(value)
        else:
            self._mappedto = value

    @property
    def texcoords(self):
        return self._texcoords

    @texcoords.setter
    def texcoords(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctexturevertexlist):
            self._texcoords = ifctexturevertexlist(value)
        else:
            self._texcoords = value


####################
# ENTITY ifcindexedtriangletexturemap #
####################
class ifcindexedtriangletexturemap(ifcindexedtexturemap):
    '''Entity ifcindexedtriangletexturemap definition.

	:param texcoordindex
	:type texcoordindex:LIST(1,None,LIST(3,3,'INTEGER', scope = schema_scope))
	'''

    def __init__(self, inherited0__maps, inherited1__mappedto, inherited2__texcoords, texcoordindex, ):
        ifcindexedtexturemap.__init__(self, inherited0__maps, inherited1__mappedto, inherited2__texcoords, )
        self._texcoordindex = texcoordindex

    @property
    def texcoordindex(self):
        return self._texcoordindex

    @texcoordindex.setter
    def texcoordindex(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, LIST(3, 3, 'INTEGER', scope=schema_scope))):
                self._texcoordindex = LIST(value)
            else:
                self._texcoordindex = value
        else:
            self._texcoordindex = value


####################
# ENTITY ifcstructuralcurvemember #
####################
class ifcstructuralcurvemember(ifcstructuralmember):
    '''Entity ifcstructuralcurvemember definition.

	:param predefinedtype
	:type predefinedtype:ifcstructuralcurvemembertypeenum

	:param axis
	:type axis:ifcdirection
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, predefinedtype,
                 axis, ):
        ifcstructuralmember.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, )
        self._predefinedtype = predefinedtype
        self._axis = axis

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstructuralcurvemembertypeenum):
            self._predefinedtype = ifcstructuralcurvemembertypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def axis(self):
        return self._axis

    @axis.setter
    def axis(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdirection):
            self._axis = ifcdirection(value)
        else:
            self._axis = value

    def hasobjecttype(self):
        eval_hasobjecttype_wr = ((self.predefinedtype != ifcstructuralcurvemembertypeenum.userdefined) or EXISTS(
            self.self.ifcobject.self.objecttype))
        if not eval_hasobjecttype_wr:
            raise AssertionError('Rule hasobjecttype violated')
        else:
            return eval_hasobjecttype_wr


####################
# ENTITY ifcwindowstyle #
####################
class ifcwindowstyle(ifctypeproduct):
    '''Entity ifcwindowstyle definition.

	:param constructiontype
	:type constructiontype:ifcwindowstyleconstructionenum

	:param operationtype
	:type operationtype:ifcwindowstyleoperationenum

	:param parametertakesprecedence
	:type parametertakesprecedence:ifcboolean

	:param sizeable
	:type sizeable:ifcboolean
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, constructiontype, operationtype, parametertakesprecedence, sizeable, ):
        ifctypeproduct.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__representationmaps, inherited7__tag, )
        self._constructiontype = constructiontype
        self._operationtype = operationtype
        self._parametertakesprecedence = parametertakesprecedence
        self._sizeable = sizeable

    @property
    def constructiontype(self):
        return self._constructiontype

    @constructiontype.setter
    def constructiontype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcwindowstyleconstructionenum):
            self._constructiontype = ifcwindowstyleconstructionenum(value)
        else:
            self._constructiontype = value

    @property
    def operationtype(self):
        return self._operationtype

    @operationtype.setter
    def operationtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcwindowstyleoperationenum):
            self._operationtype = ifcwindowstyleoperationenum(value)
        else:
            self._operationtype = value

    @property
    def parametertakesprecedence(self):
        return self._parametertakesprecedence

    @parametertakesprecedence.setter
    def parametertakesprecedence(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._parametertakesprecedence = ifcboolean(value)
        else:
            self._parametertakesprecedence = value

    @property
    def sizeable(self):
        return self._sizeable

    @sizeable.setter
    def sizeable(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._sizeable = ifcboolean(value)
        else:
            self._sizeable = value


####################
# ENTITY ifcflowmovingdevice #
####################
class ifcflowmovingdevice(ifcdistributionflowelement):
    '''Entity ifcflowmovingdevice definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcdistributionflowelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation, inherited7__tag, )


####################
# ENTITY ifcdocumentinformation #
####################
class ifcdocumentinformation(ifcexternalinformation):
    '''Entity ifcdocumentinformation definition.

	:param identification
	:type identification:ifcidentifier

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param location
	:type location:ifcurireference

	:param purpose
	:type purpose:ifctext

	:param intendeduse
	:type intendeduse:ifctext

	:param scope
	:type scope:ifctext

	:param revision
	:type revision:ifclabel

	:param documentowner
	:type documentowner:ifcactorselect

	:param editors
	:type editors:SET(1,None,'ifcactorselect', scope = schema_scope)

	:param creationtime
	:type creationtime:ifcdatetime

	:param lastrevisiontime
	:type lastrevisiontime:ifcdatetime

	:param electronicformat
	:type electronicformat:ifcidentifier

	:param validfrom
	:type validfrom:ifcdate

	:param validuntil
	:type validuntil:ifcdate

	:param confidentiality
	:type confidentiality:ifcdocumentconfidentialityenum

	:param status
	:type status:ifcdocumentstatusenum

	:param documentinfoforobjects
	:type documentinfoforobjects:SET(0,None,'ifcrelassociatesdocument', scope = schema_scope)

	:param hasdocumentreferences
	:type hasdocumentreferences:SET(0,None,'ifcdocumentreference', scope = schema_scope)

	:param ispointedto
	:type ispointedto:SET(0,None,'ifcdocumentinformationrelationship', scope = schema_scope)

	:param ispointer
	:type ispointer:SET(0,1,'ifcdocumentinformationrelationship', scope = schema_scope)
	'''

    def __init__(self, identification, name, description, location, purpose, intendeduse, scope, revision,
                 documentowner, editors, creationtime, lastrevisiontime, electronicformat, validfrom, validuntil,
                 confidentiality, status, ):
        ifcexternalinformation.__init__(self, )
        self._identification = identification
        self._name = name
        self._description = description
        self._location = location
        self._purpose = purpose
        self._intendeduse = intendeduse
        self._scope = scope
        self._revision = revision
        self._documentowner = documentowner
        self._editors = editors
        self._creationtime = creationtime
        self._lastrevisiontime = lastrevisiontime
        self._electronicformat = electronicformat
        self._validfrom = validfrom
        self._validuntil = validuntil
        self._confidentiality = confidentiality
        self._status = status

    @property
    def identification(self):
        return self._identification

    @identification.setter
    def identification(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcidentifier):
            self._identification = ifcidentifier(value)
        else:
            self._identification = value

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def location(self):
        return self._location

    @location.setter
    def location(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcurireference):
                self._location = ifcurireference(value)
            else:
                self._location = value
        else:
            self._location = value

    @property
    def purpose(self):
        return self._purpose

    @purpose.setter
    def purpose(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._purpose = ifctext(value)
            else:
                self._purpose = value
        else:
            self._purpose = value

    @property
    def intendeduse(self):
        return self._intendeduse

    @intendeduse.setter
    def intendeduse(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._intendeduse = ifctext(value)
            else:
                self._intendeduse = value
        else:
            self._intendeduse = value

    @property
    def scope(self):
        return self._scope

    @scope.setter
    def scope(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._scope = ifctext(value)
            else:
                self._scope = value
        else:
            self._scope = value

    @property
    def revision(self):
        return self._revision

    @revision.setter
    def revision(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._revision = ifclabel(value)
            else:
                self._revision = value
        else:
            self._revision = value

    @property
    def documentowner(self):
        return self._documentowner

    @documentowner.setter
    def documentowner(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcactorselect):
                self._documentowner = ifcactorselect(value)
            else:
                self._documentowner = value
        else:
            self._documentowner = value

    @property
    def editors(self):
        return self._editors

    @editors.setter
    def editors(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'ifcactorselect', scope=schema_scope)):
                self._editors = SET(value)
            else:
                self._editors = value
        else:
            self._editors = value

    @property
    def creationtime(self):
        return self._creationtime

    @creationtime.setter
    def creationtime(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._creationtime = ifcdatetime(value)
            else:
                self._creationtime = value
        else:
            self._creationtime = value

    @property
    def lastrevisiontime(self):
        return self._lastrevisiontime

    @lastrevisiontime.setter
    def lastrevisiontime(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._lastrevisiontime = ifcdatetime(value)
            else:
                self._lastrevisiontime = value
        else:
            self._lastrevisiontime = value

    @property
    def electronicformat(self):
        return self._electronicformat

    @electronicformat.setter
    def electronicformat(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._electronicformat = ifcidentifier(value)
            else:
                self._electronicformat = value
        else:
            self._electronicformat = value

    @property
    def validfrom(self):
        return self._validfrom

    @validfrom.setter
    def validfrom(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdate):
                self._validfrom = ifcdate(value)
            else:
                self._validfrom = value
        else:
            self._validfrom = value

    @property
    def validuntil(self):
        return self._validuntil

    @validuntil.setter
    def validuntil(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdate):
                self._validuntil = ifcdate(value)
            else:
                self._validuntil = value
        else:
            self._validuntil = value

    @property
    def confidentiality(self):
        return self._confidentiality

    @confidentiality.setter
    def confidentiality(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdocumentconfidentialityenum):
                self._confidentiality = ifcdocumentconfidentialityenum(value)
            else:
                self._confidentiality = value
        else:
            self._confidentiality = value

    @property
    def status(self):
        return self._status

    @status.setter
    def status(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdocumentstatusenum):
                self._status = ifcdocumentstatusenum(value)
            else:
                self._status = value
        else:
            self._status = value

    @property
    def documentinfoforobjects(self):
        return self._documentinfoforobjects

    @documentinfoforobjects.setter
    def documentinfoforobjects(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument documentinfoforobjects is INVERSE. It is computed and can not be set to any value')

    @property
    def hasdocumentreferences(self):
        return self._hasdocumentreferences

    @hasdocumentreferences.setter
    def hasdocumentreferences(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument hasdocumentreferences is INVERSE. It is computed and can not be set to any value')

    @property
    def ispointedto(self):
        return self._ispointedto

    @ispointedto.setter
    def ispointedto(self, value):
        # INVERSE argument
        raise AssertionError('Argument ispointedto is INVERSE. It is computed and can not be set to any value')

    @property
    def ispointer(self):
        return self._ispointer

    @ispointer.setter
    def ispointer(self, value):
        # INVERSE argument
        raise AssertionError('Argument ispointer is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifclightsourcepositional #
####################
class ifclightsourcepositional(ifclightsource):
    '''Entity ifclightsourcepositional definition.

	:param position
	:type position:ifccartesianpoint

	:param radius
	:type radius:ifcpositivelengthmeasure

	:param constantattenuation
	:type constantattenuation:ifcreal

	:param distanceattenuation
	:type distanceattenuation:ifcreal

	:param quadricattenuation
	:type quadricattenuation:ifcreal
	'''

    def __init__(self, inherited0__name, inherited1__lightcolour, inherited2__ambientintensity, inherited3__intensity,
                 position, radius, constantattenuation, distanceattenuation, quadricattenuation, ):
        ifclightsource.__init__(self, inherited0__name, inherited1__lightcolour, inherited2__ambientintensity,
                                inherited3__intensity, )
        self._position = position
        self._radius = radius
        self._constantattenuation = constantattenuation
        self._distanceattenuation = distanceattenuation
        self._quadricattenuation = quadricattenuation

    @property
    def position(self):
        return self._position

    @position.setter
    def position(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccartesianpoint):
            self._position = ifccartesianpoint(value)
        else:
            self._position = value

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._radius = ifcpositivelengthmeasure(value)
        else:
            self._radius = value

    @property
    def constantattenuation(self):
        return self._constantattenuation

    @constantattenuation.setter
    def constantattenuation(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcreal):
            self._constantattenuation = ifcreal(value)
        else:
            self._constantattenuation = value

    @property
    def distanceattenuation(self):
        return self._distanceattenuation

    @distanceattenuation.setter
    def distanceattenuation(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcreal):
            self._distanceattenuation = ifcreal(value)
        else:
            self._distanceattenuation = value

    @property
    def quadricattenuation(self):
        return self._quadricattenuation

    @quadricattenuation.setter
    def quadricattenuation(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcreal):
            self._quadricattenuation = ifcreal(value)
        else:
            self._quadricattenuation = value


####################
# ENTITY ifclightsourcespot #
####################
class ifclightsourcespot(ifclightsourcepositional):
    '''Entity ifclightsourcespot definition.

	:param orientation
	:type orientation:ifcdirection

	:param concentrationexponent
	:type concentrationexponent:ifcreal

	:param spreadangle
	:type spreadangle:ifcpositiveplaneanglemeasure

	:param beamwidthangle
	:type beamwidthangle:ifcpositiveplaneanglemeasure
	'''

    def __init__(self, inherited0__name, inherited1__lightcolour, inherited2__ambientintensity, inherited3__intensity,
                 inherited4__position, inherited5__radius, inherited6__constantattenuation,
                 inherited7__distanceattenuation, inherited8__quadricattenuation, orientation, concentrationexponent,
                 spreadangle, beamwidthangle, ):
        ifclightsourcepositional.__init__(self, inherited0__name, inherited1__lightcolour, inherited2__ambientintensity,
                                          inherited3__intensity, inherited4__position, inherited5__radius,
                                          inherited6__constantattenuation, inherited7__distanceattenuation,
                                          inherited8__quadricattenuation, )
        self._orientation = orientation
        self._concentrationexponent = concentrationexponent
        self._spreadangle = spreadangle
        self._beamwidthangle = beamwidthangle

    @property
    def orientation(self):
        return self._orientation

    @orientation.setter
    def orientation(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdirection):
            self._orientation = ifcdirection(value)
        else:
            self._orientation = value

    @property
    def concentrationexponent(self):
        return self._concentrationexponent

    @concentrationexponent.setter
    def concentrationexponent(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreal):
                self._concentrationexponent = ifcreal(value)
            else:
                self._concentrationexponent = value
        else:
            self._concentrationexponent = value

    @property
    def spreadangle(self):
        return self._spreadangle

    @spreadangle.setter
    def spreadangle(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositiveplaneanglemeasure):
            self._spreadangle = ifcpositiveplaneanglemeasure(value)
        else:
            self._spreadangle = value

    @property
    def beamwidthangle(self):
        return self._beamwidthangle

    @beamwidthangle.setter
    def beamwidthangle(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositiveplaneanglemeasure):
            self._beamwidthangle = ifcpositiveplaneanglemeasure(value)
        else:
            self._beamwidthangle = value


####################
# ENTITY ifcplate #
####################
class ifcplate(ifcbuildingelement):
    '''Entity ifcplate definition.

	:param predefinedtype
	:type predefinedtype:ifcplatetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplatetypeenum):
                self._predefinedtype = ifcplatetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcplatetypeenum.userdefined)) or (
                        (self.predefinedtype == ifcplatetypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCPLATETYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcplatestandardcase #
####################
class ifcplatestandardcase(ifcplate):
    '''Entity ifcplatestandardcase definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__predefinedtype, ):
        ifcplate.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                          inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                          inherited6__representation, inherited7__tag, inherited8__predefinedtype, )

    def hasmateriallayersetusage(self):
        eval_hasmateriallayersetusage_wr = (SIZEOF(None) == 1)
        if not eval_hasmateriallayersetusage_wr:
            raise AssertionError('Rule hasmateriallayersetusage violated')
        else:
            return eval_hasmateriallayersetusage_wr


####################
# ENTITY ifcquantityarea #
####################
class ifcquantityarea(ifcphysicalsimplequantity):
    '''Entity ifcquantityarea definition.

	:param areavalue
	:type areavalue:ifcareameasure

	:param formula
	:type formula:ifclabel
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__unit, areavalue, formula, ):
        ifcphysicalsimplequantity.__init__(self, inherited0__name, inherited1__description, inherited2__unit, )
        self._areavalue = areavalue
        self._formula = formula

    @property
    def areavalue(self):
        return self._areavalue

    @areavalue.setter
    def areavalue(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcareameasure):
            self._areavalue = ifcareameasure(value)
        else:
            self._areavalue = value

    @property
    def formula(self):
        return self._formula

    @formula.setter
    def formula(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._formula = ifclabel(value)
            else:
                self._formula = value
        else:
            self._formula = value

    def wr21(self):
        eval_wr21_wr = ((not EXISTS(self.self.ifcphysicalsimplequantity.self.unit)) or (
                    self.self.ifcphysicalsimplequantity.self.unit.self.unittype == ifcunitenum.areaunit))
        if not eval_wr21_wr:
            raise AssertionError('Rule wr21 violated')
        else:
            return eval_wr21_wr

    def wr22(self):
        eval_wr22_wr = (self.areavalue >= 0)
        if not eval_wr22_wr:
            raise AssertionError('Rule wr22 violated')
        else:
            return eval_wr22_wr


####################
# ENTITY ifcrelassignstoproduct #
####################
class ifcrelassignstoproduct(ifcrelassigns):
    '''Entity ifcrelassignstoproduct definition.

	:param relatingproduct
	:type relatingproduct:ifcproductselect
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatedobjects, inherited5__relatedobjectstype, relatingproduct, ):
        ifcrelassigns.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                               inherited3__description, inherited4__relatedobjects, inherited5__relatedobjectstype, )
        self._relatingproduct = relatingproduct

    @property
    def relatingproduct(self):
        return self._relatingproduct

    @relatingproduct.setter
    def relatingproduct(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcproductselect):
            self._relatingproduct = ifcproductselect(value)
        else:
            self._relatingproduct = value

    def noselfreference(self):
        eval_noselfreference_wr = (SIZEOF(None) == 0)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifcalignment2dversegcirculararc #
####################
class ifcalignment2dversegcirculararc(ifcalignment2dverticalsegment):
    '''Entity ifcalignment2dversegcirculararc definition.

	:param radius
	:type radius:ifcpositivelengthmeasure

	:param isconvex
	:type isconvex:ifcboolean
	'''

    def __init__(self, inherited0__tangentialcontinuity, inherited1__starttag, inherited2__endtag,
                 inherited3__startdistalong, inherited4__horizontallength, inherited5__startheight,
                 inherited6__startgradient, radius, isconvex, ):
        ifcalignment2dverticalsegment.__init__(self, inherited0__tangentialcontinuity, inherited1__starttag,
                                               inherited2__endtag, inherited3__startdistalong,
                                               inherited4__horizontallength, inherited5__startheight,
                                               inherited6__startgradient, )
        self._radius = radius
        self._isconvex = isconvex

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._radius = ifcpositivelengthmeasure(value)
        else:
            self._radius = value

    @property
    def isconvex(self):
        return self._isconvex

    @isconvex.setter
    def isconvex(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._isconvex = ifcboolean(value)
        else:
            self._isconvex = value


####################
# ENTITY ifcbuildingelementproxy #
####################
class ifcbuildingelementproxy(ifcbuildingelement):
    '''Entity ifcbuildingelementproxy definition.

	:param predefinedtype
	:type predefinedtype:ifcbuildingelementproxytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcbuildingelementproxytypeenum):
                self._predefinedtype = ifcbuildingelementproxytypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def hasobjectname(self):
        eval_hasobjectname_wr = EXISTS(self.self.ifcroot.self.name)
        if not eval_hasobjectname_wr:
            raise AssertionError('Rule hasobjectname violated')
        else:
            return eval_hasobjectname_wr

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcbuildingelementproxytypeenum.userdefined)) or ((
                                                                                                         self.predefinedtype == ifcbuildingelementproxytypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCBUILDINGELEMENTPROXYTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcstructuralloadtemperature #
####################
class ifcstructuralloadtemperature(ifcstructuralloadstatic):
    '''Entity ifcstructuralloadtemperature definition.

	:param deltatconstant
	:type deltatconstant:ifcthermodynamictemperaturemeasure

	:param deltaty
	:type deltaty:ifcthermodynamictemperaturemeasure

	:param deltatz
	:type deltatz:ifcthermodynamictemperaturemeasure
	'''

    def __init__(self, inherited0__name, deltatconstant, deltaty, deltatz, ):
        ifcstructuralloadstatic.__init__(self, inherited0__name, )
        self._deltatconstant = deltatconstant
        self._deltaty = deltaty
        self._deltatz = deltatz

    @property
    def deltatconstant(self):
        return self._deltatconstant

    @deltatconstant.setter
    def deltatconstant(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcthermodynamictemperaturemeasure):
                self._deltatconstant = ifcthermodynamictemperaturemeasure(value)
            else:
                self._deltatconstant = value
        else:
            self._deltatconstant = value

    @property
    def deltaty(self):
        return self._deltaty

    @deltaty.setter
    def deltaty(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcthermodynamictemperaturemeasure):
                self._deltaty = ifcthermodynamictemperaturemeasure(value)
            else:
                self._deltaty = value
        else:
            self._deltaty = value

    @property
    def deltatz(self):
        return self._deltatz

    @deltatz.setter
    def deltatz(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcthermodynamictemperaturemeasure):
                self._deltatz = ifcthermodynamictemperaturemeasure(value)
            else:
                self._deltatz = value
        else:
            self._deltatz = value


####################
# ENTITY ifcbsplinecurve #
####################
class ifcbsplinecurve(ifcboundedcurve):
    '''Entity ifcbsplinecurve definition.

	:param degree
	:type degree:ifcinteger

	:param controlpointslist
	:type controlpointslist:LIST(2,None,'ifccartesianpoint', scope = schema_scope)

	:param curveform
	:type curveform:ifcbsplinecurveform

	:param closedcurve
	:type closedcurve:ifclogical

	:param selfintersect
	:type selfintersect:ifclogical

	:param upperindexoncontrolpoints
	:type upperindexoncontrolpoints:ifcinteger

	:param controlpoints
	:type controlpoints:ARRAY(0,(null).upperindexoncontrolpoints,'ifccartesianpoint', scope = schema_scope)
	'''

    def __init__(self, degree, controlpointslist, curveform, closedcurve, selfintersect, ):
        ifcboundedcurve.__init__(self, )
        self._degree = degree
        self._controlpointslist = controlpointslist
        self._curveform = curveform
        self._closedcurve = closedcurve
        self._selfintersect = selfintersect

    @property
    def degree(self):
        return self._degree

    @degree.setter
    def degree(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcinteger):
            self._degree = ifcinteger(value)
        else:
            self._degree = value

    @property
    def controlpointslist(self):
        return self._controlpointslist

    @controlpointslist.setter
    def controlpointslist(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, 'ifccartesianpoint', scope=schema_scope)):
            self._controlpointslist = LIST(value)
        else:
            self._controlpointslist = value

    @property
    def curveform(self):
        return self._curveform

    @curveform.setter
    def curveform(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcbsplinecurveform):
            self._curveform = ifcbsplinecurveform(value)
        else:
            self._curveform = value

    @property
    def closedcurve(self):
        return self._closedcurve

    @closedcurve.setter
    def closedcurve(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclogical):
            self._closedcurve = ifclogical(value)
        else:
            self._closedcurve = value

    @property
    def selfintersect(self):
        return self._selfintersect

    @selfintersect.setter
    def selfintersect(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclogical):
            self._selfintersect = ifclogical(value)
        else:
            self._selfintersect = value

    @property
    def upperindexoncontrolpoints(self):
        attribute_eval = (SIZEOF(self.controlpointslist) - 1)
        return attribute_eval

    @upperindexoncontrolpoints.setter
    def upperindexoncontrolpoints(self, value):
        # DERIVED argument
        raise AssertionError(
            'Argument upperindexoncontrolpoints is DERIVED. It is computed and can not be set to any value')

    @property
    def controlpoints(self):
        attribute_eval = ifclisttoarray(self.controlpointslist, 0, self.upperindexoncontrolpoints)
        return attribute_eval

    @controlpoints.setter
    def controlpoints(self, value):
        # DERIVED argument
        raise AssertionError('Argument controlpoints is DERIVED. It is computed and can not be set to any value')

    def samedim(self):
        eval_samedim_wr = (SIZEOF(None) == 0)
        if not eval_samedim_wr:
            raise AssertionError('Rule samedim violated')
        else:
            return eval_samedim_wr


####################
# ENTITY ifcbsplinecurvewithknots #
####################
class ifcbsplinecurvewithknots(ifcbsplinecurve):
    '''Entity ifcbsplinecurvewithknots definition.

	:param knotmultiplicities
	:type knotmultiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param knots
	:type knots:LIST(2,None,'REAL', scope = schema_scope)

	:param knotspec
	:type knotspec:ifcknottype

	:param upperindexonknots
	:type upperindexonknots:ifcinteger
	'''

    def __init__(self, inherited0__degree, inherited1__controlpointslist, inherited2__curveform,
                 inherited3__closedcurve, inherited4__selfintersect, knotmultiplicities, knots, knotspec, ):
        ifcbsplinecurve.__init__(self, inherited0__degree, inherited1__controlpointslist, inherited2__curveform,
                                 inherited3__closedcurve, inherited4__selfintersect, )
        self._knotmultiplicities = knotmultiplicities
        self._knots = knots
        self._knotspec = knotspec

    @property
    def knotmultiplicities(self):
        return self._knotmultiplicities

    @knotmultiplicities.setter
    def knotmultiplicities(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, 'INTEGER', scope=schema_scope)):
            self._knotmultiplicities = LIST(value)
        else:
            self._knotmultiplicities = value

    @property
    def knots(self):
        return self._knots

    @knots.setter
    def knots(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, 'REAL', scope=schema_scope)):
            self._knots = LIST(value)
        else:
            self._knots = value

    @property
    def knotspec(self):
        return self._knotspec

    @knotspec.setter
    def knotspec(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcknottype):
            self._knotspec = ifcknottype(value)
        else:
            self._knotspec = value

    @property
    def upperindexonknots(self):
        attribute_eval = SIZEOF(self.knots)
        return attribute_eval

    @upperindexonknots.setter
    def upperindexonknots(self, value):
        # DERIVED argument
        raise AssertionError('Argument upperindexonknots is DERIVED. It is computed and can not be set to any value')

    def consistentbspline(self):
        eval_consistentbspline_wr = ifcconstraintsparambspline(self.degree, self.upperindexonknots,
                                                               self.upperindexoncontrolpoints, self.knotmultiplicities,
                                                               self.knots)
        if not eval_consistentbspline_wr:
            raise AssertionError('Rule consistentbspline violated')
        else:
            return eval_consistentbspline_wr

    def correspondingknotlists(self):
        eval_correspondingknotlists_wr = (SIZEOF(self.knotmultiplicities) == self.upperindexonknots)
        if not eval_correspondingknotlists_wr:
            raise AssertionError('Rule correspondingknotlists violated')
        else:
            return eval_correspondingknotlists_wr


####################
# ENTITY ifcrationalbsplinecurvewithknots #
####################
class ifcrationalbsplinecurvewithknots(ifcbsplinecurvewithknots):
    '''Entity ifcrationalbsplinecurvewithknots definition.

	:param weightsdata
	:type weightsdata:LIST(2,None,'REAL', scope = schema_scope)

	:param weights
	:type weights:ARRAY(0,(null).upperindexoncontrolpoints,'REAL', scope = schema_scope)
	'''

    def __init__(self, inherited0__degree, inherited1__controlpointslist, inherited2__curveform,
                 inherited3__closedcurve, inherited4__selfintersect, inherited5__knotmultiplicities, inherited6__knots,
                 inherited7__knotspec, weightsdata, ):
        ifcbsplinecurvewithknots.__init__(self, inherited0__degree, inherited1__controlpointslist,
                                          inherited2__curveform, inherited3__closedcurve, inherited4__selfintersect,
                                          inherited5__knotmultiplicities, inherited6__knots, inherited7__knotspec, )
        self._weightsdata = weightsdata

    @property
    def weightsdata(self):
        return self._weightsdata

    @weightsdata.setter
    def weightsdata(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, 'REAL', scope=schema_scope)):
            self._weightsdata = LIST(value)
        else:
            self._weightsdata = value

    @property
    def weights(self):
        attribute_eval = ifclisttoarray(self.weightsdata, 0, self.self.ifcbsplinecurve.self.upperindexoncontrolpoints)
        return attribute_eval

    @weights.setter
    def weights(self, value):
        # DERIVED argument
        raise AssertionError('Argument weights is DERIVED. It is computed and can not be set to any value')

    def samenumofweightsandpoints(self):
        eval_samenumofweightsandpoints_wr = (
                    SIZEOF(self.weightsdata) == SIZEOF(self.self.ifcbsplinecurve.self.controlpointslist))
        if not eval_samenumofweightsandpoints_wr:
            raise AssertionError('Rule samenumofweightsandpoints violated')
        else:
            return eval_samenumofweightsandpoints_wr

    def weightsgreaterzero(self):
        eval_weightsgreaterzero_wr = ifccurveweightspositive(self)
        if not eval_weightsgreaterzero_wr:
            raise AssertionError('Rule weightsgreaterzero violated')
        else:
            return eval_weightsgreaterzero_wr


####################
# ENTITY ifcpropertydependencyrelationship #
####################
class ifcpropertydependencyrelationship(ifcresourcelevelrelationship):
    '''Entity ifcpropertydependencyrelationship definition.

	:param dependingproperty
	:type dependingproperty:ifcproperty

	:param dependantproperty
	:type dependantproperty:ifcproperty

	:param expression
	:type expression:ifctext
	'''

    def __init__(self, inherited0__name, inherited1__description, dependingproperty, dependantproperty, expression, ):
        ifcresourcelevelrelationship.__init__(self, inherited0__name, inherited1__description, )
        self._dependingproperty = dependingproperty
        self._dependantproperty = dependantproperty
        self._expression = expression

    @property
    def dependingproperty(self):
        return self._dependingproperty

    @dependingproperty.setter
    def dependingproperty(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcproperty):
            self._dependingproperty = ifcproperty(value)
        else:
            self._dependingproperty = value

    @property
    def dependantproperty(self):
        return self._dependantproperty

    @dependantproperty.setter
    def dependantproperty(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcproperty):
            self._dependantproperty = ifcproperty(value)
        else:
            self._dependantproperty = value

    @property
    def expression(self):
        return self._expression

    @expression.setter
    def expression(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._expression = ifctext(value)
            else:
                self._expression = value
        else:
            self._expression = value

    def noselfreference(self):
        eval_noselfreference_wr = (self.dependingproperty != self.dependantproperty)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifcswitchingdevice #
####################
class ifcswitchingdevice(ifcflowcontroller):
    '''Entity ifcswitchingdevice definition.

	:param predefinedtype
	:type predefinedtype:ifcswitchingdevicetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowcontroller.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcswitchingdevicetypeenum):
                self._predefinedtype = ifcswitchingdevicetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcswitchingdevicetypeenum.userdefined)) or ((
                                                                                                    self.predefinedtype == ifcswitchingdevicetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCSWITCHINGDEVICETYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcchimneytype #
####################
class ifcchimneytype(ifcbuildingelementtype):
    '''Entity ifcchimneytype definition.

	:param predefinedtype
	:type predefinedtype:ifcchimneytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcchimneytypeenum):
            self._predefinedtype = ifcchimneytypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcchimneytypeenum.userdefined) or (
                    (self.predefinedtype == ifcchimneytypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcboundingbox #
####################
class ifcboundingbox(ifcgeometricrepresentationitem):
    '''Entity ifcboundingbox definition.

	:param corner
	:type corner:ifccartesianpoint

	:param xdim
	:type xdim:ifcpositivelengthmeasure

	:param ydim
	:type ydim:ifcpositivelengthmeasure

	:param zdim
	:type zdim:ifcpositivelengthmeasure

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, corner, xdim, ydim, zdim, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._corner = corner
        self._xdim = xdim
        self._ydim = ydim
        self._zdim = zdim

    @property
    def corner(self):
        return self._corner

    @corner.setter
    def corner(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccartesianpoint):
            self._corner = ifccartesianpoint(value)
        else:
            self._corner = value

    @property
    def xdim(self):
        return self._xdim

    @xdim.setter
    def xdim(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._xdim = ifcpositivelengthmeasure(value)
        else:
            self._xdim = value

    @property
    def ydim(self):
        return self._ydim

    @ydim.setter
    def ydim(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._ydim = ifcpositivelengthmeasure(value)
        else:
            self._ydim = value

    @property
    def zdim(self):
        return self._zdim

    @zdim.setter
    def zdim(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._zdim = ifcpositivelengthmeasure(value)
        else:
            self._zdim = value

    @property
    def dim(self):
        attribute_eval = 3
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifccolourrgblist #
####################
class ifccolourrgblist(ifcpresentationitem):
    '''Entity ifccolourrgblist definition.

	:param colourlist
	:type colourlist:LIST(1,None,LIST(3,3,'REAL', scope = schema_scope))
	'''

    def __init__(self, colourlist, ):
        ifcpresentationitem.__init__(self, )
        self._colourlist = colourlist

    @property
    def colourlist(self):
        return self._colourlist

    @colourlist.setter
    def colourlist(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, LIST(3, 3, 'REAL', scope=schema_scope))):
            self._colourlist = LIST(value)
        else:
            self._colourlist = value


####################
# ENTITY ifcpath #
####################
class ifcpath(ifctopologicalrepresentationitem):
    '''Entity ifcpath definition.

	:param edgelist
	:type edgelist:LIST(1,None,'ifcorientededge', scope = schema_scope)
	'''

    def __init__(self, edgelist, ):
        ifctopologicalrepresentationitem.__init__(self, )
        self._edgelist = edgelist

    @property
    def edgelist(self):
        return self._edgelist

    @edgelist.setter
    def edgelist(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcorientededge', scope=schema_scope)):
            self._edgelist = LIST(value)
        else:
            self._edgelist = value

    def iscontinuous(self):
        eval_iscontinuous_wr = ifcpathheadtotail(self)
        if not eval_iscontinuous_wr:
            raise AssertionError('Rule iscontinuous violated')
        else:
            return eval_iscontinuous_wr


####################
# ENTITY ifcpropertyenumeratedvalue #
####################
class ifcpropertyenumeratedvalue(ifcsimpleproperty):
    '''Entity ifcpropertyenumeratedvalue definition.

	:param enumerationvalues
	:type enumerationvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param enumerationreference
	:type enumerationreference:ifcpropertyenumeration
	'''

    def __init__(self, inherited0__name, inherited1__description, enumerationvalues, enumerationreference, ):
        ifcsimpleproperty.__init__(self, inherited0__name, inherited1__description, )
        self._enumerationvalues = enumerationvalues
        self._enumerationreference = enumerationreference

    @property
    def enumerationvalues(self):
        return self._enumerationvalues

    @enumerationvalues.setter
    def enumerationvalues(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcvalue', scope=schema_scope)):
                self._enumerationvalues = LIST(value)
            else:
                self._enumerationvalues = value
        else:
            self._enumerationvalues = value

    @property
    def enumerationreference(self):
        return self._enumerationreference

    @enumerationreference.setter
    def enumerationreference(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpropertyenumeration):
                self._enumerationreference = ifcpropertyenumeration(value)
            else:
                self._enumerationreference = value
        else:
            self._enumerationreference = value

    def wr21(self):
        eval_wr21_wr = (((not EXISTS(self.enumerationreference)) or (not EXISTS(self.enumerationvalues))) or (
                    SIZEOF(None) == SIZEOF(self.enumerationvalues)))
        if not eval_wr21_wr:
            raise AssertionError('Rule wr21 violated')
        else:
            return eval_wr21_wr


####################
# ENTITY ifcsweptsurface #
####################
class ifcsweptsurface(ifcsurface):
    '''Entity ifcsweptsurface definition.

	:param sweptcurve
	:type sweptcurve:ifcprofiledef

	:param position
	:type position:ifcaxis2placement3d
	'''

    def __init__(self, sweptcurve, position, ):
        ifcsurface.__init__(self, )
        self._sweptcurve = sweptcurve
        self._position = position

    @property
    def sweptcurve(self):
        return self._sweptcurve

    @sweptcurve.setter
    def sweptcurve(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprofiledef):
            self._sweptcurve = ifcprofiledef(value)
        else:
            self._sweptcurve = value

    @property
    def position(self):
        return self._position

    @position.setter
    def position(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcaxis2placement3d):
                self._position = ifcaxis2placement3d(value)
            else:
                self._position = value
        else:
            self._position = value

    def sweptcurvetype(self):
        eval_sweptcurvetype_wr = (self.sweptcurve.self.profiletype == ifcprofiletypeenum.curve)
        if not eval_sweptcurvetype_wr:
            raise AssertionError('Rule sweptcurvetype violated')
        else:
            return eval_sweptcurvetype_wr


####################
# ENTITY ifcsurfaceofrevolution #
####################
class ifcsurfaceofrevolution(ifcsweptsurface):
    '''Entity ifcsurfaceofrevolution definition.

	:param axisposition
	:type axisposition:ifcaxis1placement

	:param axisline
	:type axisline:ifcline
	'''

    def __init__(self, inherited0__sweptcurve, inherited1__position, axisposition, ):
        ifcsweptsurface.__init__(self, inherited0__sweptcurve, inherited1__position, )
        self._axisposition = axisposition

    @property
    def axisposition(self):
        return self._axisposition

    @axisposition.setter
    def axisposition(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcaxis1placement):
            self._axisposition = ifcaxis1placement(value)
        else:
            self._axisposition = value

    @property
    def axisline(self):
        attribute_eval = (((ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifccurve()) == ifcline(
            self.axisposition.self.location,
            (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcvector(self.axisposition.self.z, 1)))
        return attribute_eval

    @axisline.setter
    def axisline(self, value):
        # DERIVED argument
        raise AssertionError('Argument axisline is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcmechanicalfastenertype #
####################
class ifcmechanicalfastenertype(ifcelementcomponenttype):
    '''Entity ifcmechanicalfastenertype definition.

	:param predefinedtype
	:type predefinedtype:ifcmechanicalfastenertypeenum

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param nominallength
	:type nominallength:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, nominaldiameter, nominallength, ):
        ifcelementcomponenttype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__applicableoccurrence,
                                         inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                         inherited8__elementtype, )
        self._predefinedtype = predefinedtype
        self._nominaldiameter = nominaldiameter
        self._nominallength = nominallength

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmechanicalfastenertypeenum):
            self._predefinedtype = ifcmechanicalfastenertypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def nominaldiameter(self):
        return self._nominaldiameter

    @nominaldiameter.setter
    def nominaldiameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._nominaldiameter = ifcpositivelengthmeasure(value)
            else:
                self._nominaldiameter = value
        else:
            self._nominaldiameter = value

    @property
    def nominallength(self):
        return self._nominallength

    @nominallength.setter
    def nominallength(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._nominallength = ifcpositivelengthmeasure(value)
            else:
                self._nominallength = value
        else:
            self._nominallength = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcmechanicalfastenertypeenum.userdefined) or (
                    (self.predefinedtype == ifcmechanicalfastenertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcprotectivedevice #
####################
class ifcprotectivedevice(ifcflowcontroller):
    '''Entity ifcprotectivedevice definition.

	:param predefinedtype
	:type predefinedtype:ifcprotectivedevicetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowcontroller.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcprotectivedevicetypeenum):
                self._predefinedtype = ifcprotectivedevicetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcprotectivedevicetypeenum.userdefined)) or ((
                                                                                                     self.predefinedtype == ifcprotectivedevicetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCPROTECTIVEDEVICETYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcrailing #
####################
class ifcrailing(ifcbuildingelement):
    '''Entity ifcrailing definition.

	:param predefinedtype
	:type predefinedtype:ifcrailingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcrailingtypeenum):
                self._predefinedtype = ifcrailingtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcrailingtypeenum.userdefined)) or (
                        (self.predefinedtype == ifcrailingtypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCRAILINGTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcbsplinesurface #
####################
class ifcbsplinesurface(ifcboundedsurface):
    '''Entity ifcbsplinesurface definition.

	:param udegree
	:type udegree:ifcinteger

	:param vdegree
	:type vdegree:ifcinteger

	:param controlpointslist
	:type controlpointslist:LIST(2,None,LIST(2,None,'ifccartesianpoint', scope = schema_scope))

	:param surfaceform
	:type surfaceform:ifcbsplinesurfaceform

	:param uclosed
	:type uclosed:ifclogical

	:param vclosed
	:type vclosed:ifclogical

	:param selfintersect
	:type selfintersect:ifclogical

	:param uupper
	:type uupper:ifcinteger

	:param vupper
	:type vupper:ifcinteger

	:param controlpoints
	:type controlpoints:ARRAY(0,(null).uupper,ARRAY(0,(null).vupper,'ifccartesianpoint', scope = schema_scope))
	'''

    def __init__(self, udegree, vdegree, controlpointslist, surfaceform, uclosed, vclosed, selfintersect, ):
        ifcboundedsurface.__init__(self, )
        self._udegree = udegree
        self._vdegree = vdegree
        self._controlpointslist = controlpointslist
        self._surfaceform = surfaceform
        self._uclosed = uclosed
        self._vclosed = vclosed
        self._selfintersect = selfintersect

    @property
    def udegree(self):
        return self._udegree

    @udegree.setter
    def udegree(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcinteger):
            self._udegree = ifcinteger(value)
        else:
            self._udegree = value

    @property
    def vdegree(self):
        return self._vdegree

    @vdegree.setter
    def vdegree(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcinteger):
            self._vdegree = ifcinteger(value)
        else:
            self._vdegree = value

    @property
    def controlpointslist(self):
        return self._controlpointslist

    @controlpointslist.setter
    def controlpointslist(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, LIST(2, None, 'ifccartesianpoint', scope=schema_scope))):
            self._controlpointslist = LIST(value)
        else:
            self._controlpointslist = value

    @property
    def surfaceform(self):
        return self._surfaceform

    @surfaceform.setter
    def surfaceform(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcbsplinesurfaceform):
            self._surfaceform = ifcbsplinesurfaceform(value)
        else:
            self._surfaceform = value

    @property
    def uclosed(self):
        return self._uclosed

    @uclosed.setter
    def uclosed(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclogical):
            self._uclosed = ifclogical(value)
        else:
            self._uclosed = value

    @property
    def vclosed(self):
        return self._vclosed

    @vclosed.setter
    def vclosed(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclogical):
            self._vclosed = ifclogical(value)
        else:
            self._vclosed = value

    @property
    def selfintersect(self):
        return self._selfintersect

    @selfintersect.setter
    def selfintersect(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclogical):
            self._selfintersect = ifclogical(value)
        else:
            self._selfintersect = value

    @property
    def uupper(self):
        attribute_eval = (SIZEOF(self.controlpointslist) - 1)
        return attribute_eval

    @uupper.setter
    def uupper(self, value):
        # DERIVED argument
        raise AssertionError('Argument uupper is DERIVED. It is computed and can not be set to any value')

    @property
    def vupper(self):
        attribute_eval = (SIZEOF(self.controlpointslist[1]) - 1)
        return attribute_eval

    @vupper.setter
    def vupper(self, value):
        # DERIVED argument
        raise AssertionError('Argument vupper is DERIVED. It is computed and can not be set to any value')

    @property
    def controlpoints(self):
        attribute_eval = ifcmakearrayofarray(self.controlpointslist, 0, self.uupper, 0, self.vupper)
        return attribute_eval

    @controlpoints.setter
    def controlpoints(self, value):
        # DERIVED argument
        raise AssertionError('Argument controlpoints is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcbsplinesurfacewithknots #
####################
class ifcbsplinesurfacewithknots(ifcbsplinesurface):
    '''Entity ifcbsplinesurfacewithknots definition.

	:param umultiplicities
	:type umultiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param vmultiplicities
	:type vmultiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param uknots
	:type uknots:LIST(2,None,'REAL', scope = schema_scope)

	:param vknots
	:type vknots:LIST(2,None,'REAL', scope = schema_scope)

	:param knotspec
	:type knotspec:ifcknottype

	:param knotvupper
	:type knotvupper:ifcinteger

	:param knotuupper
	:type knotuupper:ifcinteger
	'''

    def __init__(self, inherited0__udegree, inherited1__vdegree, inherited2__controlpointslist, inherited3__surfaceform,
                 inherited4__uclosed, inherited5__vclosed, inherited6__selfintersect, umultiplicities, vmultiplicities,
                 uknots, vknots, knotspec, ):
        ifcbsplinesurface.__init__(self, inherited0__udegree, inherited1__vdegree, inherited2__controlpointslist,
                                   inherited3__surfaceform, inherited4__uclosed, inherited5__vclosed,
                                   inherited6__selfintersect, )
        self._umultiplicities = umultiplicities
        self._vmultiplicities = vmultiplicities
        self._uknots = uknots
        self._vknots = vknots
        self._knotspec = knotspec

    @property
    def umultiplicities(self):
        return self._umultiplicities

    @umultiplicities.setter
    def umultiplicities(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, 'INTEGER', scope=schema_scope)):
            self._umultiplicities = LIST(value)
        else:
            self._umultiplicities = value

    @property
    def vmultiplicities(self):
        return self._vmultiplicities

    @vmultiplicities.setter
    def vmultiplicities(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, 'INTEGER', scope=schema_scope)):
            self._vmultiplicities = LIST(value)
        else:
            self._vmultiplicities = value

    @property
    def uknots(self):
        return self._uknots

    @uknots.setter
    def uknots(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, 'REAL', scope=schema_scope)):
            self._uknots = LIST(value)
        else:
            self._uknots = value

    @property
    def vknots(self):
        return self._vknots

    @vknots.setter
    def vknots(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, 'REAL', scope=schema_scope)):
            self._vknots = LIST(value)
        else:
            self._vknots = value

    @property
    def knotspec(self):
        return self._knotspec

    @knotspec.setter
    def knotspec(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcknottype):
            self._knotspec = ifcknottype(value)
        else:
            self._knotspec = value

    @property
    def knotvupper(self):
        attribute_eval = SIZEOF(self.vknots)
        return attribute_eval

    @knotvupper.setter
    def knotvupper(self, value):
        # DERIVED argument
        raise AssertionError('Argument knotvupper is DERIVED. It is computed and can not be set to any value')

    @property
    def knotuupper(self):
        attribute_eval = SIZEOF(self.uknots)
        return attribute_eval

    @knotuupper.setter
    def knotuupper(self, value):
        # DERIVED argument
        raise AssertionError('Argument knotuupper is DERIVED. It is computed and can not be set to any value')

    def udirectionconstraints(self):
        eval_udirectionconstraints_wr = ifcconstraintsparambspline(self.self.ifcbsplinesurface.self.udegree,
                                                                   self.knotuupper,
                                                                   self.self.ifcbsplinesurface.self.uupper,
                                                                   self.umultiplicities, self.uknots)
        if not eval_udirectionconstraints_wr:
            raise AssertionError('Rule udirectionconstraints violated')
        else:
            return eval_udirectionconstraints_wr

    def vdirectionconstraints(self):
        eval_vdirectionconstraints_wr = ifcconstraintsparambspline(self.self.ifcbsplinesurface.self.vdegree,
                                                                   self.knotvupper,
                                                                   self.self.ifcbsplinesurface.self.vupper,
                                                                   self.vmultiplicities, self.vknots)
        if not eval_vdirectionconstraints_wr:
            raise AssertionError('Rule vdirectionconstraints violated')
        else:
            return eval_vdirectionconstraints_wr

    def correspondingulists(self):
        eval_correspondingulists_wr = (SIZEOF(self.umultiplicities) == self.knotuupper)
        if not eval_correspondingulists_wr:
            raise AssertionError('Rule correspondingulists violated')
        else:
            return eval_correspondingulists_wr

    def correspondingvlists(self):
        eval_correspondingvlists_wr = (SIZEOF(self.vmultiplicities) == self.knotvupper)
        if not eval_correspondingvlists_wr:
            raise AssertionError('Rule correspondingvlists violated')
        else:
            return eval_correspondingvlists_wr


####################
# ENTITY ifcrationalbsplinesurfacewithknots #
####################
class ifcrationalbsplinesurfacewithknots(ifcbsplinesurfacewithknots):
    '''Entity ifcrationalbsplinesurfacewithknots definition.

	:param weightsdata
	:type weightsdata:LIST(2,None,LIST(2,None,'REAL', scope = schema_scope))

	:param weights
	:type weights:ARRAY(0,(null).uupper,ARRAY(0,(null).vupper,'REAL', scope = schema_scope))
	'''

    def __init__(self, inherited0__udegree, inherited1__vdegree, inherited2__controlpointslist, inherited3__surfaceform,
                 inherited4__uclosed, inherited5__vclosed, inherited6__selfintersect, inherited7__umultiplicities,
                 inherited8__vmultiplicities, inherited9__uknots, inherited10__vknots, inherited11__knotspec,
                 weightsdata, ):
        ifcbsplinesurfacewithknots.__init__(self, inherited0__udegree, inherited1__vdegree,
                                            inherited2__controlpointslist, inherited3__surfaceform, inherited4__uclosed,
                                            inherited5__vclosed, inherited6__selfintersect, inherited7__umultiplicities,
                                            inherited8__vmultiplicities, inherited9__uknots, inherited10__vknots,
                                            inherited11__knotspec, )
        self._weightsdata = weightsdata

    @property
    def weightsdata(self):
        return self._weightsdata

    @weightsdata.setter
    def weightsdata(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, LIST(2, None, 'REAL', scope=schema_scope))):
            self._weightsdata = LIST(value)
        else:
            self._weightsdata = value

    @property
    def weights(self):
        attribute_eval = ifcmakearrayofarray(self.weightsdata, 0, self.uupper, 0, self.vupper)
        return attribute_eval

    @weights.setter
    def weights(self, value):
        # DERIVED argument
        raise AssertionError('Argument weights is DERIVED. It is computed and can not be set to any value')

    def correspondingweightsdatalists(self):
        eval_correspondingweightsdatalists_wr = (
                    (SIZEOF(self.weightsdata) == SIZEOF(self.self.ifcbsplinesurface.self.controlpointslist)) and (
                        SIZEOF(self.weightsdata[1]) == SIZEOF(self.self.ifcbsplinesurface.self.controlpointslist[1])))
        if not eval_correspondingweightsdatalists_wr:
            raise AssertionError('Rule correspondingweightsdatalists violated')
        else:
            return eval_correspondingweightsdatalists_wr

    def weightvaluesgreaterzero(self):
        eval_weightvaluesgreaterzero_wr = ifcsurfaceweightspositive(self)
        if not eval_weightvaluesgreaterzero_wr:
            raise AssertionError('Rule weightvaluesgreaterzero violated')
        else:
            return eval_weightvaluesgreaterzero_wr


####################
# ENTITY ifcapprovalrelationship #
####################
class ifcapprovalrelationship(ifcresourcelevelrelationship):
    '''Entity ifcapprovalrelationship definition.

	:param relatingapproval
	:type relatingapproval:ifcapproval

	:param relatedapprovals
	:type relatedapprovals:SET(1,None,'ifcapproval', scope = schema_scope)
	'''

    def __init__(self, inherited0__name, inherited1__description, relatingapproval, relatedapprovals, ):
        ifcresourcelevelrelationship.__init__(self, inherited0__name, inherited1__description, )
        self._relatingapproval = relatingapproval
        self._relatedapprovals = relatedapprovals

    @property
    def relatingapproval(self):
        return self._relatingapproval

    @relatingapproval.setter
    def relatingapproval(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcapproval):
            self._relatingapproval = ifcapproval(value)
        else:
            self._relatingapproval = value

    @property
    def relatedapprovals(self):
        return self._relatedapprovals

    @relatedapprovals.setter
    def relatedapprovals(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcapproval', scope=schema_scope)):
            self._relatedapprovals = SET(value)
        else:
            self._relatedapprovals = value


####################
# ENTITY ifcgridaxis #
####################
class ifcgridaxis(BaseEntityClass):
    '''Entity ifcgridaxis definition.

	:param axistag
	:type axistag:ifclabel

	:param axiscurve
	:type axiscurve:ifccurve

	:param samesense
	:type samesense:ifcboolean

	:param partofw
	:type partofw:SET(0,1,'ifcgrid', scope = schema_scope)

	:param partofv
	:type partofv:SET(0,1,'ifcgrid', scope = schema_scope)

	:param partofu
	:type partofu:SET(0,1,'ifcgrid', scope = schema_scope)

	:param hasintersections
	:type hasintersections:SET(0,None,'ifcvirtualgridintersection', scope = schema_scope)
	'''

    def __init__(self, axistag, axiscurve, samesense, ):
        self._axistag = axistag
        self._axiscurve = axiscurve
        self._samesense = samesense

    @property
    def axistag(self):
        return self._axistag

    @axistag.setter
    def axistag(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._axistag = ifclabel(value)
            else:
                self._axistag = value
        else:
            self._axistag = value

    @property
    def axiscurve(self):
        return self._axiscurve

    @axiscurve.setter
    def axiscurve(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._axiscurve = ifccurve(value)
        else:
            self._axiscurve = value

    @property
    def samesense(self):
        return self._samesense

    @samesense.setter
    def samesense(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._samesense = ifcboolean(value)
        else:
            self._samesense = value

    @property
    def partofw(self):
        return self._partofw

    @partofw.setter
    def partofw(self, value):
        # INVERSE argument
        raise AssertionError('Argument partofw is INVERSE. It is computed and can not be set to any value')

    @property
    def partofv(self):
        return self._partofv

    @partofv.setter
    def partofv(self, value):
        # INVERSE argument
        raise AssertionError('Argument partofv is INVERSE. It is computed and can not be set to any value')

    @property
    def partofu(self):
        return self._partofu

    @partofu.setter
    def partofu(self, value):
        # INVERSE argument
        raise AssertionError('Argument partofu is INVERSE. It is computed and can not be set to any value')

    @property
    def hasintersections(self):
        return self._hasintersections

    @hasintersections.setter
    def hasintersections(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasintersections is INVERSE. It is computed and can not be set to any value')

    def wr1(self):
        eval_wr1_wr = (self.axiscurve.self.dim == 2)
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr

    def wr2(self):
        eval_wr2_wr = ((SIZEOF(self.partofu) == 1) != (SIZEOF(self.partofv) == 1) != (SIZEOF(self.partofw) == 1))
        if not eval_wr2_wr:
            raise AssertionError('Rule wr2 violated')
        else:
            return eval_wr2_wr


####################
# ENTITY ifcreldecomposes #
####################
class ifcreldecomposes(ifcrelationship):
    '''Entity ifcreldecomposes definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description, ):
        ifcrelationship.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, )


####################
# ENTITY ifcrelnests #
####################
class ifcrelnests(ifcreldecomposes):
    '''Entity ifcrelnests definition.

	:param relatingobject
	:type relatingobject:ifcobjectdefinition

	:param relatedobjects
	:type relatedobjects:LIST(1,None,'ifcobjectdefinition', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingobject, relatedobjects, ):
        ifcreldecomposes.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                  inherited3__description, )
        self._relatingobject = relatingobject
        self._relatedobjects = relatedobjects

    @property
    def relatingobject(self):
        return self._relatingobject

    @relatingobject.setter
    def relatingobject(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcobjectdefinition):
            self._relatingobject = ifcobjectdefinition(value)
        else:
            self._relatingobject = value

    @property
    def relatedobjects(self):
        return self._relatedobjects

    @relatedobjects.setter
    def relatedobjects(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcobjectdefinition', scope=schema_scope)):
            self._relatedobjects = LIST(value)
        else:
            self._relatedobjects = value

    def noselfreference(self):
        eval_noselfreference_wr = (SIZEOF(None) == 0)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifcfurnishingelementtype #
####################
class ifcfurnishingelementtype(ifcelementtype):
    '''Entity ifcfurnishingelementtype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__representationmaps, inherited7__tag, inherited8__elementtype, )


####################
# ENTITY ifcmaterialdefinitionrepresentation #
####################
class ifcmaterialdefinitionrepresentation(ifcproductrepresentation):
    '''Entity ifcmaterialdefinitionrepresentation definition.

	:param representedmaterial
	:type representedmaterial:ifcmaterial
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__representations, representedmaterial, ):
        ifcproductrepresentation.__init__(self, inherited0__name, inherited1__description,
                                          inherited2__representations, )
        self._representedmaterial = representedmaterial

    @property
    def representedmaterial(self):
        return self._representedmaterial

    @representedmaterial.setter
    def representedmaterial(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmaterial):
            self._representedmaterial = ifcmaterial(value)
        else:
            self._representedmaterial = value

    def onlystyledrepresentations(self):
        eval_onlystyledrepresentations_wr = (SIZEOF(None) == 0)
        if not eval_onlystyledrepresentations_wr:
            raise AssertionError('Rule onlystyledrepresentations violated')
        else:
            return eval_onlystyledrepresentations_wr


####################
# ENTITY ifcmeasurewithunit #
####################
class ifcmeasurewithunit(BaseEntityClass):
    '''Entity ifcmeasurewithunit definition.

	:param valuecomponent
	:type valuecomponent:ifcvalue

	:param unitcomponent
	:type unitcomponent:ifcunit
	'''

    def __init__(self, valuecomponent, unitcomponent, ):
        self._valuecomponent = valuecomponent
        self._unitcomponent = unitcomponent

    @property
    def valuecomponent(self):
        return self._valuecomponent

    @valuecomponent.setter
    def valuecomponent(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcvalue):
            self._valuecomponent = ifcvalue(value)
        else:
            self._valuecomponent = value

    @property
    def unitcomponent(self):
        return self._unitcomponent

    @unitcomponent.setter
    def unitcomponent(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcunit):
            self._unitcomponent = ifcunit(value)
        else:
            self._unitcomponent = value


####################
# ENTITY ifcpolygonalfaceset #
####################
class ifcpolygonalfaceset(ifctessellatedfaceset):
    '''Entity ifcpolygonalfaceset definition.

	:param closed
	:type closed:ifcboolean

	:param faces
	:type faces:LIST(1,None,'ifcindexedpolygonalface', scope = schema_scope)

	:param pnindex
	:type pnindex:LIST(1,None,'INTEGER', scope = schema_scope)
	'''

    def __init__(self, inherited0__coordinates, closed, faces, pnindex, ):
        ifctessellatedfaceset.__init__(self, inherited0__coordinates, )
        self._closed = closed
        self._faces = faces
        self._pnindex = pnindex

    @property
    def closed(self):
        return self._closed

    @closed.setter
    def closed(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._closed = ifcboolean(value)
            else:
                self._closed = value
        else:
            self._closed = value

    @property
    def faces(self):
        return self._faces

    @faces.setter
    def faces(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcindexedpolygonalface', scope=schema_scope)):
            self._faces = LIST(value)
        else:
            self._faces = value

    @property
    def pnindex(self):
        return self._pnindex

    @pnindex.setter
    def pnindex(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'INTEGER', scope=schema_scope)):
                self._pnindex = LIST(value)
            else:
                self._pnindex = value
        else:
            self._pnindex = value


####################
# ENTITY ifccompressortype #
####################
class ifccompressortype(ifcflowmovingdevicetype):
    '''Entity ifccompressortype definition.

	:param predefinedtype
	:type predefinedtype:ifccompressortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowmovingdevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__applicableoccurrence,
                                         inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                         inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccompressortypeenum):
            self._predefinedtype = ifccompressortypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccompressortypeenum.userdefined) or (
                    (self.predefinedtype == ifccompressortypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcelectricdistributionboardtype #
####################
class ifcelectricdistributionboardtype(ifcflowcontrollertype):
    '''Entity ifcelectricdistributionboardtype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricdistributionboardtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowcontrollertype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__applicableoccurrence,
                                       inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                       inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelectricdistributionboardtypeenum):
            self._predefinedtype = ifcelectricdistributionboardtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcelectricdistributionboardtypeenum.userdefined) or (
                    (self.predefinedtype == ifcelectricdistributionboardtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifccircle #
####################
class ifccircle(ifcconic):
    '''Entity ifccircle definition.

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__position, radius, ):
        ifcconic.__init__(self, inherited0__position, )
        self._radius = radius

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._radius = ifcpositivelengthmeasure(value)
        else:
            self._radius = value


####################
# ENTITY ifclightfixture #
####################
class ifclightfixture(ifcflowterminal):
    '''Entity ifclightfixture definition.

	:param predefinedtype
	:type predefinedtype:ifclightfixturetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowterminal.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclightfixturetypeenum):
                self._predefinedtype = ifclightfixturetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifclightfixturetypeenum.userdefined)) or ((
                                                                                                 self.predefinedtype == ifclightfixturetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCLIGHTFIXTURETYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcrampflighttype #
####################
class ifcrampflighttype(ifcbuildingelementtype):
    '''Entity ifcrampflighttype definition.

	:param predefinedtype
	:type predefinedtype:ifcrampflighttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcrampflighttypeenum):
            self._predefinedtype = ifcrampflighttypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcrampflighttypeenum.userdefined) or (
                    (self.predefinedtype == ifcrampflighttypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifctransportelement #
####################
class ifctransportelement(ifcelement):
    '''Entity ifctransportelement definition.

	:param predefinedtype
	:type predefinedtype:ifctransportelementtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctransportelementtypeenum):
                self._predefinedtype = ifctransportelementtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifctransportelementtypeenum.userdefined)) or ((
                                                                                                     self.predefinedtype == ifctransportelementtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCTRANSPORTELEMENTTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcevaporativecoolertype #
####################
class ifcevaporativecoolertype(ifcenergyconversiondevicetype):
    '''Entity ifcevaporativecoolertype definition.

	:param predefinedtype
	:type predefinedtype:ifcevaporativecoolertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcevaporativecoolertypeenum):
            self._predefinedtype = ifcevaporativecoolertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcevaporativecoolertypeenum.userdefined) or (
                    (self.predefinedtype == ifcevaporativecoolertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcdeepfoundationtype #
####################
class ifcdeepfoundationtype(ifcbuildingelementtype):
    '''Entity ifcdeepfoundationtype definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )


####################
# ENTITY ifccaissonfoundationtype #
####################
class ifccaissonfoundationtype(ifcdeepfoundationtype):
    '''Entity ifccaissonfoundationtype definition.

	:param predefinedtype
	:type predefinedtype:ifccaissonfoundationtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcdeepfoundationtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__applicableoccurrence,
                                       inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                       inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccaissonfoundationtypeenum):
            self._predefinedtype = ifccaissonfoundationtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccaissonfoundationtypeenum.userdefined) or (
                    (self.predefinedtype == ifccaissonfoundationtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcpredefinedcurvefont #
####################
class ifcpredefinedcurvefont(ifcpredefineditem):
    '''Entity ifcpredefinedcurvefont definition.
	'''

    def __init__(self, inherited0__name, ):
        ifcpredefineditem.__init__(self, inherited0__name, )


####################
# ENTITY ifcdraughtingpredefinedcurvefont #
####################
class ifcdraughtingpredefinedcurvefont(ifcpredefinedcurvefont):
    '''Entity ifcdraughtingpredefinedcurvefont definition.
	'''

    def __init__(self, inherited0__name, ):
        ifcpredefinedcurvefont.__init__(self, inherited0__name, )

    def predefinedcurvefontnames(self):
        eval_predefinedcurvefontnames_wr = (
                    self.self.ifcpredefineditem.self.name == ['continuous', 'chain', 'chain double dash', 'dashed',
                                                              'dotted', 'by layer'])
        if not eval_predefinedcurvefontnames_wr:
            raise AssertionError('Rule predefinedcurvefontnames violated')
        else:
            return eval_predefinedcurvefontnames_wr


####################
# ENTITY ifcsweptareasolid #
####################
class ifcsweptareasolid(ifcsolidmodel):
    '''Entity ifcsweptareasolid definition.

	:param sweptarea
	:type sweptarea:ifcprofiledef

	:param position
	:type position:ifcaxis2placement3d
	'''

    def __init__(self, sweptarea, position, ):
        ifcsolidmodel.__init__(self, )
        self._sweptarea = sweptarea
        self._position = position

    @property
    def sweptarea(self):
        return self._sweptarea

    @sweptarea.setter
    def sweptarea(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprofiledef):
            self._sweptarea = ifcprofiledef(value)
        else:
            self._sweptarea = value

    @property
    def position(self):
        return self._position

    @position.setter
    def position(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcaxis2placement3d):
                self._position = ifcaxis2placement3d(value)
            else:
                self._position = value
        else:
            self._position = value

    def sweptareatype(self):
        eval_sweptareatype_wr = (self.sweptarea.self.profiletype == ifcprofiletypeenum.area)
        if not eval_sweptareatype_wr:
            raise AssertionError('Rule sweptareatype violated')
        else:
            return eval_sweptareatype_wr


####################
# ENTITY ifcextrudedareasolid #
####################
class ifcextrudedareasolid(ifcsweptareasolid):
    '''Entity ifcextrudedareasolid definition.

	:param extrudeddirection
	:type extrudeddirection:ifcdirection

	:param depth
	:type depth:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__sweptarea, inherited1__position, extrudeddirection, depth, ):
        ifcsweptareasolid.__init__(self, inherited0__sweptarea, inherited1__position, )
        self._extrudeddirection = extrudeddirection
        self._depth = depth

    @property
    def extrudeddirection(self):
        return self._extrudeddirection

    @extrudeddirection.setter
    def extrudeddirection(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdirection):
            self._extrudeddirection = ifcdirection(value)
        else:
            self._extrudeddirection = value

    @property
    def depth(self):
        return self._depth

    @depth.setter
    def depth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._depth = ifcpositivelengthmeasure(value)
        else:
            self._depth = value

    def validextrusiondirection(self):
        eval_validextrusiondirection_wr = (ifcdotproduct(
            (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection([0, 0, 1]),
            self.self.extrudeddirection) != 0)
        if not eval_validextrusiondirection_wr:
            raise AssertionError('Rule validextrusiondirection violated')
        else:
            return eval_validextrusiondirection_wr


####################
# ENTITY ifcreldefinesbyobject #
####################
class ifcreldefinesbyobject(ifcreldefines):
    '''Entity ifcreldefinesbyobject definition.

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcobject', scope = schema_scope)

	:param relatingobject
	:type relatingobject:ifcobject
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatedobjects, relatingobject, ):
        ifcreldefines.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                               inherited3__description, )
        self._relatedobjects = relatedobjects
        self._relatingobject = relatingobject

    @property
    def relatedobjects(self):
        return self._relatedobjects

    @relatedobjects.setter
    def relatedobjects(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcobject', scope=schema_scope)):
            self._relatedobjects = SET(value)
        else:
            self._relatedobjects = value

    @property
    def relatingobject(self):
        return self._relatingobject

    @relatingobject.setter
    def relatingobject(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcobject):
            self._relatingobject = ifcobject(value)
        else:
            self._relatingobject = value


####################
# ENTITY ifccrewresource #
####################
class ifccrewresource(ifcconstructionresource):
    '''Entity ifccrewresource definition.

	:param predefinedtype
	:type predefinedtype:ifccrewresourcetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, inherited6__longdescription, inherited7__usage,
                 inherited8__basecosts, inherited9__basequantity, predefinedtype, ):
        ifcconstructionresource.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__objecttype, inherited5__identification,
                                         inherited6__longdescription, inherited7__usage, inherited8__basecosts,
                                         inherited9__basequantity, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccrewresourcetypeenum):
                self._predefinedtype = ifccrewresourcetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifccrewresourcetypeenum.userdefined)) or ((
                                                                                                 self.predefinedtype == ifccrewresourcetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcsystemfurnitureelementtype #
####################
class ifcsystemfurnitureelementtype(ifcfurnishingelementtype):
    '''Entity ifcsystemfurnitureelementtype definition.

	:param predefinedtype
	:type predefinedtype:ifcsystemfurnitureelementtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcfurnishingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, inherited4__applicableoccurrence,
                                          inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                          inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsystemfurnitureelementtypeenum):
                self._predefinedtype = ifcsystemfurnitureelementtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcsystemfurnitureelementtypeenum.userdefined) or (
                    (self.predefinedtype == ifcsystemfurnitureelementtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcfooting #
####################
class ifcfooting(ifcbuildingelement):
    '''Entity ifcfooting definition.

	:param predefinedtype
	:type predefinedtype:ifcfootingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcfootingtypeenum):
                self._predefinedtype = ifcfootingtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcfootingtypeenum.userdefined)) or (
                        (self.predefinedtype == ifcfootingtypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCFOOTINGTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifclamp #
####################
class ifclamp(ifcflowterminal):
    '''Entity ifclamp definition.

	:param predefinedtype
	:type predefinedtype:ifclamptypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowterminal.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclamptypeenum):
                self._predefinedtype = ifclamptypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifclamptypeenum.userdefined)) or (
                        (self.predefinedtype == ifclamptypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCLAMPTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcprofileproperties #
####################
class ifcprofileproperties(ifcextendedproperties):
    '''Entity ifcprofileproperties definition.

	:param profiledefinition
	:type profiledefinition:ifcprofiledef
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__properties, profiledefinition, ):
        ifcextendedproperties.__init__(self, inherited0__name, inherited1__description, inherited2__properties, )
        self._profiledefinition = profiledefinition

    @property
    def profiledefinition(self):
        return self._profiledefinition

    @profiledefinition.setter
    def profiledefinition(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprofiledef):
            self._profiledefinition = ifcprofiledef(value)
        else:
            self._profiledefinition = value


####################
# ENTITY ifctendonconduit #
####################
class ifctendonconduit(ifcreinforcingelement):
    '''Entity ifctendonconduit definition.

	:param predefinedtype
	:type predefinedtype:ifctendonconduittypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__steelgrade, predefinedtype, ):
        ifcreinforcingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                       inherited6__representation, inherited7__tag, inherited8__steelgrade, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctendonconduittypeenum):
            self._predefinedtype = ifctendonconduittypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifctendonconduittypeenum.userdefined)) or ((
                                                                                                  self.predefinedtype == ifctendonconduittypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCTENDONCONDUITTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcsurfacefeature #
####################
class ifcsurfacefeature(ifcfeatureelement):
    '''Entity ifcsurfacefeature definition.

	:param predefinedtype
	:type predefinedtype:ifcsurfacefeaturetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcfeatureelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsurfacefeaturetypeenum):
                self._predefinedtype = ifcsurfacefeaturetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def hasobjecttype(self):
        eval_hasobjecttype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcsurfacefeaturetypeenum.userdefined)) or EXISTS(
            self.self.ifcobject.self.objecttype))
        if not eval_hasobjecttype_wr:
            raise AssertionError('Rule hasobjecttype violated')
        else:
            return eval_hasobjecttype_wr


####################
# ENTITY ifcvoidingfeature #
####################
class ifcvoidingfeature(ifcfeatureelementsubtraction):
    '''Entity ifcvoidingfeature definition.

	:param predefinedtype
	:type predefinedtype:ifcvoidingfeaturetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcfeatureelementsubtraction.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                              inherited3__description, inherited4__objecttype,
                                              inherited5__objectplacement, inherited6__representation,
                                              inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcvoidingfeaturetypeenum):
                self._predefinedtype = ifcvoidingfeaturetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def hasobjecttype(self):
        eval_hasobjecttype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcvoidingfeaturetypeenum.userdefined)) or EXISTS(
            self.self.ifcobject.self.objecttype))
        if not eval_hasobjecttype_wr:
            raise AssertionError('Rule hasobjecttype violated')
        else:
            return eval_hasobjecttype_wr


####################
# ENTITY ifccolumn #
####################
class ifccolumn(ifcbuildingelement):
    '''Entity ifccolumn definition.

	:param predefinedtype
	:type predefinedtype:ifccolumntypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccolumntypeenum):
                self._predefinedtype = ifccolumntypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifccolumntypeenum.userdefined)) or (
                        (self.predefinedtype == ifccolumntypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCOLUMNTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifccolumnstandardcase #
####################
class ifccolumnstandardcase(ifccolumn):
    '''Entity ifccolumnstandardcase definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__predefinedtype, ):
        ifccolumn.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                           inherited6__representation, inherited7__tag, inherited8__predefinedtype, )

    def hasmaterialprofilesetusage(self):
        eval_hasmaterialprofilesetusage_wr = (SIZEOF(None) == 1)
        if not eval_hasmaterialprofilesetusage_wr:
            raise AssertionError('Rule hasmaterialprofilesetusage violated')
        else:
            return eval_hasmaterialprofilesetusage_wr


####################
# ENTITY ifcfurnituretype #
####################
class ifcfurnituretype(ifcfurnishingelementtype):
    '''Entity ifcfurnituretype definition.

	:param assemblyplace
	:type assemblyplace:ifcassemblyplaceenum

	:param predefinedtype
	:type predefinedtype:ifcfurnituretypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, assemblyplace, predefinedtype, ):
        ifcfurnishingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, inherited4__applicableoccurrence,
                                          inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                          inherited8__elementtype, )
        self._assemblyplace = assemblyplace
        self._predefinedtype = predefinedtype

    @property
    def assemblyplace(self):
        return self._assemblyplace

    @assemblyplace.setter
    def assemblyplace(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcassemblyplaceenum):
            self._assemblyplace = ifcassemblyplaceenum(value)
        else:
            self._assemblyplace = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcfurnituretypeenum):
                self._predefinedtype = ifcfurnituretypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcfurnituretypeenum.userdefined) or (
                    (self.predefinedtype == ifcfurnituretypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifctopologyrepresentation #
####################
class ifctopologyrepresentation(ifcshapemodel):
    '''Entity ifctopologyrepresentation definition.
	'''

    def __init__(self, inherited0__contextofitems, inherited1__representationidentifier, inherited2__representationtype,
                 inherited3__items, ):
        ifcshapemodel.__init__(self, inherited0__contextofitems, inherited1__representationidentifier,
                               inherited2__representationtype, inherited3__items, )

    def wr21(self):
        eval_wr21_wr = (SIZEOF(None) == 0)
        if not eval_wr21_wr:
            raise AssertionError('Rule wr21 violated')
        else:
            return eval_wr21_wr

    def wr22(self):
        eval_wr22_wr = EXISTS(self.self.ifcrepresentation.self.representationtype)
        if not eval_wr22_wr:
            raise AssertionError('Rule wr22 violated')
        else:
            return eval_wr22_wr

    def wr23(self):
        eval_wr23_wr = ifctopologyrepresentationtypes(self.self.ifcrepresentation.self.representationtype,
                                                      self.self.ifcrepresentation.self.items)
        if not eval_wr23_wr:
            raise AssertionError('Rule wr23 violated')
        else:
            return eval_wr23_wr


####################
# ENTITY ifcconversionbasedunit #
####################
class ifcconversionbasedunit(ifcnamedunit):
    '''Entity ifcconversionbasedunit definition.

	:param name
	:type name:ifclabel

	:param conversionfactor
	:type conversionfactor:ifcmeasurewithunit

	:param hasexternalreference
	:type hasexternalreference:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''

    def __init__(self, inherited0__dimensions, inherited1__unittype, name, conversionfactor, ):
        ifcnamedunit.__init__(self, inherited0__dimensions, inherited1__unittype, )
        self._name = name
        self._conversionfactor = conversionfactor

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value

    @property
    def conversionfactor(self):
        return self._conversionfactor

    @conversionfactor.setter
    def conversionfactor(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmeasurewithunit):
            self._conversionfactor = ifcmeasurewithunit(value)
        else:
            self._conversionfactor = value

    @property
    def hasexternalreference(self):
        return self._hasexternalreference

    @hasexternalreference.setter
    def hasexternalreference(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasexternalreference is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcductfitting #
####################
class ifcductfitting(ifcflowfitting):
    '''Entity ifcductfitting definition.

	:param predefinedtype
	:type predefinedtype:ifcductfittingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowfitting.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcductfittingtypeenum):
                self._predefinedtype = ifcductfittingtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcductfittingtypeenum.userdefined)) or ((
                                                                                                self.predefinedtype == ifcductfittingtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCDUCTFITTINGTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifchumidifiertype #
####################
class ifchumidifiertype(ifcenergyconversiondevicetype):
    '''Entity ifchumidifiertype definition.

	:param predefinedtype
	:type predefinedtype:ifchumidifiertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifchumidifiertypeenum):
            self._predefinedtype = ifchumidifiertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifchumidifiertypeenum.userdefined) or (
                    (self.predefinedtype == ifchumidifiertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifclocalplacement #
####################
class ifclocalplacement(ifcobjectplacement):
    '''Entity ifclocalplacement definition.

	:param relativeplacement
	:type relativeplacement:ifcaxis2placement
	'''

    def __init__(self, inherited0__placementrelto, relativeplacement, ):
        ifcobjectplacement.__init__(self, inherited0__placementrelto, )
        self._relativeplacement = relativeplacement

    @property
    def relativeplacement(self):
        return self._relativeplacement

    @relativeplacement.setter
    def relativeplacement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcaxis2placement):
            self._relativeplacement = ifcaxis2placement(value)
        else:
            self._relativeplacement = value

    def wr21(self):
        eval_wr21_wr = ifccorrectlocalplacement(self.relativeplacement, self.placementrelto)
        if not eval_wr21_wr:
            raise AssertionError('Rule wr21 violated')
        else:
            return eval_wr21_wr


####################
# ENTITY ifcmotorconnectiontype #
####################
class ifcmotorconnectiontype(ifcenergyconversiondevicetype):
    '''Entity ifcmotorconnectiontype definition.

	:param predefinedtype
	:type predefinedtype:ifcmotorconnectiontypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmotorconnectiontypeenum):
            self._predefinedtype = ifcmotorconnectiontypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcmotorconnectiontypeenum.userdefined) or (
                    (self.predefinedtype == ifcmotorconnectiontypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcstructuralloadsingledisplacement #
####################
class ifcstructuralloadsingledisplacement(ifcstructuralloadstatic):
    '''Entity ifcstructuralloadsingledisplacement definition.

	:param displacementx
	:type displacementx:ifclengthmeasure

	:param displacementy
	:type displacementy:ifclengthmeasure

	:param displacementz
	:type displacementz:ifclengthmeasure

	:param rotationaldisplacementrx
	:type rotationaldisplacementrx:ifcplaneanglemeasure

	:param rotationaldisplacementry
	:type rotationaldisplacementry:ifcplaneanglemeasure

	:param rotationaldisplacementrz
	:type rotationaldisplacementrz:ifcplaneanglemeasure
	'''

    def __init__(self, inherited0__name, displacementx, displacementy, displacementz, rotationaldisplacementrx,
                 rotationaldisplacementry, rotationaldisplacementrz, ):
        ifcstructuralloadstatic.__init__(self, inherited0__name, )
        self._displacementx = displacementx
        self._displacementy = displacementy
        self._displacementz = displacementz
        self._rotationaldisplacementrx = rotationaldisplacementrx
        self._rotationaldisplacementry = rotationaldisplacementry
        self._rotationaldisplacementrz = rotationaldisplacementrz

    @property
    def displacementx(self):
        return self._displacementx

    @displacementx.setter
    def displacementx(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._displacementx = ifclengthmeasure(value)
            else:
                self._displacementx = value
        else:
            self._displacementx = value

    @property
    def displacementy(self):
        return self._displacementy

    @displacementy.setter
    def displacementy(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._displacementy = ifclengthmeasure(value)
            else:
                self._displacementy = value
        else:
            self._displacementy = value

    @property
    def displacementz(self):
        return self._displacementz

    @displacementz.setter
    def displacementz(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._displacementz = ifclengthmeasure(value)
            else:
                self._displacementz = value
        else:
            self._displacementz = value

    @property
    def rotationaldisplacementrx(self):
        return self._rotationaldisplacementrx

    @rotationaldisplacementrx.setter
    def rotationaldisplacementrx(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplaneanglemeasure):
                self._rotationaldisplacementrx = ifcplaneanglemeasure(value)
            else:
                self._rotationaldisplacementrx = value
        else:
            self._rotationaldisplacementrx = value

    @property
    def rotationaldisplacementry(self):
        return self._rotationaldisplacementry

    @rotationaldisplacementry.setter
    def rotationaldisplacementry(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplaneanglemeasure):
                self._rotationaldisplacementry = ifcplaneanglemeasure(value)
            else:
                self._rotationaldisplacementry = value
        else:
            self._rotationaldisplacementry = value

    @property
    def rotationaldisplacementrz(self):
        return self._rotationaldisplacementrz

    @rotationaldisplacementrz.setter
    def rotationaldisplacementrz(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplaneanglemeasure):
                self._rotationaldisplacementrz = ifcplaneanglemeasure(value)
            else:
                self._rotationaldisplacementrz = value
        else:
            self._rotationaldisplacementrz = value


####################
# ENTITY ifcedge #
####################
class ifcedge(ifctopologicalrepresentationitem):
    '''Entity ifcedge definition.

	:param edgestart
	:type edgestart:ifcvertex

	:param edgeend
	:type edgeend:ifcvertex
	'''

    def __init__(self, edgestart, edgeend, ):
        ifctopologicalrepresentationitem.__init__(self, )
        self._edgestart = edgestart
        self._edgeend = edgeend

    @property
    def edgestart(self):
        return self._edgestart

    @edgestart.setter
    def edgestart(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcvertex):
            self._edgestart = ifcvertex(value)
        else:
            self._edgestart = value

    @property
    def edgeend(self):
        return self._edgeend

    @edgeend.setter
    def edgeend(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcvertex):
            self._edgeend = ifcvertex(value)
        else:
            self._edgeend = value


####################
# ENTITY ifcsubedge #
####################
class ifcsubedge(ifcedge):
    '''Entity ifcsubedge definition.

	:param parentedge
	:type parentedge:ifcedge
	'''

    def __init__(self, inherited0__edgestart, inherited1__edgeend, parentedge, ):
        ifcedge.__init__(self, inherited0__edgestart, inherited1__edgeend, )
        self._parentedge = parentedge

    @property
    def parentedge(self):
        return self._parentedge

    @parentedge.setter
    def parentedge(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcedge):
            self._parentedge = ifcedge(value)
        else:
            self._parentedge = value


####################
# ENTITY ifctask #
####################
class ifctask(ifcprocess):
    '''Entity ifctask definition.

	:param status
	:type status:ifclabel

	:param workmethod
	:type workmethod:ifclabel

	:param ismilestone
	:type ismilestone:ifcboolean

	:param priority
	:type priority:ifcinteger

	:param tasktime
	:type tasktime:ifctasktime

	:param predefinedtype
	:type predefinedtype:ifctasktypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, inherited6__longdescription, status, workmethod,
                 ismilestone, priority, tasktime, predefinedtype, ):
        ifcprocess.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__identification,
                            inherited6__longdescription, )
        self._status = status
        self._workmethod = workmethod
        self._ismilestone = ismilestone
        self._priority = priority
        self._tasktime = tasktime
        self._predefinedtype = predefinedtype

    @property
    def status(self):
        return self._status

    @status.setter
    def status(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._status = ifclabel(value)
            else:
                self._status = value
        else:
            self._status = value

    @property
    def workmethod(self):
        return self._workmethod

    @workmethod.setter
    def workmethod(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._workmethod = ifclabel(value)
            else:
                self._workmethod = value
        else:
            self._workmethod = value

    @property
    def ismilestone(self):
        return self._ismilestone

    @ismilestone.setter
    def ismilestone(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._ismilestone = ifcboolean(value)
        else:
            self._ismilestone = value

    @property
    def priority(self):
        return self._priority

    @priority.setter
    def priority(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcinteger):
                self._priority = ifcinteger(value)
            else:
                self._priority = value
        else:
            self._priority = value

    @property
    def tasktime(self):
        return self._tasktime

    @tasktime.setter
    def tasktime(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctasktime):
                self._tasktime = ifctasktime(value)
            else:
                self._tasktime = value
        else:
            self._tasktime = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctasktypeenum):
                self._predefinedtype = ifctasktypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def hasname(self):
        eval_hasname_wr = EXISTS(self.self.ifcroot.self.name)
        if not eval_hasname_wr:
            raise AssertionError('Rule hasname violated')
        else:
            return eval_hasname_wr

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifctasktypeenum.userdefined)) or (
                        (self.predefinedtype == ifctasktypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcelectricgeneratortype #
####################
class ifcelectricgeneratortype(ifcenergyconversiondevicetype):
    '''Entity ifcelectricgeneratortype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricgeneratortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelectricgeneratortypeenum):
            self._predefinedtype = ifcelectricgeneratortypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcelectricgeneratortypeenum.userdefined) or (
                    (self.predefinedtype == ifcelectricgeneratortypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcprocedure #
####################
class ifcprocedure(ifcprocess):
    '''Entity ifcprocedure definition.

	:param predefinedtype
	:type predefinedtype:ifcproceduretypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, inherited6__longdescription, predefinedtype, ):
        ifcprocess.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__identification,
                            inherited6__longdescription, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcproceduretypeenum):
                self._predefinedtype = ifcproceduretypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def hasname(self):
        eval_hasname_wr = EXISTS(self.self.ifcroot.self.name)
        if not eval_hasname_wr:
            raise AssertionError('Rule hasname violated')
        else:
            return eval_hasname_wr

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcproceduretypeenum.userdefined)) or ((
                                                                                              self.predefinedtype == ifcproceduretypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcstructuralloadsingledisplacementdistortion #
####################
class ifcstructuralloadsingledisplacementdistortion(ifcstructuralloadsingledisplacement):
    '''Entity ifcstructuralloadsingledisplacementdistortion definition.

	:param distortion
	:type distortion:ifccurvaturemeasure
	'''

    def __init__(self, inherited0__name, inherited1__displacementx, inherited2__displacementy,
                 inherited3__displacementz, inherited4__rotationaldisplacementrx, inherited5__rotationaldisplacementry,
                 inherited6__rotationaldisplacementrz, distortion, ):
        ifcstructuralloadsingledisplacement.__init__(self, inherited0__name, inherited1__displacementx,
                                                     inherited2__displacementy, inherited3__displacementz,
                                                     inherited4__rotationaldisplacementrx,
                                                     inherited5__rotationaldisplacementry,
                                                     inherited6__rotationaldisplacementrz, )
        self._distortion = distortion

    @property
    def distortion(self):
        return self._distortion

    @distortion.setter
    def distortion(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccurvaturemeasure):
                self._distortion = ifccurvaturemeasure(value)
            else:
                self._distortion = value
        else:
            self._distortion = value


####################
# ENTITY ifcfootingtype #
####################
class ifcfootingtype(ifcbuildingelementtype):
    '''Entity ifcfootingtype definition.

	:param predefinedtype
	:type predefinedtype:ifcfootingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcfootingtypeenum):
            self._predefinedtype = ifcfootingtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcfootingtypeenum.userdefined) or (
                    (self.predefinedtype == ifcfootingtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifccommunicationsappliance #
####################
class ifccommunicationsappliance(ifcflowterminal):
    '''Entity ifccommunicationsappliance definition.

	:param predefinedtype
	:type predefinedtype:ifccommunicationsappliancetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowterminal.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccommunicationsappliancetypeenum):
                self._predefinedtype = ifccommunicationsappliancetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifccommunicationsappliancetypeenum.userdefined)) or ((
                                                                                                            self.predefinedtype == ifccommunicationsappliancetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCOMMUNICATIONSAPPLIANCETYPE' == TYPEOF(
                self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcpolygonalboundedhalfspace #
####################
class ifcpolygonalboundedhalfspace(ifchalfspacesolid):
    '''Entity ifcpolygonalboundedhalfspace definition.

	:param position
	:type position:ifcaxis2placement3d

	:param polygonalboundary
	:type polygonalboundary:ifcboundedcurve
	'''

    def __init__(self, inherited0__basesurface, inherited1__agreementflag, position, polygonalboundary, ):
        ifchalfspacesolid.__init__(self, inherited0__basesurface, inherited1__agreementflag, )
        self._position = position
        self._polygonalboundary = polygonalboundary

    @property
    def position(self):
        return self._position

    @position.setter
    def position(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcaxis2placement3d):
            self._position = ifcaxis2placement3d(value)
        else:
            self._position = value

    @property
    def polygonalboundary(self):
        return self._polygonalboundary

    @polygonalboundary.setter
    def polygonalboundary(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboundedcurve):
            self._polygonalboundary = ifcboundedcurve(value)
        else:
            self._polygonalboundary = value

    def boundarydim(self):
        eval_boundarydim_wr = (self.polygonalboundary.self.dim == 2)
        if not eval_boundarydim_wr:
            raise AssertionError('Rule boundarydim violated')
        else:
            return eval_boundarydim_wr

    def boundarytype(self):
        eval_boundarytype_wr = (
                    SIZEOF(TYPEOF(self.polygonalboundary) * ['IFC4X2.IFCPOLYLINE', 'IFC4X2.IFCCOMPOSITECURVE']) == 1)
        if not eval_boundarytype_wr:
            raise AssertionError('Rule boundarytype violated')
        else:
            return eval_boundarytype_wr


####################
# ENTITY ifcsolardevicetype #
####################
class ifcsolardevicetype(ifcenergyconversiondevicetype):
    '''Entity ifcsolardevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcsolardevicetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsolardevicetypeenum):
            self._predefinedtype = ifcsolardevicetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcsolardevicetypeenum.userdefined) or (
                    (self.predefinedtype == ifcsolardevicetypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifccircleprofiledef #
####################
class ifccircleprofiledef(ifcparameterizedprofiledef):
    '''Entity ifccircleprofiledef definition.

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, radius, ):
        ifcparameterizedprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename,
                                            inherited2__position, )
        self._radius = radius

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._radius = ifcpositivelengthmeasure(value)
        else:
            self._radius = value


####################
# ENTITY ifccirclehollowprofiledef #
####################
class ifccirclehollowprofiledef(ifccircleprofiledef):
    '''Entity ifccirclehollowprofiledef definition.

	:param wallthickness
	:type wallthickness:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, inherited3__radius,
                 wallthickness, ):
        ifccircleprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position,
                                     inherited3__radius, )
        self._wallthickness = wallthickness

    @property
    def wallthickness(self):
        return self._wallthickness

    @wallthickness.setter
    def wallthickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._wallthickness = ifcpositivelengthmeasure(value)
        else:
            self._wallthickness = value

    def wr1(self):
        eval_wr1_wr = (self.wallthickness < self.self.ifccircleprofiledef.self.radius)
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


####################
# ENTITY ifccurtainwalltype #
####################
class ifccurtainwalltype(ifcbuildingelementtype):
    '''Entity ifccurtainwalltype definition.

	:param predefinedtype
	:type predefinedtype:ifccurtainwalltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurtainwalltypeenum):
            self._predefinedtype = ifccurtainwalltypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccurtainwalltypeenum.userdefined) or (
                    (self.predefinedtype == ifccurtainwalltypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcmonetaryunit #
####################
class ifcmonetaryunit(BaseEntityClass):
    '''Entity ifcmonetaryunit definition.

	:param currency
	:type currency:ifclabel
	'''

    def __init__(self, currency, ):
        self._currency = currency

    @property
    def currency(self):
        return self._currency

    @currency.setter
    def currency(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._currency = ifclabel(value)
        else:
            self._currency = value


####################
# ENTITY ifcrectangularpyramid #
####################
class ifcrectangularpyramid(ifccsgprimitive3d):
    '''Entity ifcrectangularpyramid definition.

	:param xlength
	:type xlength:ifcpositivelengthmeasure

	:param ylength
	:type ylength:ifcpositivelengthmeasure

	:param height
	:type height:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__position, xlength, ylength, height, ):
        ifccsgprimitive3d.__init__(self, inherited0__position, )
        self._xlength = xlength
        self._ylength = ylength
        self._height = height

    @property
    def xlength(self):
        return self._xlength

    @xlength.setter
    def xlength(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._xlength = ifcpositivelengthmeasure(value)
        else:
            self._xlength = value

    @property
    def ylength(self):
        return self._ylength

    @ylength.setter
    def ylength(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._ylength = ifcpositivelengthmeasure(value)
        else:
            self._ylength = value

    @property
    def height(self):
        return self._height

    @height.setter
    def height(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._height = ifcpositivelengthmeasure(value)
        else:
            self._height = value


####################
# ENTITY ifctimeseries #
####################
class ifctimeseries(BaseEntityClass):
    '''Entity ifctimeseries definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param starttime
	:type starttime:ifcdatetime

	:param endtime
	:type endtime:ifcdatetime

	:param timeseriesdatatype
	:type timeseriesdatatype:ifctimeseriesdatatypeenum

	:param dataorigin
	:type dataorigin:ifcdataoriginenum

	:param userdefineddataorigin
	:type userdefineddataorigin:ifclabel

	:param unit
	:type unit:ifcunit

	:param hasexternalreference
	:type hasexternalreference:SET(1,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''

    def __init__(self, name, description, starttime, endtime, timeseriesdatatype, dataorigin, userdefineddataorigin,
                 unit, ):
        self._name = name
        self._description = description
        self._starttime = starttime
        self._endtime = endtime
        self._timeseriesdatatype = timeseriesdatatype
        self._dataorigin = dataorigin
        self._userdefineddataorigin = userdefineddataorigin
        self._unit = unit

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def starttime(self):
        return self._starttime

    @starttime.setter
    def starttime(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdatetime):
            self._starttime = ifcdatetime(value)
        else:
            self._starttime = value

    @property
    def endtime(self):
        return self._endtime

    @endtime.setter
    def endtime(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdatetime):
            self._endtime = ifcdatetime(value)
        else:
            self._endtime = value

    @property
    def timeseriesdatatype(self):
        return self._timeseriesdatatype

    @timeseriesdatatype.setter
    def timeseriesdatatype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctimeseriesdatatypeenum):
            self._timeseriesdatatype = ifctimeseriesdatatypeenum(value)
        else:
            self._timeseriesdatatype = value

    @property
    def dataorigin(self):
        return self._dataorigin

    @dataorigin.setter
    def dataorigin(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdataoriginenum):
            self._dataorigin = ifcdataoriginenum(value)
        else:
            self._dataorigin = value

    @property
    def userdefineddataorigin(self):
        return self._userdefineddataorigin

    @userdefineddataorigin.setter
    def userdefineddataorigin(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefineddataorigin = ifclabel(value)
            else:
                self._userdefineddataorigin = value
        else:
            self._userdefineddataorigin = value

    @property
    def unit(self):
        return self._unit

    @unit.setter
    def unit(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcunit):
                self._unit = ifcunit(value)
            else:
                self._unit = value
        else:
            self._unit = value

    @property
    def hasexternalreference(self):
        return self._hasexternalreference

    @hasexternalreference.setter
    def hasexternalreference(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasexternalreference is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcregulartimeseries #
####################
class ifcregulartimeseries(ifctimeseries):
    '''Entity ifcregulartimeseries definition.

	:param timestep
	:type timestep:ifctimemeasure

	:param values
	:type values:LIST(1,None,'ifctimeseriesvalue', scope = schema_scope)
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__starttime, inherited3__endtime,
                 inherited4__timeseriesdatatype, inherited5__dataorigin, inherited6__userdefineddataorigin,
                 inherited7__unit, timestep, values, ):
        ifctimeseries.__init__(self, inherited0__name, inherited1__description, inherited2__starttime,
                               inherited3__endtime, inherited4__timeseriesdatatype, inherited5__dataorigin,
                               inherited6__userdefineddataorigin, inherited7__unit, )
        self._timestep = timestep
        self._values = values

    @property
    def timestep(self):
        return self._timestep

    @timestep.setter
    def timestep(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctimemeasure):
            self._timestep = ifctimemeasure(value)
        else:
            self._timestep = value

    @property
    def values(self):
        return self._values

    @values.setter
    def values(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifctimeseriesvalue', scope=schema_scope)):
            self._values = LIST(value)
        else:
            self._values = value


####################
# ENTITY ifcstyledrepresentation #
####################
class ifcstyledrepresentation(ifcstylemodel):
    '''Entity ifcstyledrepresentation definition.
	'''

    def __init__(self, inherited0__contextofitems, inherited1__representationidentifier, inherited2__representationtype,
                 inherited3__items, ):
        ifcstylemodel.__init__(self, inherited0__contextofitems, inherited1__representationidentifier,
                               inherited2__representationtype, inherited3__items, )

    def onlystyleditems(self):
        eval_onlystyleditems_wr = (SIZEOF(None) == 0)
        if not eval_onlystyleditems_wr:
            raise AssertionError('Rule onlystyleditems violated')
        else:
            return eval_onlystyleditems_wr


####################
# ENTITY ifccompositeprofiledef #
####################
class ifccompositeprofiledef(ifcprofiledef):
    '''Entity ifccompositeprofiledef definition.

	:param profiles
	:type profiles:SET(2,None,'ifcprofiledef', scope = schema_scope)

	:param label
	:type label:ifclabel
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, profiles, label, ):
        ifcprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename, )
        self._profiles = profiles
        self._label = label

    @property
    def profiles(self):
        return self._profiles

    @profiles.setter
    def profiles(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(2, None, 'ifcprofiledef', scope=schema_scope)):
            self._profiles = SET(value)
        else:
            self._profiles = value

    @property
    def label(self):
        return self._label

    @label.setter
    def label(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._label = ifclabel(value)
            else:
                self._label = value
        else:
            self._label = value

    def invariantprofiletype(self):
        eval_invariantprofiletype_wr = (SIZEOF(None) == 0)
        if not eval_invariantprofiletype_wr:
            raise AssertionError('Rule invariantprofiletype violated')
        else:
            return eval_invariantprofiletype_wr

    def norecursion(self):
        eval_norecursion_wr = (SIZEOF(None) == 0)
        if not eval_norecursion_wr:
            raise AssertionError('Rule norecursion violated')
        else:
            return eval_norecursion_wr


####################
# ENTITY ifcpropertysinglevalue #
####################
class ifcpropertysinglevalue(ifcsimpleproperty):
    '''Entity ifcpropertysinglevalue definition.

	:param nominalvalue
	:type nominalvalue:ifcvalue

	:param unit
	:type unit:ifcunit
	'''

    def __init__(self, inherited0__name, inherited1__description, nominalvalue, unit, ):
        ifcsimpleproperty.__init__(self, inherited0__name, inherited1__description, )
        self._nominalvalue = nominalvalue
        self._unit = unit

    @property
    def nominalvalue(self):
        return self._nominalvalue

    @nominalvalue.setter
    def nominalvalue(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcvalue):
                self._nominalvalue = ifcvalue(value)
            else:
                self._nominalvalue = value
        else:
            self._nominalvalue = value

    @property
    def unit(self):
        return self._unit

    @unit.setter
    def unit(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcunit):
                self._unit = ifcunit(value)
            else:
                self._unit = value
        else:
            self._unit = value


####################
# ENTITY ifcrevolvedareasolid #
####################
class ifcrevolvedareasolid(ifcsweptareasolid):
    '''Entity ifcrevolvedareasolid definition.

	:param axis
	:type axis:ifcaxis1placement

	:param angle
	:type angle:ifcplaneanglemeasure

	:param axisline
	:type axisline:ifcline
	'''

    def __init__(self, inherited0__sweptarea, inherited1__position, axis, angle, ):
        ifcsweptareasolid.__init__(self, inherited0__sweptarea, inherited1__position, )
        self._axis = axis
        self._angle = angle

    @property
    def axis(self):
        return self._axis

    @axis.setter
    def axis(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcaxis1placement):
            self._axis = ifcaxis1placement(value)
        else:
            self._axis = value

    @property
    def angle(self):
        return self._angle

    @angle.setter
    def angle(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcplaneanglemeasure):
            self._angle = ifcplaneanglemeasure(value)
        else:
            self._angle = value

    @property
    def axisline(self):
        attribute_eval = (((ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifccurve()) == ifcline(
            self.axis.self.location,
            (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcvector(self.axis.self.z, 1)))
        return attribute_eval

    @axisline.setter
    def axisline(self, value):
        # DERIVED argument
        raise AssertionError('Argument axisline is DERIVED. It is computed and can not be set to any value')

    def axisstartinxy(self):
        eval_axisstartinxy_wr = (self.axis.self.location.self.coordinates[3] == 0)
        if not eval_axisstartinxy_wr:
            raise AssertionError('Rule axisstartinxy violated')
        else:
            return eval_axisstartinxy_wr

    def axisdirectioninxy(self):
        eval_axisdirectioninxy_wr = (self.axis.self.z.self.directionratios[3] == 0)
        if not eval_axisdirectioninxy_wr:
            raise AssertionError('Rule axisdirectioninxy violated')
        else:
            return eval_axisdirectioninxy_wr


####################
# ENTITY ifcrevolvedareasolidtapered #
####################
class ifcrevolvedareasolidtapered(ifcrevolvedareasolid):
    '''Entity ifcrevolvedareasolidtapered definition.

	:param endsweptarea
	:type endsweptarea:ifcprofiledef
	'''

    def __init__(self, inherited0__sweptarea, inherited1__position, inherited2__axis, inherited3__angle,
                 endsweptarea, ):
        ifcrevolvedareasolid.__init__(self, inherited0__sweptarea, inherited1__position, inherited2__axis,
                                      inherited3__angle, )
        self._endsweptarea = endsweptarea

    @property
    def endsweptarea(self):
        return self._endsweptarea

    @endsweptarea.setter
    def endsweptarea(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprofiledef):
            self._endsweptarea = ifcprofiledef(value)
        else:
            self._endsweptarea = value

    def correctprofileassignment(self):
        eval_correctprofileassignment_wr = ifctaperedsweptareaprofiles(self.self.ifcsweptareasolid.self.sweptarea,
                                                                       self.self.endsweptarea)
        if not eval_correctprofileassignment_wr:
            raise AssertionError('Rule correctprofileassignment violated')
        else:
            return eval_correctprofileassignment_wr


####################
# ENTITY ifcswitchingdevicetype #
####################
class ifcswitchingdevicetype(ifcflowcontrollertype):
    '''Entity ifcswitchingdevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcswitchingdevicetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowcontrollertype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__applicableoccurrence,
                                       inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                       inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcswitchingdevicetypeenum):
            self._predefinedtype = ifcswitchingdevicetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcswitchingdevicetypeenum.userdefined) or (
                    (self.predefinedtype == ifcswitchingdevicetypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcvector #
####################
class ifcvector(ifcgeometricrepresentationitem):
    '''Entity ifcvector definition.

	:param orientation
	:type orientation:ifcdirection

	:param magnitude
	:type magnitude:ifclengthmeasure

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, orientation, magnitude, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._orientation = orientation
        self._magnitude = magnitude

    @property
    def orientation(self):
        return self._orientation

    @orientation.setter
    def orientation(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdirection):
            self._orientation = ifcdirection(value)
        else:
            self._orientation = value

    @property
    def magnitude(self):
        return self._magnitude

    @magnitude.setter
    def magnitude(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._magnitude = ifclengthmeasure(value)
        else:
            self._magnitude = value

    @property
    def dim(self):
        attribute_eval = self.orientation.self.dim
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')

    def maggreaterorequalzero(self):
        eval_maggreaterorequalzero_wr = (self.magnitude >= 0)
        if not eval_maggreaterorequalzero_wr:
            raise AssertionError('Rule maggreaterorequalzero violated')
        else:
            return eval_maggreaterorequalzero_wr


####################
# ENTITY ifcmaterialprofilesetusagetapering #
####################
class ifcmaterialprofilesetusagetapering(ifcmaterialprofilesetusage):
    '''Entity ifcmaterialprofilesetusagetapering definition.

	:param forprofileendset
	:type forprofileendset:ifcmaterialprofileset

	:param cardinalendpoint
	:type cardinalendpoint:ifccardinalpointreference
	'''

    def __init__(self, inherited0__forprofileset, inherited1__cardinalpoint, inherited2__referenceextent,
                 forprofileendset, cardinalendpoint, ):
        ifcmaterialprofilesetusage.__init__(self, inherited0__forprofileset, inherited1__cardinalpoint,
                                            inherited2__referenceextent, )
        self._forprofileendset = forprofileendset
        self._cardinalendpoint = cardinalendpoint

    @property
    def forprofileendset(self):
        return self._forprofileendset

    @forprofileendset.setter
    def forprofileendset(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmaterialprofileset):
            self._forprofileendset = ifcmaterialprofileset(value)
        else:
            self._forprofileendset = value

    @property
    def cardinalendpoint(self):
        return self._cardinalendpoint

    @cardinalendpoint.setter
    def cardinalendpoint(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccardinalpointreference):
                self._cardinalendpoint = ifccardinalpointreference(value)
            else:
                self._cardinalendpoint = value
        else:
            self._cardinalendpoint = value


####################
# ENTITY ifcconnectionpointgeometry #
####################
class ifcconnectionpointgeometry(ifcconnectiongeometry):
    '''Entity ifcconnectionpointgeometry definition.

	:param pointonrelatingelement
	:type pointonrelatingelement:ifcpointorvertexpoint

	:param pointonrelatedelement
	:type pointonrelatedelement:ifcpointorvertexpoint
	'''

    def __init__(self, pointonrelatingelement, pointonrelatedelement, ):
        ifcconnectiongeometry.__init__(self, )
        self._pointonrelatingelement = pointonrelatingelement
        self._pointonrelatedelement = pointonrelatedelement

    @property
    def pointonrelatingelement(self):
        return self._pointonrelatingelement

    @pointonrelatingelement.setter
    def pointonrelatingelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpointorvertexpoint):
            self._pointonrelatingelement = ifcpointorvertexpoint(value)
        else:
            self._pointonrelatingelement = value

    @property
    def pointonrelatedelement(self):
        return self._pointonrelatedelement

    @pointonrelatedelement.setter
    def pointonrelatedelement(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpointorvertexpoint):
                self._pointonrelatedelement = ifcpointorvertexpoint(value)
            else:
                self._pointonrelatedelement = value
        else:
            self._pointonrelatedelement = value


####################
# ENTITY ifcevaporatortype #
####################
class ifcevaporatortype(ifcenergyconversiondevicetype):
    '''Entity ifcevaporatortype definition.

	:param predefinedtype
	:type predefinedtype:ifcevaporatortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcevaporatortypeenum):
            self._predefinedtype = ifcevaporatortypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcevaporatortypeenum.userdefined) or (
                    (self.predefinedtype == ifcevaporatortypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcsurfacestylerefraction #
####################
class ifcsurfacestylerefraction(ifcpresentationitem):
    '''Entity ifcsurfacestylerefraction definition.

	:param refractionindex
	:type refractionindex:ifcreal

	:param dispersionfactor
	:type dispersionfactor:ifcreal
	'''

    def __init__(self, refractionindex, dispersionfactor, ):
        ifcpresentationitem.__init__(self, )
        self._refractionindex = refractionindex
        self._dispersionfactor = dispersionfactor

    @property
    def refractionindex(self):
        return self._refractionindex

    @refractionindex.setter
    def refractionindex(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreal):
                self._refractionindex = ifcreal(value)
            else:
                self._refractionindex = value
        else:
            self._refractionindex = value

    @property
    def dispersionfactor(self):
        return self._dispersionfactor

    @dispersionfactor.setter
    def dispersionfactor(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreal):
                self._dispersionfactor = ifcreal(value)
            else:
                self._dispersionfactor = value
        else:
            self._dispersionfactor = value


####################
# ENTITY ifccoveringtype #
####################
class ifccoveringtype(ifcbuildingelementtype):
    '''Entity ifccoveringtype definition.

	:param predefinedtype
	:type predefinedtype:ifccoveringtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccoveringtypeenum):
            self._predefinedtype = ifccoveringtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccoveringtypeenum.userdefined) or (
                    (self.predefinedtype == ifccoveringtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcrailingtype #
####################
class ifcrailingtype(ifcbuildingelementtype):
    '''Entity ifcrailingtype definition.

	:param predefinedtype
	:type predefinedtype:ifcrailingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcrailingtypeenum):
            self._predefinedtype = ifcrailingtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcrailingtypeenum.userdefined) or (
                    (self.predefinedtype == ifcrailingtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcstructuralloadsingleforce #
####################
class ifcstructuralloadsingleforce(ifcstructuralloadstatic):
    '''Entity ifcstructuralloadsingleforce definition.

	:param forcex
	:type forcex:ifcforcemeasure

	:param forcey
	:type forcey:ifcforcemeasure

	:param forcez
	:type forcez:ifcforcemeasure

	:param momentx
	:type momentx:ifctorquemeasure

	:param momenty
	:type momenty:ifctorquemeasure

	:param momentz
	:type momentz:ifctorquemeasure
	'''

    def __init__(self, inherited0__name, forcex, forcey, forcez, momentx, momenty, momentz, ):
        ifcstructuralloadstatic.__init__(self, inherited0__name, )
        self._forcex = forcex
        self._forcey = forcey
        self._forcez = forcez
        self._momentx = momentx
        self._momenty = momenty
        self._momentz = momentz

    @property
    def forcex(self):
        return self._forcex

    @forcex.setter
    def forcex(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcforcemeasure):
                self._forcex = ifcforcemeasure(value)
            else:
                self._forcex = value
        else:
            self._forcex = value

    @property
    def forcey(self):
        return self._forcey

    @forcey.setter
    def forcey(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcforcemeasure):
                self._forcey = ifcforcemeasure(value)
            else:
                self._forcey = value
        else:
            self._forcey = value

    @property
    def forcez(self):
        return self._forcez

    @forcez.setter
    def forcez(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcforcemeasure):
                self._forcez = ifcforcemeasure(value)
            else:
                self._forcez = value
        else:
            self._forcez = value

    @property
    def momentx(self):
        return self._momentx

    @momentx.setter
    def momentx(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctorquemeasure):
                self._momentx = ifctorquemeasure(value)
            else:
                self._momentx = value
        else:
            self._momentx = value

    @property
    def momenty(self):
        return self._momenty

    @momenty.setter
    def momenty(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctorquemeasure):
                self._momenty = ifctorquemeasure(value)
            else:
                self._momenty = value
        else:
            self._momenty = value

    @property
    def momentz(self):
        return self._momentz

    @momentz.setter
    def momentz(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctorquemeasure):
                self._momentz = ifctorquemeasure(value)
            else:
                self._momentz = value
        else:
            self._momentz = value


####################
# ENTITY ifcdocumentreference #
####################
class ifcdocumentreference(ifcexternalreference):
    '''Entity ifcdocumentreference definition.

	:param description
	:type description:ifctext

	:param referenceddocument
	:type referenceddocument:ifcdocumentinformation

	:param documentrefforobjects
	:type documentrefforobjects:SET(0,None,'ifcrelassociatesdocument', scope = schema_scope)
	'''

    def __init__(self, inherited0__location, inherited1__identification, inherited2__name, description,
                 referenceddocument, ):
        ifcexternalreference.__init__(self, inherited0__location, inherited1__identification, inherited2__name, )
        self._description = description
        self._referenceddocument = referenceddocument

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def referenceddocument(self):
        return self._referenceddocument

    @referenceddocument.setter
    def referenceddocument(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdocumentinformation):
                self._referenceddocument = ifcdocumentinformation(value)
            else:
                self._referenceddocument = value
        else:
            self._referenceddocument = value

    @property
    def documentrefforobjects(self):
        return self._documentrefforobjects

    @documentrefforobjects.setter
    def documentrefforobjects(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument documentrefforobjects is INVERSE. It is computed and can not be set to any value')

    def wr1(self):
        eval_wr1_wr = (EXISTS(self.name) != EXISTS(self.referenceddocument))
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


####################
# ENTITY ifcheatexchangertype #
####################
class ifcheatexchangertype(ifcenergyconversiondevicetype):
    '''Entity ifcheatexchangertype definition.

	:param predefinedtype
	:type predefinedtype:ifcheatexchangertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcheatexchangertypeenum):
            self._predefinedtype = ifcheatexchangertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcheatexchangertypeenum.userdefined) or (
                    (self.predefinedtype == ifcheatexchangertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcmaterialconstituentset #
####################
class ifcmaterialconstituentset(ifcmaterialdefinition):
    '''Entity ifcmaterialconstituentset definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param materialconstituents
	:type materialconstituents:SET(1,None,'ifcmaterialconstituent', scope = schema_scope)
	'''

    def __init__(self, name, description, materialconstituents, ):
        ifcmaterialdefinition.__init__(self, )
        self._name = name
        self._description = description
        self._materialconstituents = materialconstituents

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def materialconstituents(self):
        return self._materialconstituents

    @materialconstituents.setter
    def materialconstituents(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'ifcmaterialconstituent', scope=schema_scope)):
                self._materialconstituents = SET(value)
            else:
                self._materialconstituents = value
        else:
            self._materialconstituents = value


####################
# ENTITY ifcoutlet #
####################
class ifcoutlet(ifcflowterminal):
    '''Entity ifcoutlet definition.

	:param predefinedtype
	:type predefinedtype:ifcoutlettypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowterminal.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcoutlettypeenum):
                self._predefinedtype = ifcoutlettypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcoutlettypeenum.userdefined)) or (
                        (self.predefinedtype == ifcoutlettypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCOUTLETTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcboundaryedgecondition #
####################
class ifcboundaryedgecondition(ifcboundarycondition):
    '''Entity ifcboundaryedgecondition definition.

	:param translationalstiffnessbylengthx
	:type translationalstiffnessbylengthx:ifcmodulusoftranslationalsubgradereactionselect

	:param translationalstiffnessbylengthy
	:type translationalstiffnessbylengthy:ifcmodulusoftranslationalsubgradereactionselect

	:param translationalstiffnessbylengthz
	:type translationalstiffnessbylengthz:ifcmodulusoftranslationalsubgradereactionselect

	:param rotationalstiffnessbylengthx
	:type rotationalstiffnessbylengthx:ifcmodulusofrotationalsubgradereactionselect

	:param rotationalstiffnessbylengthy
	:type rotationalstiffnessbylengthy:ifcmodulusofrotationalsubgradereactionselect

	:param rotationalstiffnessbylengthz
	:type rotationalstiffnessbylengthz:ifcmodulusofrotationalsubgradereactionselect
	'''

    def __init__(self, inherited0__name, translationalstiffnessbylengthx, translationalstiffnessbylengthy,
                 translationalstiffnessbylengthz, rotationalstiffnessbylengthx, rotationalstiffnessbylengthy,
                 rotationalstiffnessbylengthz, ):
        ifcboundarycondition.__init__(self, inherited0__name, )
        self._translationalstiffnessbylengthx = translationalstiffnessbylengthx
        self._translationalstiffnessbylengthy = translationalstiffnessbylengthy
        self._translationalstiffnessbylengthz = translationalstiffnessbylengthz
        self._rotationalstiffnessbylengthx = rotationalstiffnessbylengthx
        self._rotationalstiffnessbylengthy = rotationalstiffnessbylengthy
        self._rotationalstiffnessbylengthz = rotationalstiffnessbylengthz

    @property
    def translationalstiffnessbylengthx(self):
        return self._translationalstiffnessbylengthx

    @translationalstiffnessbylengthx.setter
    def translationalstiffnessbylengthx(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmodulusoftranslationalsubgradereactionselect):
                self._translationalstiffnessbylengthx = ifcmodulusoftranslationalsubgradereactionselect(value)
            else:
                self._translationalstiffnessbylengthx = value
        else:
            self._translationalstiffnessbylengthx = value

    @property
    def translationalstiffnessbylengthy(self):
        return self._translationalstiffnessbylengthy

    @translationalstiffnessbylengthy.setter
    def translationalstiffnessbylengthy(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmodulusoftranslationalsubgradereactionselect):
                self._translationalstiffnessbylengthy = ifcmodulusoftranslationalsubgradereactionselect(value)
            else:
                self._translationalstiffnessbylengthy = value
        else:
            self._translationalstiffnessbylengthy = value

    @property
    def translationalstiffnessbylengthz(self):
        return self._translationalstiffnessbylengthz

    @translationalstiffnessbylengthz.setter
    def translationalstiffnessbylengthz(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmodulusoftranslationalsubgradereactionselect):
                self._translationalstiffnessbylengthz = ifcmodulusoftranslationalsubgradereactionselect(value)
            else:
                self._translationalstiffnessbylengthz = value
        else:
            self._translationalstiffnessbylengthz = value

    @property
    def rotationalstiffnessbylengthx(self):
        return self._rotationalstiffnessbylengthx

    @rotationalstiffnessbylengthx.setter
    def rotationalstiffnessbylengthx(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmodulusofrotationalsubgradereactionselect):
                self._rotationalstiffnessbylengthx = ifcmodulusofrotationalsubgradereactionselect(value)
            else:
                self._rotationalstiffnessbylengthx = value
        else:
            self._rotationalstiffnessbylengthx = value

    @property
    def rotationalstiffnessbylengthy(self):
        return self._rotationalstiffnessbylengthy

    @rotationalstiffnessbylengthy.setter
    def rotationalstiffnessbylengthy(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmodulusofrotationalsubgradereactionselect):
                self._rotationalstiffnessbylengthy = ifcmodulusofrotationalsubgradereactionselect(value)
            else:
                self._rotationalstiffnessbylengthy = value
        else:
            self._rotationalstiffnessbylengthy = value

    @property
    def rotationalstiffnessbylengthz(self):
        return self._rotationalstiffnessbylengthz

    @rotationalstiffnessbylengthz.setter
    def rotationalstiffnessbylengthz(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmodulusofrotationalsubgradereactionselect):
                self._rotationalstiffnessbylengthz = ifcmodulusofrotationalsubgradereactionselect(value)
            else:
                self._rotationalstiffnessbylengthz = value
        else:
            self._rotationalstiffnessbylengthz = value


####################
# ENTITY ifcbridgepart #
####################
class ifcbridgepart(ifcfacilitypart):
    '''Entity ifcbridgepart definition.

	:param predefinedtype
	:type predefinedtype:ifcbridgeparttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__longname,
                 inherited8__compositiontype, predefinedtype, ):
        ifcfacilitypart.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__longname, inherited8__compositiontype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcbridgeparttypeenum):
                self._predefinedtype = ifcbridgeparttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value


####################
# ENTITY ifccablecarrierfittingtype #
####################
class ifccablecarrierfittingtype(ifcflowfittingtype):
    '''Entity ifccablecarrierfittingtype definition.

	:param predefinedtype
	:type predefinedtype:ifccablecarrierfittingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowfittingtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__applicableoccurrence,
                                    inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                    inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccablecarrierfittingtypeenum):
            self._predefinedtype = ifccablecarrierfittingtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccablecarrierfittingtypeenum.userdefined) or (
                    (self.predefinedtype == ifccablecarrierfittingtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifccontrollertype #
####################
class ifccontrollertype(ifcdistributioncontrolelementtype):
    '''Entity ifccontrollertype definition.

	:param predefinedtype
	:type predefinedtype:ifccontrollertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcdistributioncontrolelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory,
                                                   inherited2__name, inherited3__description,
                                                   inherited4__applicableoccurrence, inherited5__haspropertysets,
                                                   inherited6__representationmaps, inherited7__tag,
                                                   inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccontrollertypeenum):
            self._predefinedtype = ifccontrollertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccontrollertypeenum.userdefined) or (
                    (self.predefinedtype == ifccontrollertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcrelassignstogroupbyfactor #
####################
class ifcrelassignstogroupbyfactor(ifcrelassignstogroup):
    '''Entity ifcrelassignstogroupbyfactor definition.

	:param factor
	:type factor:ifcratiomeasure
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatedobjects, inherited5__relatedobjectstype, inherited6__relatinggroup, factor, ):
        ifcrelassignstogroup.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                      inherited3__description, inherited4__relatedobjects,
                                      inherited5__relatedobjectstype, inherited6__relatinggroup, )
        self._factor = factor

    @property
    def factor(self):
        return self._factor

    @factor.setter
    def factor(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcratiomeasure):
            self._factor = ifcratiomeasure(value)
        else:
            self._factor = value


####################
# ENTITY ifctransitioncurvesegment2d #
####################
class ifctransitioncurvesegment2d(ifccurvesegment2d):
    '''Entity ifctransitioncurvesegment2d definition.

	:param startradius
	:type startradius:ifcpositivelengthmeasure

	:param endradius
	:type endradius:ifcpositivelengthmeasure

	:param isstartradiusccw
	:type isstartradiusccw:ifcboolean

	:param isendradiusccw
	:type isendradiusccw:ifcboolean

	:param transitioncurvetype
	:type transitioncurvetype:ifctransitioncurvetype
	'''

    def __init__(self, inherited0__startpoint, inherited1__startdirection, inherited2__segmentlength, startradius,
                 endradius, isstartradiusccw, isendradiusccw, transitioncurvetype, ):
        ifccurvesegment2d.__init__(self, inherited0__startpoint, inherited1__startdirection,
                                   inherited2__segmentlength, )
        self._startradius = startradius
        self._endradius = endradius
        self._isstartradiusccw = isstartradiusccw
        self._isendradiusccw = isendradiusccw
        self._transitioncurvetype = transitioncurvetype

    @property
    def startradius(self):
        return self._startradius

    @startradius.setter
    def startradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._startradius = ifcpositivelengthmeasure(value)
            else:
                self._startradius = value
        else:
            self._startradius = value

    @property
    def endradius(self):
        return self._endradius

    @endradius.setter
    def endradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._endradius = ifcpositivelengthmeasure(value)
            else:
                self._endradius = value
        else:
            self._endradius = value

    @property
    def isstartradiusccw(self):
        return self._isstartradiusccw

    @isstartradiusccw.setter
    def isstartradiusccw(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._isstartradiusccw = ifcboolean(value)
        else:
            self._isstartradiusccw = value

    @property
    def isendradiusccw(self):
        return self._isendradiusccw

    @isendradiusccw.setter
    def isendradiusccw(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._isendradiusccw = ifcboolean(value)
        else:
            self._isendradiusccw = value

    @property
    def transitioncurvetype(self):
        return self._transitioncurvetype

    @transitioncurvetype.setter
    def transitioncurvetype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctransitioncurvetype):
            self._transitioncurvetype = ifctransitioncurvetype(value)
        else:
            self._transitioncurvetype = value


####################
# ENTITY ifcworkcontrol #
####################
class ifcworkcontrol(ifccontrol):
    '''Entity ifcworkcontrol definition.

	:param creationdate
	:type creationdate:ifcdatetime

	:param creators
	:type creators:SET(1,None,'ifcperson', scope = schema_scope)

	:param purpose
	:type purpose:ifclabel

	:param duration
	:type duration:ifcduration

	:param totalfloat
	:type totalfloat:ifcduration

	:param starttime
	:type starttime:ifcdatetime

	:param finishtime
	:type finishtime:ifcdatetime
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, creationdate, creators, purpose, duration,
                 totalfloat, starttime, finishtime, ):
        ifccontrol.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__identification, )
        self._creationdate = creationdate
        self._creators = creators
        self._purpose = purpose
        self._duration = duration
        self._totalfloat = totalfloat
        self._starttime = starttime
        self._finishtime = finishtime

    @property
    def creationdate(self):
        return self._creationdate

    @creationdate.setter
    def creationdate(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdatetime):
            self._creationdate = ifcdatetime(value)
        else:
            self._creationdate = value

    @property
    def creators(self):
        return self._creators

    @creators.setter
    def creators(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'ifcperson', scope=schema_scope)):
                self._creators = SET(value)
            else:
                self._creators = value
        else:
            self._creators = value

    @property
    def purpose(self):
        return self._purpose

    @purpose.setter
    def purpose(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._purpose = ifclabel(value)
            else:
                self._purpose = value
        else:
            self._purpose = value

    @property
    def duration(self):
        return self._duration

    @duration.setter
    def duration(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcduration):
                self._duration = ifcduration(value)
            else:
                self._duration = value
        else:
            self._duration = value

    @property
    def totalfloat(self):
        return self._totalfloat

    @totalfloat.setter
    def totalfloat(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcduration):
                self._totalfloat = ifcduration(value)
            else:
                self._totalfloat = value
        else:
            self._totalfloat = value

    @property
    def starttime(self):
        return self._starttime

    @starttime.setter
    def starttime(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdatetime):
            self._starttime = ifcdatetime(value)
        else:
            self._starttime = value

    @property
    def finishtime(self):
        return self._finishtime

    @finishtime.setter
    def finishtime(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._finishtime = ifcdatetime(value)
            else:
                self._finishtime = value
        else:
            self._finishtime = value


####################
# ENTITY ifcworkplan #
####################
class ifcworkplan(ifcworkcontrol):
    '''Entity ifcworkplan definition.

	:param predefinedtype
	:type predefinedtype:ifcworkplantypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, inherited6__creationdate, inherited7__creators,
                 inherited8__purpose, inherited9__duration, inherited10__totalfloat, inherited11__starttime,
                 inherited12__finishtime, predefinedtype, ):
        ifcworkcontrol.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__objecttype, inherited5__identification,
                                inherited6__creationdate, inherited7__creators, inherited8__purpose,
                                inherited9__duration, inherited10__totalfloat, inherited11__starttime,
                                inherited12__finishtime, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcworkplantypeenum):
                self._predefinedtype = ifcworkplantypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcworkplantypeenum.userdefined)) or (
                        (self.predefinedtype == ifcworkplantypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcactorrole #
####################
class ifcactorrole(BaseEntityClass):
    '''Entity ifcactorrole definition.

	:param role
	:type role:ifcroleenum

	:param userdefinedrole
	:type userdefinedrole:ifclabel

	:param description
	:type description:ifctext

	:param hasexternalreference
	:type hasexternalreference:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''

    def __init__(self, role, userdefinedrole, description, ):
        self._role = role
        self._userdefinedrole = userdefinedrole
        self._description = description

    @property
    def role(self):
        return self._role

    @role.setter
    def role(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcroleenum):
            self._role = ifcroleenum(value)
        else:
            self._role = value

    @property
    def userdefinedrole(self):
        return self._userdefinedrole

    @userdefinedrole.setter
    def userdefinedrole(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefinedrole = ifclabel(value)
            else:
                self._userdefinedrole = value
        else:
            self._userdefinedrole = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def hasexternalreference(self):
        return self._hasexternalreference

    @hasexternalreference.setter
    def hasexternalreference(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasexternalreference is INVERSE. It is computed and can not be set to any value')

    def wr1(self):
        eval_wr1_wr = ((self.role != ifcroleenum.userdefined) or (
                    (self.role == ifcroleenum.userdefined) and EXISTS(self.self.userdefinedrole)))
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


####################
# ENTITY ifcface #
####################
class ifcface(ifctopologicalrepresentationitem):
    '''Entity ifcface definition.

	:param bounds
	:type bounds:SET(1,None,'ifcfacebound', scope = schema_scope)

	:param hastexturemaps
	:type hastexturemaps:SET(0,None,'ifctexturemap', scope = schema_scope)
	'''

    def __init__(self, bounds, ):
        ifctopologicalrepresentationitem.__init__(self, )
        self._bounds = bounds

    @property
    def bounds(self):
        return self._bounds

    @bounds.setter
    def bounds(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcfacebound', scope=schema_scope)):
            self._bounds = SET(value)
        else:
            self._bounds = value

    @property
    def hastexturemaps(self):
        return self._hastexturemaps

    @hastexturemaps.setter
    def hastexturemaps(self, value):
        # INVERSE argument
        raise AssertionError('Argument hastexturemaps is INVERSE. It is computed and can not be set to any value')

    def hasouterbound(self):
        eval_hasouterbound_wr = (SIZEOF(None) <= 1)
        if not eval_hasouterbound_wr:
            raise AssertionError('Rule hasouterbound violated')
        else:
            return eval_hasouterbound_wr


####################
# ENTITY ifcfacesurface #
####################
class ifcfacesurface(ifcface):
    '''Entity ifcfacesurface definition.

	:param facesurface
	:type facesurface:ifcsurface

	:param samesense
	:type samesense:ifcboolean
	'''

    def __init__(self, inherited0__bounds, facesurface, samesense, ):
        ifcface.__init__(self, inherited0__bounds, )
        self._facesurface = facesurface
        self._samesense = samesense

    @property
    def facesurface(self):
        return self._facesurface

    @facesurface.setter
    def facesurface(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsurface):
            self._facesurface = ifcsurface(value)
        else:
            self._facesurface = value

    @property
    def samesense(self):
        return self._samesense

    @samesense.setter
    def samesense(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._samesense = ifcboolean(value)
        else:
            self._samesense = value


####################
# ENTITY ifcadvancedface #
####################
class ifcadvancedface(ifcfacesurface):
    '''Entity ifcadvancedface definition.
	'''

    def __init__(self, inherited0__bounds, inherited1__facesurface, inherited2__samesense, ):
        ifcfacesurface.__init__(self, inherited0__bounds, inherited1__facesurface, inherited2__samesense, )

    def applicablesurface(self):
        eval_applicablesurface_wr = (SIZEOF(
            ['IFC4X2.IFCELEMENTARYSURFACE', 'IFC4X2.IFCSWEPTSURFACE', 'IFC4X2.IFCBSPLINESURFACE'] * TYPEOF(
                self.self.ifcfacesurface.self.facesurface)) == 1)
        if not eval_applicablesurface_wr:
            raise AssertionError('Rule applicablesurface violated')
        else:
            return eval_applicablesurface_wr

    def requiresedgecurve(self):
        eval_requiresedgecurve_wr = (SIZEOF(None) == 0)
        if not eval_requiresedgecurve_wr:
            raise AssertionError('Rule requiresedgecurve violated')
        else:
            return eval_requiresedgecurve_wr

    def applicableedgecurves(self):
        eval_applicableedgecurves_wr = (SIZEOF(None) == 0)
        if not eval_applicableedgecurves_wr:
            raise AssertionError('Rule applicableedgecurves violated')
        else:
            return eval_applicableedgecurves_wr


####################
# ENTITY ifcirregulartimeseriesvalue #
####################
class ifcirregulartimeseriesvalue(BaseEntityClass):
    '''Entity ifcirregulartimeseriesvalue definition.

	:param timestamp
	:type timestamp:ifcdatetime

	:param listvalues
	:type listvalues:LIST(1,None,'ifcvalue', scope = schema_scope)
	'''

    def __init__(self, timestamp, listvalues, ):
        self._timestamp = timestamp
        self._listvalues = listvalues

    @property
    def timestamp(self):
        return self._timestamp

    @timestamp.setter
    def timestamp(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdatetime):
            self._timestamp = ifcdatetime(value)
        else:
            self._timestamp = value

    @property
    def listvalues(self):
        return self._listvalues

    @listvalues.setter
    def listvalues(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcvalue', scope=schema_scope)):
            self._listvalues = LIST(value)
        else:
            self._listvalues = value


####################
# ENTITY ifcspaceheater #
####################
class ifcspaceheater(ifcflowterminal):
    '''Entity ifcspaceheater definition.

	:param predefinedtype
	:type predefinedtype:ifcspaceheatertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowterminal.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcspaceheatertypeenum):
                self._predefinedtype = ifcspaceheatertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcspaceheatertypeenum.userdefined)) or ((
                                                                                                self.predefinedtype == ifcspaceheatertypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCSPACEHEATERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcalarm #
####################
class ifcalarm(ifcdistributioncontrolelement):
    '''Entity ifcalarm definition.

	:param predefinedtype
	:type predefinedtype:ifcalarmtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcdistributioncontrolelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__objecttype,
                                               inherited5__objectplacement, inherited6__representation,
                                               inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcalarmtypeenum):
                self._predefinedtype = ifcalarmtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcalarmtypeenum.userdefined)) or (
                        (self.predefinedtype == ifcalarmtypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCALARMTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcderivedprofiledef #
####################
class ifcderivedprofiledef(ifcprofiledef):
    '''Entity ifcderivedprofiledef definition.

	:param parentprofile
	:type parentprofile:ifcprofiledef

	:param operator
	:type operator:ifccartesiantransformationoperator2d

	:param label
	:type label:ifclabel
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, parentprofile, operator, label, ):
        ifcprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename, )
        self._parentprofile = parentprofile
        self._operator = operator
        self._label = label

    @property
    def parentprofile(self):
        return self._parentprofile

    @parentprofile.setter
    def parentprofile(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprofiledef):
            self._parentprofile = ifcprofiledef(value)
        else:
            self._parentprofile = value

    @property
    def operator(self):
        return self._operator

    @operator.setter
    def operator(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccartesiantransformationoperator2d):
            self._operator = ifccartesiantransformationoperator2d(value)
        else:
            self._operator = value

    @property
    def label(self):
        return self._label

    @label.setter
    def label(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._label = ifclabel(value)
            else:
                self._label = value
        else:
            self._label = value

    def invariantprofiletype(self):
        eval_invariantprofiletype_wr = (self.self.ifcprofiledef.self.profiletype == self.parentprofile.self.profiletype)
        if not eval_invariantprofiletype_wr:
            raise AssertionError('Rule invariantprofiletype violated')
        else:
            return eval_invariantprofiletype_wr


####################
# ENTITY ifcmirroredprofiledef #
####################
class ifcmirroredprofiledef(ifcderivedprofiledef):
    '''Entity ifcmirroredprofiledef definition.

	:param operator
	:type operator:ifccartesiantransformationoperator2d
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__parentprofile,
                 inherited3__operator, inherited4__label, ):
        ifcderivedprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename, inherited2__parentprofile,
                                      inherited3__operator, inherited4__label, )

    @property
    def operator(self):
        attribute_eval = (((
                                       ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifccartesiantransformationoperator(
            (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection([-1, 0]),
            (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection([0, 1]),
            ((ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcpoint()) == ifccartesianpoint([0, 0]),
            1)) == ifccartesiantransformationoperator2d())
        return attribute_eval

    @operator.setter
    def operator(self, value):
        # DERIVED argument
        raise AssertionError('Argument operator is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcsurfacecurvesweptareasolid #
####################
class ifcsurfacecurvesweptareasolid(ifcsweptareasolid):
    '''Entity ifcsurfacecurvesweptareasolid definition.

	:param directrix
	:type directrix:ifccurve

	:param startparam
	:type startparam:ifcparametervalue

	:param endparam
	:type endparam:ifcparametervalue

	:param referencesurface
	:type referencesurface:ifcsurface
	'''

    def __init__(self, inherited0__sweptarea, inherited1__position, directrix, startparam, endparam,
                 referencesurface, ):
        ifcsweptareasolid.__init__(self, inherited0__sweptarea, inherited1__position, )
        self._directrix = directrix
        self._startparam = startparam
        self._endparam = endparam
        self._referencesurface = referencesurface

    @property
    def directrix(self):
        return self._directrix

    @directrix.setter
    def directrix(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._directrix = ifccurve(value)
        else:
            self._directrix = value

    @property
    def startparam(self):
        return self._startparam

    @startparam.setter
    def startparam(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcparametervalue):
                self._startparam = ifcparametervalue(value)
            else:
                self._startparam = value
        else:
            self._startparam = value

    @property
    def endparam(self):
        return self._endparam

    @endparam.setter
    def endparam(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcparametervalue):
                self._endparam = ifcparametervalue(value)
            else:
                self._endparam = value
        else:
            self._endparam = value

    @property
    def referencesurface(self):
        return self._referencesurface

    @referencesurface.setter
    def referencesurface(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsurface):
            self._referencesurface = ifcsurface(value)
        else:
            self._referencesurface = value

    def directrixbounded(self):
        eval_directrixbounded_wr = ((EXISTS(self.startparam) and EXISTS(self.endparam)) or (
                    SIZEOF(['IFC4X2.IFCCONIC', 'IFC4X2.IFCBOUNDEDCURVE'] * TYPEOF(self.directrix)) == 1))
        if not eval_directrixbounded_wr:
            raise AssertionError('Rule directrixbounded violated')
        else:
            return eval_directrixbounded_wr


####################
# ENTITY ifcbearing #
####################
class ifcbearing(ifcbuildingelement):
    '''Entity ifcbearing definition.

	:param predefinedtype
	:type predefinedtype:ifcbearingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcbearingtypeenum):
                self._predefinedtype = ifcbearingtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcbearingtypeenum.userdefined)) or (
                        (self.predefinedtype == ifcbearingtypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCBEARINGTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcopeningstandardcase #
####################
class ifcopeningstandardcase(ifcopeningelement):
    '''Entity ifcopeningstandardcase definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__predefinedtype, ):
        ifcopeningelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, inherited8__predefinedtype, )


####################
# ENTITY ifcprojectlibrary #
####################
class ifcprojectlibrary(ifccontext):
    '''Entity ifcprojectlibrary definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__longname, inherited6__phase, inherited7__representationcontexts,
                 inherited8__unitsincontext, ):
        ifccontext.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__longname, inherited6__phase,
                            inherited7__representationcontexts, inherited8__unitsincontext, )


####################
# ENTITY ifcstructuralsurfacemembervarying #
####################
class ifcstructuralsurfacemembervarying(ifcstructuralsurfacemember):
    '''Entity ifcstructuralsurfacemembervarying definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__predefinedtype, inherited8__thickness, ):
        ifcstructuralsurfacemember.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation,
                                            inherited7__predefinedtype, inherited8__thickness, )


####################
# ENTITY ifctablerow #
####################
class ifctablerow(BaseEntityClass):
    '''Entity ifctablerow definition.

	:param rowcells
	:type rowcells:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param isheading
	:type isheading:ifcboolean
	'''

    def __init__(self, rowcells, isheading, ):
        self._rowcells = rowcells
        self._isheading = isheading

    @property
    def rowcells(self):
        return self._rowcells

    @rowcells.setter
    def rowcells(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcvalue', scope=schema_scope)):
                self._rowcells = LIST(value)
            else:
                self._rowcells = value
        else:
            self._rowcells = value

    @property
    def isheading(self):
        return self._isheading

    @isheading.setter
    def isheading(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._isheading = ifcboolean(value)
            else:
                self._isheading = value
        else:
            self._isheading = value


####################
# ENTITY ifcconnectionpointeccentricity #
####################
class ifcconnectionpointeccentricity(ifcconnectionpointgeometry):
    '''Entity ifcconnectionpointeccentricity definition.

	:param eccentricityinx
	:type eccentricityinx:ifclengthmeasure

	:param eccentricityiny
	:type eccentricityiny:ifclengthmeasure

	:param eccentricityinz
	:type eccentricityinz:ifclengthmeasure
	'''

    def __init__(self, inherited0__pointonrelatingelement, inherited1__pointonrelatedelement, eccentricityinx,
                 eccentricityiny, eccentricityinz, ):
        ifcconnectionpointgeometry.__init__(self, inherited0__pointonrelatingelement,
                                            inherited1__pointonrelatedelement, )
        self._eccentricityinx = eccentricityinx
        self._eccentricityiny = eccentricityiny
        self._eccentricityinz = eccentricityinz

    @property
    def eccentricityinx(self):
        return self._eccentricityinx

    @eccentricityinx.setter
    def eccentricityinx(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._eccentricityinx = ifclengthmeasure(value)
            else:
                self._eccentricityinx = value
        else:
            self._eccentricityinx = value

    @property
    def eccentricityiny(self):
        return self._eccentricityiny

    @eccentricityiny.setter
    def eccentricityiny(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._eccentricityiny = ifclengthmeasure(value)
            else:
                self._eccentricityiny = value
        else:
            self._eccentricityiny = value

    @property
    def eccentricityinz(self):
        return self._eccentricityinz

    @eccentricityinz.setter
    def eccentricityinz(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._eccentricityinz = ifclengthmeasure(value)
            else:
                self._eccentricityinz = value
        else:
            self._eccentricityinz = value


####################
# ENTITY ifcfan #
####################
class ifcfan(ifcflowmovingdevice):
    '''Entity ifcfan definition.

	:param predefinedtype
	:type predefinedtype:ifcfantypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowmovingdevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcfantypeenum):
                self._predefinedtype = ifcfantypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcfantypeenum.userdefined)) or (
                        (self.predefinedtype == ifcfantypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCFANTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcstructuralloadsingleforcewarping #
####################
class ifcstructuralloadsingleforcewarping(ifcstructuralloadsingleforce):
    '''Entity ifcstructuralloadsingleforcewarping definition.

	:param warpingmoment
	:type warpingmoment:ifcwarpingmomentmeasure
	'''

    def __init__(self, inherited0__name, inherited1__forcex, inherited2__forcey, inherited3__forcez,
                 inherited4__momentx, inherited5__momenty, inherited6__momentz, warpingmoment, ):
        ifcstructuralloadsingleforce.__init__(self, inherited0__name, inherited1__forcex, inherited2__forcey,
                                              inherited3__forcez, inherited4__momentx, inherited5__momenty,
                                              inherited6__momentz, )
        self._warpingmoment = warpingmoment

    @property
    def warpingmoment(self):
        return self._warpingmoment

    @warpingmoment.setter
    def warpingmoment(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcwarpingmomentmeasure):
                self._warpingmoment = ifcwarpingmomentmeasure(value)
            else:
                self._warpingmoment = value
        else:
            self._warpingmoment = value


####################
# ENTITY ifcphysicalcomplexquantity #
####################
class ifcphysicalcomplexquantity(ifcphysicalquantity):
    '''Entity ifcphysicalcomplexquantity definition.

	:param hasquantities
	:type hasquantities:SET(1,None,'ifcphysicalquantity', scope = schema_scope)

	:param discrimination
	:type discrimination:ifclabel

	:param quality
	:type quality:ifclabel

	:param usage
	:type usage:ifclabel
	'''

    def __init__(self, inherited0__name, inherited1__description, hasquantities, discrimination, quality, usage, ):
        ifcphysicalquantity.__init__(self, inherited0__name, inherited1__description, )
        self._hasquantities = hasquantities
        self._discrimination = discrimination
        self._quality = quality
        self._usage = usage

    @property
    def hasquantities(self):
        return self._hasquantities

    @hasquantities.setter
    def hasquantities(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcphysicalquantity', scope=schema_scope)):
            self._hasquantities = SET(value)
        else:
            self._hasquantities = value

    @property
    def discrimination(self):
        return self._discrimination

    @discrimination.setter
    def discrimination(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._discrimination = ifclabel(value)
        else:
            self._discrimination = value

    @property
    def quality(self):
        return self._quality

    @quality.setter
    def quality(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._quality = ifclabel(value)
            else:
                self._quality = value
        else:
            self._quality = value

    @property
    def usage(self):
        return self._usage

    @usage.setter
    def usage(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._usage = ifclabel(value)
            else:
                self._usage = value
        else:
            self._usage = value

    def noselfreference(self):
        eval_noselfreference_wr = (SIZEOF(None) == 0)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr

    def uniquequantitynames(self):
        eval_uniquequantitynames_wr = ifcuniquequantitynames(self.hasquantities)
        if not eval_uniquequantitynames_wr:
            raise AssertionError('Rule uniquequantitynames violated')
        else:
            return eval_uniquequantitynames_wr


####################
# ENTITY ifcrelcoversspaces #
####################
class ifcrelcoversspaces(ifcrelconnects):
    '''Entity ifcrelcoversspaces definition.

	:param relatingspace
	:type relatingspace:ifcspace

	:param relatedcoverings
	:type relatedcoverings:SET(1,None,'ifccovering', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingspace, relatedcoverings, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatingspace = relatingspace
        self._relatedcoverings = relatedcoverings

    @property
    def relatingspace(self):
        return self._relatingspace

    @relatingspace.setter
    def relatingspace(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcspace):
            self._relatingspace = ifcspace(value)
        else:
            self._relatingspace = value

    @property
    def relatedcoverings(self):
        return self._relatedcoverings

    @relatedcoverings.setter
    def relatedcoverings(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifccovering', scope=schema_scope)):
            self._relatedcoverings = SET(value)
        else:
            self._relatedcoverings = value


####################
# ENTITY ifctank #
####################
class ifctank(ifcflowstoragedevice):
    '''Entity ifctank definition.

	:param predefinedtype
	:type predefinedtype:ifctanktypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowstoragedevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                      inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                      inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctanktypeenum):
                self._predefinedtype = ifctanktypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifctanktypeenum.userdefined)) or (
                        (self.predefinedtype == ifctanktypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCTANKTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcvertex #
####################
class ifcvertex(ifctopologicalrepresentationitem):
    '''Entity ifcvertex definition.
	'''

    def __init__(self, ):
        ifctopologicalrepresentationitem.__init__(self, )


####################
# ENTITY ifcvertexpoint #
####################
class ifcvertexpoint(ifcvertex):
    '''Entity ifcvertexpoint definition.

	:param vertexgeometry
	:type vertexgeometry:ifcpoint
	'''

    def __init__(self, vertexgeometry, ):
        ifcvertex.__init__(self, )
        self._vertexgeometry = vertexgeometry

    @property
    def vertexgeometry(self):
        return self._vertexgeometry

    @vertexgeometry.setter
    def vertexgeometry(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpoint):
            self._vertexgeometry = ifcpoint(value)
        else:
            self._vertexgeometry = value


####################
# ENTITY ifcairtoairheatrecovery #
####################
class ifcairtoairheatrecovery(ifcenergyconversiondevice):
    '''Entity ifcairtoairheatrecovery definition.

	:param predefinedtype
	:type predefinedtype:ifcairtoairheatrecoverytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcairtoairheatrecoverytypeenum):
                self._predefinedtype = ifcairtoairheatrecoverytypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcairtoairheatrecoverytypeenum.userdefined)) or ((
                                                                                                         self.predefinedtype == ifcairtoairheatrecoverytypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCAIRTOAIRHEATRECOVERYTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcapproval #
####################
class ifcapproval(BaseEntityClass):
    '''Entity ifcapproval definition.

	:param identifier
	:type identifier:ifcidentifier

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param timeofapproval
	:type timeofapproval:ifcdatetime

	:param status
	:type status:ifclabel

	:param level
	:type level:ifclabel

	:param qualifier
	:type qualifier:ifctext

	:param requestingapproval
	:type requestingapproval:ifcactorselect

	:param givingapproval
	:type givingapproval:ifcactorselect

	:param hasexternalreferences
	:type hasexternalreferences:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)

	:param approvedobjects
	:type approvedobjects:SET(0,None,'ifcrelassociatesapproval', scope = schema_scope)

	:param approvedresources
	:type approvedresources:SET(0,None,'ifcresourceapprovalrelationship', scope = schema_scope)

	:param isrelatedwith
	:type isrelatedwith:SET(0,None,'ifcapprovalrelationship', scope = schema_scope)

	:param relates
	:type relates:SET(0,None,'ifcapprovalrelationship', scope = schema_scope)
	'''

    def __init__(self, identifier, name, description, timeofapproval, status, level, qualifier, requestingapproval,
                 givingapproval, ):
        self._identifier = identifier
        self._name = name
        self._description = description
        self._timeofapproval = timeofapproval
        self._status = status
        self._level = level
        self._qualifier = qualifier
        self._requestingapproval = requestingapproval
        self._givingapproval = givingapproval

    @property
    def identifier(self):
        return self._identifier

    @identifier.setter
    def identifier(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._identifier = ifcidentifier(value)
            else:
                self._identifier = value
        else:
            self._identifier = value

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def timeofapproval(self):
        return self._timeofapproval

    @timeofapproval.setter
    def timeofapproval(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._timeofapproval = ifcdatetime(value)
            else:
                self._timeofapproval = value
        else:
            self._timeofapproval = value

    @property
    def status(self):
        return self._status

    @status.setter
    def status(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._status = ifclabel(value)
            else:
                self._status = value
        else:
            self._status = value

    @property
    def level(self):
        return self._level

    @level.setter
    def level(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._level = ifclabel(value)
            else:
                self._level = value
        else:
            self._level = value

    @property
    def qualifier(self):
        return self._qualifier

    @qualifier.setter
    def qualifier(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._qualifier = ifctext(value)
            else:
                self._qualifier = value
        else:
            self._qualifier = value

    @property
    def requestingapproval(self):
        return self._requestingapproval

    @requestingapproval.setter
    def requestingapproval(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcactorselect):
                self._requestingapproval = ifcactorselect(value)
            else:
                self._requestingapproval = value
        else:
            self._requestingapproval = value

    @property
    def givingapproval(self):
        return self._givingapproval

    @givingapproval.setter
    def givingapproval(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcactorselect):
                self._givingapproval = ifcactorselect(value)
            else:
                self._givingapproval = value
        else:
            self._givingapproval = value

    @property
    def hasexternalreferences(self):
        return self._hasexternalreferences

    @hasexternalreferences.setter
    def hasexternalreferences(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument hasexternalreferences is INVERSE. It is computed and can not be set to any value')

    @property
    def approvedobjects(self):
        return self._approvedobjects

    @approvedobjects.setter
    def approvedobjects(self, value):
        # INVERSE argument
        raise AssertionError('Argument approvedobjects is INVERSE. It is computed and can not be set to any value')

    @property
    def approvedresources(self):
        return self._approvedresources

    @approvedresources.setter
    def approvedresources(self, value):
        # INVERSE argument
        raise AssertionError('Argument approvedresources is INVERSE. It is computed and can not be set to any value')

    @property
    def isrelatedwith(self):
        return self._isrelatedwith

    @isrelatedwith.setter
    def isrelatedwith(self, value):
        # INVERSE argument
        raise AssertionError('Argument isrelatedwith is INVERSE. It is computed and can not be set to any value')

    @property
    def relates(self):
        return self._relates

    @relates.setter
    def relates(self, value):
        # INVERSE argument
        raise AssertionError('Argument relates is INVERSE. It is computed and can not be set to any value')

    def hasidentifierorname(self):
        eval_hasidentifierorname_wr = (EXISTS(self.identifier) or EXISTS(self.name))
        if not eval_hasidentifierorname_wr:
            raise AssertionError('Rule hasidentifierorname violated')
        else:
            return eval_hasidentifierorname_wr


####################
# ENTITY ifcstructuralcurvemembervarying #
####################
class ifcstructuralcurvemembervarying(ifcstructuralcurvemember):
    '''Entity ifcstructuralcurvemembervarying definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__predefinedtype, inherited8__axis, ):
        ifcstructuralcurvemember.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                          inherited6__representation, inherited7__predefinedtype, inherited8__axis, )


####################
# ENTITY ifcseamcurve #
####################
class ifcseamcurve(ifcsurfacecurve):
    '''Entity ifcseamcurve definition.
	'''

    def __init__(self, inherited0__curve3d, inherited1__associatedgeometry, inherited2__masterrepresentation, ):
        ifcsurfacecurve.__init__(self, inherited0__curve3d, inherited1__associatedgeometry,
                                 inherited2__masterrepresentation, )

    def twopcurves(self):
        eval_twopcurves_wr = (SIZEOF(self.self.ifcsurfacecurve.self.associatedgeometry) == 2)
        if not eval_twopcurves_wr:
            raise AssertionError('Rule twopcurves violated')
        else:
            return eval_twopcurves_wr

    def samesurface(self):
        eval_samesurface_wr = (
                    ifcassociatedsurface(self.self.ifcsurfacecurve.self.associatedgeometry[1]) == ifcassociatedsurface(
                self.self.ifcsurfacecurve.self.associatedgeometry[2]))
        if not eval_samesurface_wr:
            raise AssertionError('Rule samesurface violated')
        else:
            return eval_samesurface_wr


####################
# ENTITY ifcductsilencertype #
####################
class ifcductsilencertype(ifcflowtreatmentdevicetype):
    '''Entity ifcductsilencertype definition.

	:param predefinedtype
	:type predefinedtype:ifcductsilencertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowtreatmentdevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__applicableoccurrence,
                                            inherited5__haspropertysets, inherited6__representationmaps,
                                            inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcductsilencertypeenum):
            self._predefinedtype = ifcductsilencertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcductsilencertypeenum.userdefined) or (
                    (self.predefinedtype == ifcductsilencertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifclightsourcedirectional #
####################
class ifclightsourcedirectional(ifclightsource):
    '''Entity ifclightsourcedirectional definition.

	:param orientation
	:type orientation:ifcdirection
	'''

    def __init__(self, inherited0__name, inherited1__lightcolour, inherited2__ambientintensity, inherited3__intensity,
                 orientation, ):
        ifclightsource.__init__(self, inherited0__name, inherited1__lightcolour, inherited2__ambientintensity,
                                inherited3__intensity, )
        self._orientation = orientation

    @property
    def orientation(self):
        return self._orientation

    @orientation.setter
    def orientation(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdirection):
            self._orientation = ifcdirection(value)
        else:
            self._orientation = value


####################
# ENTITY ifcquantityvolume #
####################
class ifcquantityvolume(ifcphysicalsimplequantity):
    '''Entity ifcquantityvolume definition.

	:param volumevalue
	:type volumevalue:ifcvolumemeasure

	:param formula
	:type formula:ifclabel
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__unit, volumevalue, formula, ):
        ifcphysicalsimplequantity.__init__(self, inherited0__name, inherited1__description, inherited2__unit, )
        self._volumevalue = volumevalue
        self._formula = formula

    @property
    def volumevalue(self):
        return self._volumevalue

    @volumevalue.setter
    def volumevalue(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcvolumemeasure):
            self._volumevalue = ifcvolumemeasure(value)
        else:
            self._volumevalue = value

    @property
    def formula(self):
        return self._formula

    @formula.setter
    def formula(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._formula = ifclabel(value)
            else:
                self._formula = value
        else:
            self._formula = value

    def wr21(self):
        eval_wr21_wr = ((not EXISTS(self.self.ifcphysicalsimplequantity.self.unit)) or (
                    self.self.ifcphysicalsimplequantity.self.unit.self.unittype == ifcunitenum.volumeunit))
        if not eval_wr21_wr:
            raise AssertionError('Rule wr21 violated')
        else:
            return eval_wr21_wr

    def wr22(self):
        eval_wr22_wr = (self.volumevalue >= 0)
        if not eval_wr22_wr:
            raise AssertionError('Rule wr22 violated')
        else:
            return eval_wr22_wr


####################
# ENTITY ifcsubcontractresource #
####################
class ifcsubcontractresource(ifcconstructionresource):
    '''Entity ifcsubcontractresource definition.

	:param predefinedtype
	:type predefinedtype:ifcsubcontractresourcetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, inherited6__longdescription, inherited7__usage,
                 inherited8__basecosts, inherited9__basequantity, predefinedtype, ):
        ifcconstructionresource.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__objecttype, inherited5__identification,
                                         inherited6__longdescription, inherited7__usage, inherited8__basecosts,
                                         inherited9__basequantity, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsubcontractresourcetypeenum):
                self._predefinedtype = ifcsubcontractresourcetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcsubcontractresourcetypeenum.userdefined)) or ((
                                                                                                        self.predefinedtype == ifcsubcontractresourcetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcalarmtype #
####################
class ifcalarmtype(ifcdistributioncontrolelementtype):
    '''Entity ifcalarmtype definition.

	:param predefinedtype
	:type predefinedtype:ifcalarmtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcdistributioncontrolelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory,
                                                   inherited2__name, inherited3__description,
                                                   inherited4__applicableoccurrence, inherited5__haspropertysets,
                                                   inherited6__representationmaps, inherited7__tag,
                                                   inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcalarmtypeenum):
            self._predefinedtype = ifcalarmtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcalarmtypeenum.userdefined) or (
                    (self.predefinedtype == ifcalarmtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcaudiovisualappliance #
####################
class ifcaudiovisualappliance(ifcflowterminal):
    '''Entity ifcaudiovisualappliance definition.

	:param predefinedtype
	:type predefinedtype:ifcaudiovisualappliancetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowterminal.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcaudiovisualappliancetypeenum):
                self._predefinedtype = ifcaudiovisualappliancetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcaudiovisualappliancetypeenum.userdefined)) or ((
                                                                                                         self.predefinedtype == ifcaudiovisualappliancetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCAUDIOVISUALAPPLIANCETYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcresourcetime #
####################
class ifcresourcetime(ifcschedulingtime):
    '''Entity ifcresourcetime definition.

	:param schedulework
	:type schedulework:ifcduration

	:param scheduleusage
	:type scheduleusage:ifcpositiveratiomeasure

	:param schedulestart
	:type schedulestart:ifcdatetime

	:param schedulefinish
	:type schedulefinish:ifcdatetime

	:param schedulecontour
	:type schedulecontour:ifclabel

	:param levelingdelay
	:type levelingdelay:ifcduration

	:param isoverallocated
	:type isoverallocated:ifcboolean

	:param statustime
	:type statustime:ifcdatetime

	:param actualwork
	:type actualwork:ifcduration

	:param actualusage
	:type actualusage:ifcpositiveratiomeasure

	:param actualstart
	:type actualstart:ifcdatetime

	:param actualfinish
	:type actualfinish:ifcdatetime

	:param remainingwork
	:type remainingwork:ifcduration

	:param remainingusage
	:type remainingusage:ifcpositiveratiomeasure

	:param completion
	:type completion:ifcpositiveratiomeasure
	'''

    def __init__(self, inherited0__name, inherited1__dataorigin, inherited2__userdefineddataorigin, schedulework,
                 scheduleusage, schedulestart, schedulefinish, schedulecontour, levelingdelay, isoverallocated,
                 statustime, actualwork, actualusage, actualstart, actualfinish, remainingwork, remainingusage,
                 completion, ):
        ifcschedulingtime.__init__(self, inherited0__name, inherited1__dataorigin, inherited2__userdefineddataorigin, )
        self._schedulework = schedulework
        self._scheduleusage = scheduleusage
        self._schedulestart = schedulestart
        self._schedulefinish = schedulefinish
        self._schedulecontour = schedulecontour
        self._levelingdelay = levelingdelay
        self._isoverallocated = isoverallocated
        self._statustime = statustime
        self._actualwork = actualwork
        self._actualusage = actualusage
        self._actualstart = actualstart
        self._actualfinish = actualfinish
        self._remainingwork = remainingwork
        self._remainingusage = remainingusage
        self._completion = completion

    @property
    def schedulework(self):
        return self._schedulework

    @schedulework.setter
    def schedulework(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcduration):
                self._schedulework = ifcduration(value)
            else:
                self._schedulework = value
        else:
            self._schedulework = value

    @property
    def scheduleusage(self):
        return self._scheduleusage

    @scheduleusage.setter
    def scheduleusage(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositiveratiomeasure):
                self._scheduleusage = ifcpositiveratiomeasure(value)
            else:
                self._scheduleusage = value
        else:
            self._scheduleusage = value

    @property
    def schedulestart(self):
        return self._schedulestart

    @schedulestart.setter
    def schedulestart(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._schedulestart = ifcdatetime(value)
            else:
                self._schedulestart = value
        else:
            self._schedulestart = value

    @property
    def schedulefinish(self):
        return self._schedulefinish

    @schedulefinish.setter
    def schedulefinish(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._schedulefinish = ifcdatetime(value)
            else:
                self._schedulefinish = value
        else:
            self._schedulefinish = value

    @property
    def schedulecontour(self):
        return self._schedulecontour

    @schedulecontour.setter
    def schedulecontour(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._schedulecontour = ifclabel(value)
            else:
                self._schedulecontour = value
        else:
            self._schedulecontour = value

    @property
    def levelingdelay(self):
        return self._levelingdelay

    @levelingdelay.setter
    def levelingdelay(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcduration):
                self._levelingdelay = ifcduration(value)
            else:
                self._levelingdelay = value
        else:
            self._levelingdelay = value

    @property
    def isoverallocated(self):
        return self._isoverallocated

    @isoverallocated.setter
    def isoverallocated(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._isoverallocated = ifcboolean(value)
            else:
                self._isoverallocated = value
        else:
            self._isoverallocated = value

    @property
    def statustime(self):
        return self._statustime

    @statustime.setter
    def statustime(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._statustime = ifcdatetime(value)
            else:
                self._statustime = value
        else:
            self._statustime = value

    @property
    def actualwork(self):
        return self._actualwork

    @actualwork.setter
    def actualwork(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcduration):
                self._actualwork = ifcduration(value)
            else:
                self._actualwork = value
        else:
            self._actualwork = value

    @property
    def actualusage(self):
        return self._actualusage

    @actualusage.setter
    def actualusage(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositiveratiomeasure):
                self._actualusage = ifcpositiveratiomeasure(value)
            else:
                self._actualusage = value
        else:
            self._actualusage = value

    @property
    def actualstart(self):
        return self._actualstart

    @actualstart.setter
    def actualstart(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._actualstart = ifcdatetime(value)
            else:
                self._actualstart = value
        else:
            self._actualstart = value

    @property
    def actualfinish(self):
        return self._actualfinish

    @actualfinish.setter
    def actualfinish(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._actualfinish = ifcdatetime(value)
            else:
                self._actualfinish = value
        else:
            self._actualfinish = value

    @property
    def remainingwork(self):
        return self._remainingwork

    @remainingwork.setter
    def remainingwork(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcduration):
                self._remainingwork = ifcduration(value)
            else:
                self._remainingwork = value
        else:
            self._remainingwork = value

    @property
    def remainingusage(self):
        return self._remainingusage

    @remainingusage.setter
    def remainingusage(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositiveratiomeasure):
                self._remainingusage = ifcpositiveratiomeasure(value)
            else:
                self._remainingusage = value
        else:
            self._remainingusage = value

    @property
    def completion(self):
        return self._completion

    @completion.setter
    def completion(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositiveratiomeasure):
                self._completion = ifcpositiveratiomeasure(value)
            else:
                self._completion = value
        else:
            self._completion = value


####################
# ENTITY ifctendontype #
####################
class ifctendontype(ifcreinforcingelementtype):
    '''Entity ifctendontype definition.

	:param predefinedtype
	:type predefinedtype:ifctendontypeenum

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param crosssectionarea
	:type crosssectionarea:ifcareameasure

	:param sheathdiameter
	:type sheathdiameter:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, nominaldiameter, crosssectionarea,
                 sheathdiameter, ):
        ifcreinforcingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__applicableoccurrence,
                                           inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                           inherited8__elementtype, )
        self._predefinedtype = predefinedtype
        self._nominaldiameter = nominaldiameter
        self._crosssectionarea = crosssectionarea
        self._sheathdiameter = sheathdiameter

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctendontypeenum):
            self._predefinedtype = ifctendontypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def nominaldiameter(self):
        return self._nominaldiameter

    @nominaldiameter.setter
    def nominaldiameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._nominaldiameter = ifcpositivelengthmeasure(value)
            else:
                self._nominaldiameter = value
        else:
            self._nominaldiameter = value

    @property
    def crosssectionarea(self):
        return self._crosssectionarea

    @crosssectionarea.setter
    def crosssectionarea(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcareameasure):
                self._crosssectionarea = ifcareameasure(value)
            else:
                self._crosssectionarea = value
        else:
            self._crosssectionarea = value

    @property
    def sheathdiameter(self):
        return self._sheathdiameter

    @sheathdiameter.setter
    def sheathdiameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._sheathdiameter = ifcpositivelengthmeasure(value)
            else:
                self._sheathdiameter = value
        else:
            self._sheathdiameter = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifctendontypeenum.userdefined) or (
                    (self.predefinedtype == ifctendontypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcelementassembly #
####################
class ifcelementassembly(ifcelement):
    '''Entity ifcelementassembly definition.

	:param assemblyplace
	:type assemblyplace:ifcassemblyplaceenum

	:param predefinedtype
	:type predefinedtype:ifcelementassemblytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 assemblyplace, predefinedtype, ):
        ifcelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, inherited7__tag, )
        self._assemblyplace = assemblyplace
        self._predefinedtype = predefinedtype

    @property
    def assemblyplace(self):
        return self._assemblyplace

    @assemblyplace.setter
    def assemblyplace(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcassemblyplaceenum):
                self._assemblyplace = ifcassemblyplaceenum(value)
            else:
                self._assemblyplace = value
        else:
            self._assemblyplace = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcelementassemblytypeenum):
                self._predefinedtype = ifcelementassemblytypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcelementassemblytypeenum.userdefined)) or ((
                                                                                                    self.predefinedtype == ifcelementassemblytypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCELEMENTASSEMBLYTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcimagetexture #
####################
class ifcimagetexture(ifcsurfacetexture):
    '''Entity ifcimagetexture definition.

	:param urlreference
	:type urlreference:ifcurireference
	'''

    def __init__(self, inherited0__repeats, inherited1__repeatt, inherited2__mode, inherited3__texturetransform,
                 inherited4__parameter, urlreference, ):
        ifcsurfacetexture.__init__(self, inherited0__repeats, inherited1__repeatt, inherited2__mode,
                                   inherited3__texturetransform, inherited4__parameter, )
        self._urlreference = urlreference

    @property
    def urlreference(self):
        return self._urlreference

    @urlreference.setter
    def urlreference(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcurireference):
            self._urlreference = ifcurireference(value)
        else:
            self._urlreference = value


####################
# ENTITY ifctendonconduittype #
####################
class ifctendonconduittype(ifcreinforcingelementtype):
    '''Entity ifctendonconduittype definition.

	:param predefinedtype
	:type predefinedtype:ifctendonconduittypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcreinforcingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__applicableoccurrence,
                                           inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                           inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctendonconduittypeenum):
            self._predefinedtype = ifctendonconduittypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifctendonconduittypeenum.userdefined) or (
                    (self.predefinedtype == ifctendonconduittypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcfillareastyletiles #
####################
class ifcfillareastyletiles(ifcgeometricrepresentationitem):
    '''Entity ifcfillareastyletiles definition.

	:param tilingpattern
	:type tilingpattern:LIST(2,2,'ifcvector', scope = schema_scope)

	:param tiles
	:type tiles:SET(1,None,'ifcstyleditem', scope = schema_scope)

	:param tilingscale
	:type tilingscale:ifcpositiveratiomeasure
	'''

    def __init__(self, tilingpattern, tiles, tilingscale, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._tilingpattern = tilingpattern
        self._tiles = tiles
        self._tilingscale = tilingscale

    @property
    def tilingpattern(self):
        return self._tilingpattern

    @tilingpattern.setter
    def tilingpattern(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, 2, 'ifcvector', scope=schema_scope)):
            self._tilingpattern = LIST(value)
        else:
            self._tilingpattern = value

    @property
    def tiles(self):
        return self._tiles

    @tiles.setter
    def tiles(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcstyleditem', scope=schema_scope)):
            self._tiles = SET(value)
        else:
            self._tiles = value

    @property
    def tilingscale(self):
        return self._tilingscale

    @tilingscale.setter
    def tilingscale(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositiveratiomeasure):
            self._tilingscale = ifcpositiveratiomeasure(value)
        else:
            self._tilingscale = value


####################
# ENTITY ifcpropertytemplate #
####################
class ifcpropertytemplate(ifcpropertytemplatedefinition):
    '''Entity ifcpropertytemplate definition.

	:param partofcomplextemplate
	:type partofcomplextemplate:SET(0,None,'ifccomplexpropertytemplate', scope = schema_scope)

	:param partofpsettemplate
	:type partofpsettemplate:SET(0,None,'ifcpropertysettemplate', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description, ):
        ifcpropertytemplatedefinition.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, )

    @property
    def partofcomplextemplate(self):
        return self._partofcomplextemplate

    @partofcomplextemplate.setter
    def partofcomplextemplate(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument partofcomplextemplate is INVERSE. It is computed and can not be set to any value')

    @property
    def partofpsettemplate(self):
        return self._partofpsettemplate

    @partofpsettemplate.setter
    def partofpsettemplate(self, value):
        # INVERSE argument
        raise AssertionError('Argument partofpsettemplate is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcsimplepropertytemplate #
####################
class ifcsimplepropertytemplate(ifcpropertytemplate):
    '''Entity ifcsimplepropertytemplate definition.

	:param templatetype
	:type templatetype:ifcsimplepropertytemplatetypeenum

	:param primarymeasuretype
	:type primarymeasuretype:ifclabel

	:param secondarymeasuretype
	:type secondarymeasuretype:ifclabel

	:param enumerators
	:type enumerators:ifcpropertyenumeration

	:param primaryunit
	:type primaryunit:ifcunit

	:param secondaryunit
	:type secondaryunit:ifcunit

	:param expression
	:type expression:ifclabel

	:param accessstate
	:type accessstate:ifcstateenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 templatetype, primarymeasuretype, secondarymeasuretype, enumerators, primaryunit, secondaryunit,
                 expression, accessstate, ):
        ifcpropertytemplate.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, )
        self._templatetype = templatetype
        self._primarymeasuretype = primarymeasuretype
        self._secondarymeasuretype = secondarymeasuretype
        self._enumerators = enumerators
        self._primaryunit = primaryunit
        self._secondaryunit = secondaryunit
        self._expression = expression
        self._accessstate = accessstate

    @property
    def templatetype(self):
        return self._templatetype

    @templatetype.setter
    def templatetype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsimplepropertytemplatetypeenum):
                self._templatetype = ifcsimplepropertytemplatetypeenum(value)
            else:
                self._templatetype = value
        else:
            self._templatetype = value

    @property
    def primarymeasuretype(self):
        return self._primarymeasuretype

    @primarymeasuretype.setter
    def primarymeasuretype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._primarymeasuretype = ifclabel(value)
            else:
                self._primarymeasuretype = value
        else:
            self._primarymeasuretype = value

    @property
    def secondarymeasuretype(self):
        return self._secondarymeasuretype

    @secondarymeasuretype.setter
    def secondarymeasuretype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._secondarymeasuretype = ifclabel(value)
            else:
                self._secondarymeasuretype = value
        else:
            self._secondarymeasuretype = value

    @property
    def enumerators(self):
        return self._enumerators

    @enumerators.setter
    def enumerators(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpropertyenumeration):
                self._enumerators = ifcpropertyenumeration(value)
            else:
                self._enumerators = value
        else:
            self._enumerators = value

    @property
    def primaryunit(self):
        return self._primaryunit

    @primaryunit.setter
    def primaryunit(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcunit):
                self._primaryunit = ifcunit(value)
            else:
                self._primaryunit = value
        else:
            self._primaryunit = value

    @property
    def secondaryunit(self):
        return self._secondaryunit

    @secondaryunit.setter
    def secondaryunit(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcunit):
                self._secondaryunit = ifcunit(value)
            else:
                self._secondaryunit = value
        else:
            self._secondaryunit = value

    @property
    def expression(self):
        return self._expression

    @expression.setter
    def expression(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._expression = ifclabel(value)
            else:
                self._expression = value
        else:
            self._expression = value

    @property
    def accessstate(self):
        return self._accessstate

    @accessstate.setter
    def accessstate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcstateenum):
                self._accessstate = ifcstateenum(value)
            else:
                self._accessstate = value
        else:
            self._accessstate = value


####################
# ENTITY ifcstair #
####################
class ifcstair(ifcbuildingelement):
    '''Entity ifcstair definition.

	:param predefinedtype
	:type predefinedtype:ifcstairtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcstairtypeenum):
                self._predefinedtype = ifcstairtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcstairtypeenum.userdefined)) or (
                        (self.predefinedtype == ifcstairtypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCSTAIRTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcfiresuppressionterminaltype #
####################
class ifcfiresuppressionterminaltype(ifcflowterminaltype):
    '''Entity ifcfiresuppressionterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcfiresuppressionterminaltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowterminaltype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__applicableoccurrence,
                                     inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                     inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcfiresuppressionterminaltypeenum):
            self._predefinedtype = ifcfiresuppressionterminaltypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcfiresuppressionterminaltypeenum.userdefined) or (
                    (self.predefinedtype == ifcfiresuppressionterminaltypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifclagtime #
####################
class ifclagtime(ifcschedulingtime):
    '''Entity ifclagtime definition.

	:param lagvalue
	:type lagvalue:ifctimeorratioselect

	:param durationtype
	:type durationtype:ifctaskdurationenum
	'''

    def __init__(self, inherited0__name, inherited1__dataorigin, inherited2__userdefineddataorigin, lagvalue,
                 durationtype, ):
        ifcschedulingtime.__init__(self, inherited0__name, inherited1__dataorigin, inherited2__userdefineddataorigin, )
        self._lagvalue = lagvalue
        self._durationtype = durationtype

    @property
    def lagvalue(self):
        return self._lagvalue

    @lagvalue.setter
    def lagvalue(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctimeorratioselect):
            self._lagvalue = ifctimeorratioselect(value)
        else:
            self._lagvalue = value

    @property
    def durationtype(self):
        return self._durationtype

    @durationtype.setter
    def durationtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctaskdurationenum):
            self._durationtype = ifctaskdurationenum(value)
        else:
            self._durationtype = value


####################
# ENTITY ifcpoint #
####################
class ifcpoint(ifcgeometricrepresentationitem):
    '''Entity ifcpoint definition.
	'''

    def __init__(self, ):
        ifcgeometricrepresentationitem.__init__(self, )


####################
# ENTITY ifctextliteralwithextent #
####################
class ifctextliteralwithextent(ifctextliteral):
    '''Entity ifctextliteralwithextent definition.

	:param extent
	:type extent:ifcplanarextent

	:param boxalignment
	:type boxalignment:ifcboxalignment
	'''

    def __init__(self, inherited0__literal, inherited1__placement, inherited2__path, extent, boxalignment, ):
        ifctextliteral.__init__(self, inherited0__literal, inherited1__placement, inherited2__path, )
        self._extent = extent
        self._boxalignment = boxalignment

    @property
    def extent(self):
        return self._extent

    @extent.setter
    def extent(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcplanarextent):
            self._extent = ifcplanarextent(value)
        else:
            self._extent = value

    @property
    def boxalignment(self):
        return self._boxalignment

    @boxalignment.setter
    def boxalignment(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboxalignment):
            self._boxalignment = ifcboxalignment(value)
        else:
            self._boxalignment = value

    def wr31(self):
        eval_wr31_wr = (not ('IFC4X2.IFCPLANARBOX' == TYPEOF(self.extent)))
        if not eval_wr31_wr:
            raise AssertionError('Rule wr31 violated')
        else:
            return eval_wr31_wr


####################
# ENTITY ifclinesegment2d #
####################
class ifclinesegment2d(ifccurvesegment2d):
    '''Entity ifclinesegment2d definition.
	'''

    def __init__(self, inherited0__startpoint, inherited1__startdirection, inherited2__segmentlength, ):
        ifccurvesegment2d.__init__(self, inherited0__startpoint, inherited1__startdirection,
                                   inherited2__segmentlength, )


####################
# ENTITY ifcpresentationlayerassignment #
####################
class ifcpresentationlayerassignment(BaseEntityClass):
    '''Entity ifcpresentationlayerassignment definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param assigneditems
	:type assigneditems:SET(1,None,'ifclayereditem', scope = schema_scope)

	:param identifier
	:type identifier:ifcidentifier
	'''

    def __init__(self, name, description, assigneditems, identifier, ):
        self._name = name
        self._description = description
        self._assigneditems = assigneditems
        self._identifier = identifier

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def assigneditems(self):
        return self._assigneditems

    @assigneditems.setter
    def assigneditems(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifclayereditem', scope=schema_scope)):
            self._assigneditems = SET(value)
        else:
            self._assigneditems = value

    @property
    def identifier(self):
        return self._identifier

    @identifier.setter
    def identifier(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._identifier = ifcidentifier(value)
            else:
                self._identifier = value
        else:
            self._identifier = value

    def applicableitems(self):
        eval_applicableitems_wr = (SIZEOF(None) == SIZEOF(self.assigneditems))
        if not eval_applicableitems_wr:
            raise AssertionError('Rule applicableitems violated')
        else:
            return eval_applicableitems_wr


####################
# ENTITY ifcpresentationlayerwithstyle #
####################
class ifcpresentationlayerwithstyle(ifcpresentationlayerassignment):
    '''Entity ifcpresentationlayerwithstyle definition.

	:param layeron
	:type layeron:ifclogical

	:param layerfrozen
	:type layerfrozen:ifclogical

	:param layerblocked
	:type layerblocked:ifclogical

	:param layerstyles
	:type layerstyles:SET(0,None,'ifcpresentationstyle', scope = schema_scope)
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__assigneditems, inherited3__identifier,
                 layeron, layerfrozen, layerblocked, layerstyles, ):
        ifcpresentationlayerassignment.__init__(self, inherited0__name, inherited1__description,
                                                inherited2__assigneditems, inherited3__identifier, )
        self._layeron = layeron
        self._layerfrozen = layerfrozen
        self._layerblocked = layerblocked
        self._layerstyles = layerstyles

    @property
    def layeron(self):
        return self._layeron

    @layeron.setter
    def layeron(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclogical):
            self._layeron = ifclogical(value)
        else:
            self._layeron = value

    @property
    def layerfrozen(self):
        return self._layerfrozen

    @layerfrozen.setter
    def layerfrozen(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclogical):
            self._layerfrozen = ifclogical(value)
        else:
            self._layerfrozen = value

    @property
    def layerblocked(self):
        return self._layerblocked

    @layerblocked.setter
    def layerblocked(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclogical):
            self._layerblocked = ifclogical(value)
        else:
            self._layerblocked = value

    @property
    def layerstyles(self):
        return self._layerstyles

    @layerstyles.setter
    def layerstyles(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(0, None, 'ifcpresentationstyle', scope=schema_scope)):
            self._layerstyles = SET(value)
        else:
            self._layerstyles = value

    def applicableonlytoitems(self):
        eval_applicableonlytoitems_wr = (SIZEOF(None) == SIZEOF(self.assigneditems))
        if not eval_applicableonlytoitems_wr:
            raise AssertionError('Rule applicableonlytoitems violated')
        else:
            return eval_applicableonlytoitems_wr


####################
# ENTITY ifcresourceapprovalrelationship #
####################
class ifcresourceapprovalrelationship(ifcresourcelevelrelationship):
    '''Entity ifcresourceapprovalrelationship definition.

	:param relatedresourceobjects
	:type relatedresourceobjects:SET(1,None,'ifcresourceobjectselect', scope = schema_scope)

	:param relatingapproval
	:type relatingapproval:ifcapproval
	'''

    def __init__(self, inherited0__name, inherited1__description, relatedresourceobjects, relatingapproval, ):
        ifcresourcelevelrelationship.__init__(self, inherited0__name, inherited1__description, )
        self._relatedresourceobjects = relatedresourceobjects
        self._relatingapproval = relatingapproval

    @property
    def relatedresourceobjects(self):
        return self._relatedresourceobjects

    @relatedresourceobjects.setter
    def relatedresourceobjects(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcresourceobjectselect', scope=schema_scope)):
            self._relatedresourceobjects = SET(value)
        else:
            self._relatedresourceobjects = value

    @property
    def relatingapproval(self):
        return self._relatingapproval

    @relatingapproval.setter
    def relatingapproval(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcapproval):
            self._relatingapproval = ifcapproval(value)
        else:
            self._relatingapproval = value


####################
# ENTITY ifctextstyletextmodel #
####################
class ifctextstyletextmodel(ifcpresentationitem):
    '''Entity ifctextstyletextmodel definition.

	:param textindent
	:type textindent:ifcsizeselect

	:param textalign
	:type textalign:ifctextalignment

	:param textdecoration
	:type textdecoration:ifctextdecoration

	:param letterspacing
	:type letterspacing:ifcsizeselect

	:param wordspacing
	:type wordspacing:ifcsizeselect

	:param texttransform
	:type texttransform:ifctexttransformation

	:param lineheight
	:type lineheight:ifcsizeselect
	'''

    def __init__(self, textindent, textalign, textdecoration, letterspacing, wordspacing, texttransform, lineheight, ):
        ifcpresentationitem.__init__(self, )
        self._textindent = textindent
        self._textalign = textalign
        self._textdecoration = textdecoration
        self._letterspacing = letterspacing
        self._wordspacing = wordspacing
        self._texttransform = texttransform
        self._lineheight = lineheight

    @property
    def textindent(self):
        return self._textindent

    @textindent.setter
    def textindent(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsizeselect):
                self._textindent = ifcsizeselect(value)
            else:
                self._textindent = value
        else:
            self._textindent = value

    @property
    def textalign(self):
        return self._textalign

    @textalign.setter
    def textalign(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctextalignment):
                self._textalign = ifctextalignment(value)
            else:
                self._textalign = value
        else:
            self._textalign = value

    @property
    def textdecoration(self):
        return self._textdecoration

    @textdecoration.setter
    def textdecoration(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctextdecoration):
                self._textdecoration = ifctextdecoration(value)
            else:
                self._textdecoration = value
        else:
            self._textdecoration = value

    @property
    def letterspacing(self):
        return self._letterspacing

    @letterspacing.setter
    def letterspacing(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsizeselect):
                self._letterspacing = ifcsizeselect(value)
            else:
                self._letterspacing = value
        else:
            self._letterspacing = value

    @property
    def wordspacing(self):
        return self._wordspacing

    @wordspacing.setter
    def wordspacing(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsizeselect):
                self._wordspacing = ifcsizeselect(value)
            else:
                self._wordspacing = value
        else:
            self._wordspacing = value

    @property
    def texttransform(self):
        return self._texttransform

    @texttransform.setter
    def texttransform(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctexttransformation):
                self._texttransform = ifctexttransformation(value)
            else:
                self._texttransform = value
        else:
            self._texttransform = value

    @property
    def lineheight(self):
        return self._lineheight

    @lineheight.setter
    def lineheight(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsizeselect):
                self._lineheight = ifcsizeselect(value)
            else:
                self._lineheight = value
        else:
            self._lineheight = value


####################
# ENTITY ifcairtoairheatrecoverytype #
####################
class ifcairtoairheatrecoverytype(ifcenergyconversiondevicetype):
    '''Entity ifcairtoairheatrecoverytype definition.

	:param predefinedtype
	:type predefinedtype:ifcairtoairheatrecoverytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcairtoairheatrecoverytypeenum):
            self._predefinedtype = ifcairtoairheatrecoverytypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcairtoairheatrecoverytypeenum.userdefined) or (
                    (self.predefinedtype == ifcairtoairheatrecoverytypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcboundaryfacecondition #
####################
class ifcboundaryfacecondition(ifcboundarycondition):
    '''Entity ifcboundaryfacecondition definition.

	:param translationalstiffnessbyareax
	:type translationalstiffnessbyareax:ifcmodulusofsubgradereactionselect

	:param translationalstiffnessbyareay
	:type translationalstiffnessbyareay:ifcmodulusofsubgradereactionselect

	:param translationalstiffnessbyareaz
	:type translationalstiffnessbyareaz:ifcmodulusofsubgradereactionselect
	'''

    def __init__(self, inherited0__name, translationalstiffnessbyareax, translationalstiffnessbyareay,
                 translationalstiffnessbyareaz, ):
        ifcboundarycondition.__init__(self, inherited0__name, )
        self._translationalstiffnessbyareax = translationalstiffnessbyareax
        self._translationalstiffnessbyareay = translationalstiffnessbyareay
        self._translationalstiffnessbyareaz = translationalstiffnessbyareaz

    @property
    def translationalstiffnessbyareax(self):
        return self._translationalstiffnessbyareax

    @translationalstiffnessbyareax.setter
    def translationalstiffnessbyareax(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmodulusofsubgradereactionselect):
                self._translationalstiffnessbyareax = ifcmodulusofsubgradereactionselect(value)
            else:
                self._translationalstiffnessbyareax = value
        else:
            self._translationalstiffnessbyareax = value

    @property
    def translationalstiffnessbyareay(self):
        return self._translationalstiffnessbyareay

    @translationalstiffnessbyareay.setter
    def translationalstiffnessbyareay(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmodulusofsubgradereactionselect):
                self._translationalstiffnessbyareay = ifcmodulusofsubgradereactionselect(value)
            else:
                self._translationalstiffnessbyareay = value
        else:
            self._translationalstiffnessbyareay = value

    @property
    def translationalstiffnessbyareaz(self):
        return self._translationalstiffnessbyareaz

    @translationalstiffnessbyareaz.setter
    def translationalstiffnessbyareaz(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmodulusofsubgradereactionselect):
                self._translationalstiffnessbyareaz = ifcmodulusofsubgradereactionselect(value)
            else:
                self._translationalstiffnessbyareaz = value
        else:
            self._translationalstiffnessbyareaz = value


####################
# ENTITY ifcbuildingelementpart #
####################
class ifcbuildingelementpart(ifcelementcomponent):
    '''Entity ifcbuildingelementpart definition.

	:param predefinedtype
	:type predefinedtype:ifcbuildingelementparttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcelementcomponent.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcbuildingelementparttypeenum):
                self._predefinedtype = ifcbuildingelementparttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcbuildingelementparttypeenum.userdefined)) or ((
                                                                                                        self.predefinedtype == ifcbuildingelementparttypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCBUILDINGELEMENTPARTTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcrelvoidselement #
####################
class ifcrelvoidselement(ifcreldecomposes):
    '''Entity ifcrelvoidselement definition.

	:param relatingbuildingelement
	:type relatingbuildingelement:ifcelement

	:param relatedopeningelement
	:type relatedopeningelement:ifcfeatureelementsubtraction
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingbuildingelement, relatedopeningelement, ):
        ifcreldecomposes.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                  inherited3__description, )
        self._relatingbuildingelement = relatingbuildingelement
        self._relatedopeningelement = relatedopeningelement

    @property
    def relatingbuildingelement(self):
        return self._relatingbuildingelement

    @relatingbuildingelement.setter
    def relatingbuildingelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelement):
            self._relatingbuildingelement = ifcelement(value)
        else:
            self._relatingbuildingelement = value

    @property
    def relatedopeningelement(self):
        return self._relatedopeningelement

    @relatedopeningelement.setter
    def relatedopeningelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcfeatureelementsubtraction):
            self._relatedopeningelement = ifcfeatureelementsubtraction(value)
        else:
            self._relatedopeningelement = value


####################
# ENTITY ifctubebundle #
####################
class ifctubebundle(ifcenergyconversiondevice):
    '''Entity ifctubebundle definition.

	:param predefinedtype
	:type predefinedtype:ifctubebundletypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctubebundletypeenum):
                self._predefinedtype = ifctubebundletypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifctubebundletypeenum.userdefined)) or ((
                                                                                               self.predefinedtype == ifctubebundletypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCTUBEBUNDLETYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcplanarextent #
####################
class ifcplanarextent(ifcgeometricrepresentationitem):
    '''Entity ifcplanarextent definition.

	:param sizeinx
	:type sizeinx:ifclengthmeasure

	:param sizeiny
	:type sizeiny:ifclengthmeasure
	'''

    def __init__(self, sizeinx, sizeiny, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._sizeinx = sizeinx
        self._sizeiny = sizeiny

    @property
    def sizeinx(self):
        return self._sizeinx

    @sizeinx.setter
    def sizeinx(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._sizeinx = ifclengthmeasure(value)
        else:
            self._sizeinx = value

    @property
    def sizeiny(self):
        return self._sizeiny

    @sizeiny.setter
    def sizeiny(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._sizeiny = ifclengthmeasure(value)
        else:
            self._sizeiny = value


####################
# ENTITY ifcplanarbox #
####################
class ifcplanarbox(ifcplanarextent):
    '''Entity ifcplanarbox definition.

	:param placement
	:type placement:ifcaxis2placement
	'''

    def __init__(self, inherited0__sizeinx, inherited1__sizeiny, placement, ):
        ifcplanarextent.__init__(self, inherited0__sizeinx, inherited1__sizeiny, )
        self._placement = placement

    @property
    def placement(self):
        return self._placement

    @placement.setter
    def placement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcaxis2placement):
            self._placement = ifcaxis2placement(value)
        else:
            self._placement = value


####################
# ENTITY ifcsanitaryterminaltype #
####################
class ifcsanitaryterminaltype(ifcflowterminaltype):
    '''Entity ifcsanitaryterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcsanitaryterminaltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowterminaltype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__applicableoccurrence,
                                     inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                     inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsanitaryterminaltypeenum):
            self._predefinedtype = ifcsanitaryterminaltypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcsanitaryterminaltypeenum.userdefined) or (
                    (self.predefinedtype == ifcsanitaryterminaltypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifccoiltype #
####################
class ifccoiltype(ifcenergyconversiondevicetype):
    '''Entity ifccoiltype definition.

	:param predefinedtype
	:type predefinedtype:ifccoiltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccoiltypeenum):
            self._predefinedtype = ifccoiltypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccoiltypeenum.userdefined) or (
                    (self.predefinedtype == ifccoiltypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcorientededge #
####################
class ifcorientededge(ifcedge):
    '''Entity ifcorientededge definition.

	:param edgeelement
	:type edgeelement:ifcedge

	:param orientation
	:type orientation:ifcboolean

	:param edgestart
	:type edgestart:ifcvertex

	:param edgeend
	:type edgeend:ifcvertex
	'''

    def __init__(self, inherited0__edgestart, inherited1__edgeend, edgeelement, orientation, ):
        ifcedge.__init__(self, inherited0__edgestart, inherited1__edgeend, )
        self._edgeelement = edgeelement
        self._orientation = orientation

    @property
    def edgeelement(self):
        return self._edgeelement

    @edgeelement.setter
    def edgeelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcedge):
            self._edgeelement = ifcedge(value)
        else:
            self._edgeelement = value

    @property
    def orientation(self):
        return self._orientation

    @orientation.setter
    def orientation(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._orientation = ifcboolean(value)
        else:
            self._orientation = value

    @property
    def edgestart(self):
        attribute_eval = ifcbooleanchoose(self.orientation, self.edgeelement.self.edgestart,
                                          self.edgeelement.self.edgeend)
        return attribute_eval

    @edgestart.setter
    def edgestart(self, value):
        # DERIVED argument
        raise AssertionError('Argument edgestart is DERIVED. It is computed and can not be set to any value')

    @property
    def edgeend(self):
        attribute_eval = ifcbooleanchoose(self.orientation, self.edgeelement.self.edgeend,
                                          self.edgeelement.self.edgestart)
        return attribute_eval

    @edgeend.setter
    def edgeend(self, value):
        # DERIVED argument
        raise AssertionError('Argument edgeend is DERIVED. It is computed and can not be set to any value')

    def edgeelementnotoriented(self):
        eval_edgeelementnotoriented_wr = (not ('IFC4X2.IFCORIENTEDEDGE' == TYPEOF(self.edgeelement)))
        if not eval_edgeelementnotoriented_wr:
            raise AssertionError('Rule edgeelementnotoriented violated')
        else:
            return eval_edgeelementnotoriented_wr


####################
# ENTITY ifcwindow #
####################
class ifcwindow(ifcbuildingelement):
    '''Entity ifcwindow definition.

	:param overallheight
	:type overallheight:ifcpositivelengthmeasure

	:param overallwidth
	:type overallwidth:ifcpositivelengthmeasure

	:param predefinedtype
	:type predefinedtype:ifcwindowtypeenum

	:param partitioningtype
	:type partitioningtype:ifcwindowtypepartitioningenum

	:param userdefinedpartitioningtype
	:type userdefinedpartitioningtype:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 overallheight, overallwidth, predefinedtype, partitioningtype, userdefinedpartitioningtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._overallheight = overallheight
        self._overallwidth = overallwidth
        self._predefinedtype = predefinedtype
        self._partitioningtype = partitioningtype
        self._userdefinedpartitioningtype = userdefinedpartitioningtype

    @property
    def overallheight(self):
        return self._overallheight

    @overallheight.setter
    def overallheight(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._overallheight = ifcpositivelengthmeasure(value)
            else:
                self._overallheight = value
        else:
            self._overallheight = value

    @property
    def overallwidth(self):
        return self._overallwidth

    @overallwidth.setter
    def overallwidth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._overallwidth = ifcpositivelengthmeasure(value)
            else:
                self._overallwidth = value
        else:
            self._overallwidth = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcwindowtypeenum):
                self._predefinedtype = ifcwindowtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def partitioningtype(self):
        return self._partitioningtype

    @partitioningtype.setter
    def partitioningtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcwindowtypepartitioningenum):
                self._partitioningtype = ifcwindowtypepartitioningenum(value)
            else:
                self._partitioningtype = value
        else:
            self._partitioningtype = value

    @property
    def userdefinedpartitioningtype(self):
        return self._userdefinedpartitioningtype

    @userdefinedpartitioningtype.setter
    def userdefinedpartitioningtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefinedpartitioningtype = ifclabel(value)
            else:
                self._userdefinedpartitioningtype = value
        else:
            self._userdefinedpartitioningtype = value

    def correctstyleassigned(self):
        eval_correctstyleassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCWINDOWTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correctstyleassigned_wr:
            raise AssertionError('Rule correctstyleassigned violated')
        else:
            return eval_correctstyleassigned_wr


####################
# ENTITY ifclightintensitydistribution #
####################
class ifclightintensitydistribution(BaseEntityClass):
    '''Entity ifclightintensitydistribution definition.

	:param lightdistributioncurve
	:type lightdistributioncurve:ifclightdistributioncurveenum

	:param distributiondata
	:type distributiondata:LIST(1,None,'ifclightdistributiondata', scope = schema_scope)
	'''

    def __init__(self, lightdistributioncurve, distributiondata, ):
        self._lightdistributioncurve = lightdistributioncurve
        self._distributiondata = distributiondata

    @property
    def lightdistributioncurve(self):
        return self._lightdistributioncurve

    @lightdistributioncurve.setter
    def lightdistributioncurve(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclightdistributioncurveenum):
            self._lightdistributioncurve = ifclightdistributioncurveenum(value)
        else:
            self._lightdistributioncurve = value

    @property
    def distributiondata(self):
        return self._distributiondata

    @distributiondata.setter
    def distributiondata(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifclightdistributiondata', scope=schema_scope)):
            self._distributiondata = LIST(value)
        else:
            self._distributiondata = value


####################
# ENTITY ifcpile #
####################
class ifcpile(ifcdeepfoundation):
    '''Entity ifcpile definition.

	:param predefinedtype
	:type predefinedtype:ifcpiletypeenum

	:param constructiontype
	:type constructiontype:ifcpileconstructionenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, constructiontype, ):
        ifcdeepfoundation.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype
        self._constructiontype = constructiontype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpiletypeenum):
                self._predefinedtype = ifcpiletypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def constructiontype(self):
        return self._constructiontype

    @constructiontype.setter
    def constructiontype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpileconstructionenum):
                self._constructiontype = ifcpileconstructionenum(value)
            else:
                self._constructiontype = value
        else:
            self._constructiontype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcpiletypeenum.userdefined)) or (
                        (self.predefinedtype == ifcpiletypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCPILETYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcreldefinesbytype #
####################
class ifcreldefinesbytype(ifcreldefines):
    '''Entity ifcreldefinesbytype definition.

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcobject', scope = schema_scope)

	:param relatingtype
	:type relatingtype:ifctypeobject
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatedobjects, relatingtype, ):
        ifcreldefines.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                               inherited3__description, )
        self._relatedobjects = relatedobjects
        self._relatingtype = relatingtype

    @property
    def relatedobjects(self):
        return self._relatedobjects

    @relatedobjects.setter
    def relatedobjects(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcobject', scope=schema_scope)):
            self._relatedobjects = SET(value)
        else:
            self._relatedobjects = value

    @property
    def relatingtype(self):
        return self._relatingtype

    @relatingtype.setter
    def relatingtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctypeobject):
            self._relatingtype = ifctypeobject(value)
        else:
            self._relatingtype = value


####################
# ENTITY ifcstructuralloadgroup #
####################
class ifcstructuralloadgroup(ifcgroup):
    '''Entity ifcstructuralloadgroup definition.

	:param predefinedtype
	:type predefinedtype:ifcloadgrouptypeenum

	:param actiontype
	:type actiontype:ifcactiontypeenum

	:param actionsource
	:type actionsource:ifcactionsourcetypeenum

	:param coefficient
	:type coefficient:ifcratiomeasure

	:param purpose
	:type purpose:ifclabel

	:param sourceofresultgroup
	:type sourceofresultgroup:SET(0,1,'ifcstructuralresultgroup', scope = schema_scope)

	:param loadgroupfor
	:type loadgroupfor:SET(0,None,'ifcstructuralanalysismodel', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, predefinedtype, actiontype, actionsource, coefficient, purpose, ):
        ifcgroup.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                          inherited3__description, inherited4__objecttype, )
        self._predefinedtype = predefinedtype
        self._actiontype = actiontype
        self._actionsource = actionsource
        self._coefficient = coefficient
        self._purpose = purpose

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcloadgrouptypeenum):
            self._predefinedtype = ifcloadgrouptypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def actiontype(self):
        return self._actiontype

    @actiontype.setter
    def actiontype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcactiontypeenum):
            self._actiontype = ifcactiontypeenum(value)
        else:
            self._actiontype = value

    @property
    def actionsource(self):
        return self._actionsource

    @actionsource.setter
    def actionsource(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcactionsourcetypeenum):
            self._actionsource = ifcactionsourcetypeenum(value)
        else:
            self._actionsource = value

    @property
    def coefficient(self):
        return self._coefficient

    @coefficient.setter
    def coefficient(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcratiomeasure):
                self._coefficient = ifcratiomeasure(value)
            else:
                self._coefficient = value
        else:
            self._coefficient = value

    @property
    def purpose(self):
        return self._purpose

    @purpose.setter
    def purpose(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._purpose = ifclabel(value)
            else:
                self._purpose = value
        else:
            self._purpose = value

    @property
    def sourceofresultgroup(self):
        return self._sourceofresultgroup

    @sourceofresultgroup.setter
    def sourceofresultgroup(self, value):
        # INVERSE argument
        raise AssertionError('Argument sourceofresultgroup is INVERSE. It is computed and can not be set to any value')

    @property
    def loadgroupfor(self):
        return self._loadgroupfor

    @loadgroupfor.setter
    def loadgroupfor(self, value):
        # INVERSE argument
        raise AssertionError('Argument loadgroupfor is INVERSE. It is computed and can not be set to any value')

    def hasobjecttype(self):
        eval_hasobjecttype_wr = ((((self.predefinedtype != ifcloadgrouptypeenum.userdefined) and (
                    self.actiontype != ifcactiontypeenum.userdefined)) and (
                                              self.actionsource != ifcactionsourcetypeenum.userdefined)) or EXISTS(
            self.self.ifcobject.self.objecttype))
        if not eval_hasobjecttype_wr:
            raise AssertionError('Rule hasobjecttype violated')
        else:
            return eval_hasobjecttype_wr


####################
# ENTITY ifcstructuralloadcase #
####################
class ifcstructuralloadcase(ifcstructuralloadgroup):
    '''Entity ifcstructuralloadcase definition.

	:param selfweightcoefficients
	:type selfweightcoefficients:LIST(3,3,'REAL', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__predefinedtype, inherited6__actiontype, inherited7__actionsource,
                 inherited8__coefficient, inherited9__purpose, selfweightcoefficients, ):
        ifcstructuralloadgroup.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__objecttype, inherited5__predefinedtype,
                                        inherited6__actiontype, inherited7__actionsource, inherited8__coefficient,
                                        inherited9__purpose, )
        self._selfweightcoefficients = selfweightcoefficients

    @property
    def selfweightcoefficients(self):
        return self._selfweightcoefficients

    @selfweightcoefficients.setter
    def selfweightcoefficients(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(3, 3, 'REAL', scope=schema_scope)):
                self._selfweightcoefficients = LIST(value)
            else:
                self._selfweightcoefficients = value
        else:
            self._selfweightcoefficients = value

    def isloadcasepredefinedtype(self):
        eval_isloadcasepredefinedtype_wr = (
                    self.self.ifcstructuralloadgroup.self.predefinedtype == ifcloadgrouptypeenum.load_case)
        if not eval_isloadcasepredefinedtype_wr:
            raise AssertionError('Rule isloadcasepredefinedtype violated')
        else:
            return eval_isloadcasepredefinedtype_wr


####################
# ENTITY ifcbridge #
####################
class ifcbridge(ifcfacility):
    '''Entity ifcbridge definition.

	:param predefinedtype
	:type predefinedtype:ifcbridgetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__longname,
                 inherited8__compositiontype, predefinedtype, ):
        ifcfacility.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                             inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                             inherited6__representation, inherited7__longname, inherited8__compositiontype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcbridgetypeenum):
                self._predefinedtype = ifcbridgetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value


####################
# ENTITY ifccaissonfoundation #
####################
class ifccaissonfoundation(ifcdeepfoundation):
    '''Entity ifccaissonfoundation definition.

	:param predefinedtype
	:type predefinedtype:ifccaissonfoundationtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcdeepfoundation.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccaissonfoundationtypeenum):
                self._predefinedtype = ifccaissonfoundationtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifccaissonfoundationtypeenum.userdefined)) or ((
                                                                                                      self.predefinedtype == ifccaissonfoundationtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCCAISSONFOUNDATIONTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcfastener #
####################
class ifcfastener(ifcelementcomponent):
    '''Entity ifcfastener definition.

	:param predefinedtype
	:type predefinedtype:ifcfastenertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcelementcomponent.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcfastenertypeenum):
                self._predefinedtype = ifcfastenertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcfastenertypeenum.userdefined)) or (
                        (self.predefinedtype == ifcfastenertypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCFASTENERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifclshapeprofiledef #
####################
class ifclshapeprofiledef(ifcparameterizedprofiledef):
    '''Entity ifclshapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param width
	:type width:ifcpositivelengthmeasure

	:param thickness
	:type thickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcnonnegativelengthmeasure

	:param edgeradius
	:type edgeradius:ifcnonnegativelengthmeasure

	:param legslope
	:type legslope:ifcplaneanglemeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, depth, width, thickness,
                 filletradius, edgeradius, legslope, ):
        ifcparameterizedprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename,
                                            inherited2__position, )
        self._depth = depth
        self._width = width
        self._thickness = thickness
        self._filletradius = filletradius
        self._edgeradius = edgeradius
        self._legslope = legslope

    @property
    def depth(self):
        return self._depth

    @depth.setter
    def depth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._depth = ifcpositivelengthmeasure(value)
        else:
            self._depth = value

    @property
    def width(self):
        return self._width

    @width.setter
    def width(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._width = ifcpositivelengthmeasure(value)
            else:
                self._width = value
        else:
            self._width = value

    @property
    def thickness(self):
        return self._thickness

    @thickness.setter
    def thickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._thickness = ifcpositivelengthmeasure(value)
        else:
            self._thickness = value

    @property
    def filletradius(self):
        return self._filletradius

    @filletradius.setter
    def filletradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._filletradius = ifcnonnegativelengthmeasure(value)
            else:
                self._filletradius = value
        else:
            self._filletradius = value

    @property
    def edgeradius(self):
        return self._edgeradius

    @edgeradius.setter
    def edgeradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._edgeradius = ifcnonnegativelengthmeasure(value)
            else:
                self._edgeradius = value
        else:
            self._edgeradius = value

    @property
    def legslope(self):
        return self._legslope

    @legslope.setter
    def legslope(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplaneanglemeasure):
                self._legslope = ifcplaneanglemeasure(value)
            else:
                self._legslope = value
        else:
            self._legslope = value

    def validthickness(self):
        eval_validthickness_wr = (
                    (self.thickness < self.depth) and ((not EXISTS(self.width)) or (self.thickness < self.width)))
        if not eval_validthickness_wr:
            raise AssertionError('Rule validthickness violated')
        else:
            return eval_validthickness_wr


####################
# ENTITY ifclibraryinformation #
####################
class ifclibraryinformation(ifcexternalinformation):
    '''Entity ifclibraryinformation definition.

	:param name
	:type name:ifclabel

	:param version
	:type version:ifclabel

	:param publisher
	:type publisher:ifcactorselect

	:param versiondate
	:type versiondate:ifcdatetime

	:param location
	:type location:ifcurireference

	:param description
	:type description:ifctext

	:param libraryinfoforobjects
	:type libraryinfoforobjects:SET(0,None,'ifcrelassociateslibrary', scope = schema_scope)

	:param haslibraryreferences
	:type haslibraryreferences:SET(0,None,'ifclibraryreference', scope = schema_scope)
	'''

    def __init__(self, name, version, publisher, versiondate, location, description, ):
        ifcexternalinformation.__init__(self, )
        self._name = name
        self._version = version
        self._publisher = publisher
        self._versiondate = versiondate
        self._location = location
        self._description = description

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value

    @property
    def version(self):
        return self._version

    @version.setter
    def version(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._version = ifclabel(value)
            else:
                self._version = value
        else:
            self._version = value

    @property
    def publisher(self):
        return self._publisher

    @publisher.setter
    def publisher(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcactorselect):
                self._publisher = ifcactorselect(value)
            else:
                self._publisher = value
        else:
            self._publisher = value

    @property
    def versiondate(self):
        return self._versiondate

    @versiondate.setter
    def versiondate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdatetime):
                self._versiondate = ifcdatetime(value)
            else:
                self._versiondate = value
        else:
            self._versiondate = value

    @property
    def location(self):
        return self._location

    @location.setter
    def location(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcurireference):
                self._location = ifcurireference(value)
            else:
                self._location = value
        else:
            self._location = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def libraryinfoforobjects(self):
        return self._libraryinfoforobjects

    @libraryinfoforobjects.setter
    def libraryinfoforobjects(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument libraryinfoforobjects is INVERSE. It is computed and can not be set to any value')

    @property
    def haslibraryreferences(self):
        return self._haslibraryreferences

    @haslibraryreferences.setter
    def haslibraryreferences(self, value):
        # INVERSE argument
        raise AssertionError('Argument haslibraryreferences is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcpipesegment #
####################
class ifcpipesegment(ifcflowsegment):
    '''Entity ifcpipesegment definition.

	:param predefinedtype
	:type predefinedtype:ifcpipesegmenttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowsegment.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpipesegmenttypeenum):
                self._predefinedtype = ifcpipesegmenttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcpipesegmenttypeenum.userdefined)) or ((
                                                                                                self.predefinedtype == ifcpipesegmenttypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCPIPESEGMENTTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcdistributionchamberelement #
####################
class ifcdistributionchamberelement(ifcdistributionflowelement):
    '''Entity ifcdistributionchamberelement definition.

	:param predefinedtype
	:type predefinedtype:ifcdistributionchamberelementtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcdistributionflowelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdistributionchamberelementtypeenum):
                self._predefinedtype = ifcdistributionchamberelementtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcdistributionchamberelementtypeenum.userdefined)) or ((
                                                                                                               self.predefinedtype == ifcdistributionchamberelementtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCDISTRIBUTIONCHAMBERELEMENTTYPE' == TYPEOF(
                self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcelectricmotortype #
####################
class ifcelectricmotortype(ifcenergyconversiondevicetype):
    '''Entity ifcelectricmotortype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricmotortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelectricmotortypeenum):
            self._predefinedtype = ifcelectricmotortypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcelectricmotortypeenum.userdefined) or (
                    (self.predefinedtype == ifcelectricmotortypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcreinforcementdefinitionproperties #
####################
class ifcreinforcementdefinitionproperties(ifcpredefinedpropertyset):
    '''Entity ifcreinforcementdefinitionproperties definition.

	:param definitiontype
	:type definitiontype:ifclabel

	:param reinforcementsectiondefinitions
	:type reinforcementsectiondefinitions:LIST(1,None,'ifcsectionreinforcementproperties', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 definitiontype, reinforcementsectiondefinitions, ):
        ifcpredefinedpropertyset.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, )
        self._definitiontype = definitiontype
        self._reinforcementsectiondefinitions = reinforcementsectiondefinitions

    @property
    def definitiontype(self):
        return self._definitiontype

    @definitiontype.setter
    def definitiontype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._definitiontype = ifclabel(value)
            else:
                self._definitiontype = value
        else:
            self._definitiontype = value

    @property
    def reinforcementsectiondefinitions(self):
        return self._reinforcementsectiondefinitions

    @reinforcementsectiondefinitions.setter
    def reinforcementsectiondefinitions(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcsectionreinforcementproperties', scope=schema_scope)):
            self._reinforcementsectiondefinitions = LIST(value)
        else:
            self._reinforcementsectiondefinitions = value


####################
# ENTITY ifcairterminaltype #
####################
class ifcairterminaltype(ifcflowterminaltype):
    '''Entity ifcairterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcairterminaltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowterminaltype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__applicableoccurrence,
                                     inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                     inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcairterminaltypeenum):
            self._predefinedtype = ifcairterminaltypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcairterminaltypeenum.userdefined) or (
                    (self.predefinedtype == ifcairterminaltypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcdoor #
####################
class ifcdoor(ifcbuildingelement):
    '''Entity ifcdoor definition.

	:param overallheight
	:type overallheight:ifcpositivelengthmeasure

	:param overallwidth
	:type overallwidth:ifcpositivelengthmeasure

	:param predefinedtype
	:type predefinedtype:ifcdoortypeenum

	:param operationtype
	:type operationtype:ifcdoortypeoperationenum

	:param userdefinedoperationtype
	:type userdefinedoperationtype:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 overallheight, overallwidth, predefinedtype, operationtype, userdefinedoperationtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._overallheight = overallheight
        self._overallwidth = overallwidth
        self._predefinedtype = predefinedtype
        self._operationtype = operationtype
        self._userdefinedoperationtype = userdefinedoperationtype

    @property
    def overallheight(self):
        return self._overallheight

    @overallheight.setter
    def overallheight(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._overallheight = ifcpositivelengthmeasure(value)
            else:
                self._overallheight = value
        else:
            self._overallheight = value

    @property
    def overallwidth(self):
        return self._overallwidth

    @overallwidth.setter
    def overallwidth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._overallwidth = ifcpositivelengthmeasure(value)
            else:
                self._overallwidth = value
        else:
            self._overallwidth = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdoortypeenum):
                self._predefinedtype = ifcdoortypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def operationtype(self):
        return self._operationtype

    @operationtype.setter
    def operationtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdoortypeoperationenum):
                self._operationtype = ifcdoortypeoperationenum(value)
            else:
                self._operationtype = value
        else:
            self._operationtype = value

    @property
    def userdefinedoperationtype(self):
        return self._userdefinedoperationtype

    @userdefinedoperationtype.setter
    def userdefinedoperationtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefinedoperationtype = ifclabel(value)
            else:
                self._userdefinedoperationtype = value
        else:
            self._userdefinedoperationtype = value

    def correctstyleassigned(self):
        eval_correctstyleassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCDOORTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correctstyleassigned_wr:
            raise AssertionError('Rule correctstyleassigned violated')
        else:
            return eval_correctstyleassigned_wr


####################
# ENTITY ifcdoorstandardcase #
####################
class ifcdoorstandardcase(ifcdoor):
    '''Entity ifcdoorstandardcase definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__overallheight, inherited9__overallwidth, inherited10__predefinedtype,
                 inherited11__operationtype, inherited12__userdefinedoperationtype, ):
        ifcdoor.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                         inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                         inherited6__representation, inherited7__tag, inherited8__overallheight,
                         inherited9__overallwidth, inherited10__predefinedtype, inherited11__operationtype,
                         inherited12__userdefinedoperationtype, )


####################
# ENTITY ifcmappeditem #
####################
class ifcmappeditem(ifcrepresentationitem):
    '''Entity ifcmappeditem definition.

	:param mappingsource
	:type mappingsource:ifcrepresentationmap

	:param mappingtarget
	:type mappingtarget:ifccartesiantransformationoperator
	'''

    def __init__(self, mappingsource, mappingtarget, ):
        ifcrepresentationitem.__init__(self, )
        self._mappingsource = mappingsource
        self._mappingtarget = mappingtarget

    @property
    def mappingsource(self):
        return self._mappingsource

    @mappingsource.setter
    def mappingsource(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcrepresentationmap):
            self._mappingsource = ifcrepresentationmap(value)
        else:
            self._mappingsource = value

    @property
    def mappingtarget(self):
        return self._mappingtarget

    @mappingtarget.setter
    def mappingtarget(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccartesiantransformationoperator):
            self._mappingtarget = ifccartesiantransformationoperator(value)
        else:
            self._mappingtarget = value


####################
# ENTITY ifcpump #
####################
class ifcpump(ifcflowmovingdevice):
    '''Entity ifcpump definition.

	:param predefinedtype
	:type predefinedtype:ifcpumptypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowmovingdevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpumptypeenum):
                self._predefinedtype = ifcpumptypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcpumptypeenum.userdefined)) or (
                        (self.predefinedtype == ifcpumptypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCPUMPTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcrelconnectsports #
####################
class ifcrelconnectsports(ifcrelconnects):
    '''Entity ifcrelconnectsports definition.

	:param relatingport
	:type relatingport:ifcport

	:param relatedport
	:type relatedport:ifcport

	:param realizingelement
	:type realizingelement:ifcelement
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingport, relatedport, realizingelement, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatingport = relatingport
        self._relatedport = relatedport
        self._realizingelement = realizingelement

    @property
    def relatingport(self):
        return self._relatingport

    @relatingport.setter
    def relatingport(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcport):
            self._relatingport = ifcport(value)
        else:
            self._relatingport = value

    @property
    def relatedport(self):
        return self._relatedport

    @relatedport.setter
    def relatedport(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcport):
            self._relatedport = ifcport(value)
        else:
            self._relatedport = value

    @property
    def realizingelement(self):
        return self._realizingelement

    @realizingelement.setter
    def realizingelement(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcelement):
                self._realizingelement = ifcelement(value)
            else:
                self._realizingelement = value
        else:
            self._realizingelement = value

    def noselfreference(self):
        eval_noselfreference_wr = (self.relatingport != self.relatedport)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifcsphere #
####################
class ifcsphere(ifccsgprimitive3d):
    '''Entity ifcsphere definition.

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__position, radius, ):
        ifccsgprimitive3d.__init__(self, inherited0__position, )
        self._radius = radius

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._radius = ifcpositivelengthmeasure(value)
        else:
            self._radius = value


####################
# ENTITY ifcconnectedfaceset #
####################
class ifcconnectedfaceset(ifctopologicalrepresentationitem):
    '''Entity ifcconnectedfaceset definition.

	:param cfsfaces
	:type cfsfaces:SET(1,None,'ifcface', scope = schema_scope)
	'''

    def __init__(self, cfsfaces, ):
        ifctopologicalrepresentationitem.__init__(self, )
        self._cfsfaces = cfsfaces

    @property
    def cfsfaces(self):
        return self._cfsfaces

    @cfsfaces.setter
    def cfsfaces(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcface', scope=schema_scope)):
            self._cfsfaces = SET(value)
        else:
            self._cfsfaces = value


####################
# ENTITY ifcopenshell #
####################
class ifcopenshell(ifcconnectedfaceset):
    '''Entity ifcopenshell definition.
	'''

    def __init__(self, inherited0__cfsfaces, ):
        ifcconnectedfaceset.__init__(self, inherited0__cfsfaces, )


####################
# ENTITY ifcboundarynodeconditionwarping #
####################
class ifcboundarynodeconditionwarping(ifcboundarynodecondition):
    '''Entity ifcboundarynodeconditionwarping definition.

	:param warpingstiffness
	:type warpingstiffness:ifcwarpingstiffnessselect
	'''

    def __init__(self, inherited0__name, inherited1__translationalstiffnessx, inherited2__translationalstiffnessy,
                 inherited3__translationalstiffnessz, inherited4__rotationalstiffnessx,
                 inherited5__rotationalstiffnessy, inherited6__rotationalstiffnessz, warpingstiffness, ):
        ifcboundarynodecondition.__init__(self, inherited0__name, inherited1__translationalstiffnessx,
                                          inherited2__translationalstiffnessy, inherited3__translationalstiffnessz,
                                          inherited4__rotationalstiffnessx, inherited5__rotationalstiffnessy,
                                          inherited6__rotationalstiffnessz, )
        self._warpingstiffness = warpingstiffness

    @property
    def warpingstiffness(self):
        return self._warpingstiffness

    @warpingstiffness.setter
    def warpingstiffness(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcwarpingstiffnessselect):
                self._warpingstiffness = ifcwarpingstiffnessselect(value)
            else:
                self._warpingstiffness = value
        else:
            self._warpingstiffness = value


####################
# ENTITY ifcrelprojectselement #
####################
class ifcrelprojectselement(ifcreldecomposes):
    '''Entity ifcrelprojectselement definition.

	:param relatingelement
	:type relatingelement:ifcelement

	:param relatedfeatureelement
	:type relatedfeatureelement:ifcfeatureelementaddition
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingelement, relatedfeatureelement, ):
        ifcreldecomposes.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                  inherited3__description, )
        self._relatingelement = relatingelement
        self._relatedfeatureelement = relatedfeatureelement

    @property
    def relatingelement(self):
        return self._relatingelement

    @relatingelement.setter
    def relatingelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelement):
            self._relatingelement = ifcelement(value)
        else:
            self._relatingelement = value

    @property
    def relatedfeatureelement(self):
        return self._relatedfeatureelement

    @relatedfeatureelement.setter
    def relatedfeatureelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcfeatureelementaddition):
            self._relatedfeatureelement = ifcfeatureelementaddition(value)
        else:
            self._relatedfeatureelement = value


####################
# ENTITY ifcsweptdisksolid #
####################
class ifcsweptdisksolid(ifcsolidmodel):
    '''Entity ifcsweptdisksolid definition.

	:param directrix
	:type directrix:ifccurve

	:param radius
	:type radius:ifcpositivelengthmeasure

	:param innerradius
	:type innerradius:ifcpositivelengthmeasure

	:param startparam
	:type startparam:ifcparametervalue

	:param endparam
	:type endparam:ifcparametervalue
	'''

    def __init__(self, directrix, radius, innerradius, startparam, endparam, ):
        ifcsolidmodel.__init__(self, )
        self._directrix = directrix
        self._radius = radius
        self._innerradius = innerradius
        self._startparam = startparam
        self._endparam = endparam

    @property
    def directrix(self):
        return self._directrix

    @directrix.setter
    def directrix(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._directrix = ifccurve(value)
        else:
            self._directrix = value

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._radius = ifcpositivelengthmeasure(value)
        else:
            self._radius = value

    @property
    def innerradius(self):
        return self._innerradius

    @innerradius.setter
    def innerradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._innerradius = ifcpositivelengthmeasure(value)
            else:
                self._innerradius = value
        else:
            self._innerradius = value

    @property
    def startparam(self):
        return self._startparam

    @startparam.setter
    def startparam(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcparametervalue):
                self._startparam = ifcparametervalue(value)
            else:
                self._startparam = value
        else:
            self._startparam = value

    @property
    def endparam(self):
        return self._endparam

    @endparam.setter
    def endparam(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcparametervalue):
                self._endparam = ifcparametervalue(value)
            else:
                self._endparam = value
        else:
            self._endparam = value

    def directrixdim(self):
        eval_directrixdim_wr = (self.directrix.self.dim == 3)
        if not eval_directrixdim_wr:
            raise AssertionError('Rule directrixdim violated')
        else:
            return eval_directrixdim_wr

    def innerradiussize(self):
        eval_innerradiussize_wr = ((not EXISTS(self.innerradius)) or (self.radius > self.innerradius))
        if not eval_innerradiussize_wr:
            raise AssertionError('Rule innerradiussize violated')
        else:
            return eval_innerradiussize_wr

    def directrixbounded(self):
        eval_directrixbounded_wr = ((EXISTS(self.startparam) and EXISTS(self.endparam)) or (
                    SIZEOF(['IFC4X2.IFCCONIC', 'IFC4X2.IFCBOUNDEDCURVE'] * TYPEOF(self.directrix)) == 1))
        if not eval_directrixbounded_wr:
            raise AssertionError('Rule directrixbounded violated')
        else:
            return eval_directrixbounded_wr


####################
# ENTITY ifcsweptdisksolidpolygonal #
####################
class ifcsweptdisksolidpolygonal(ifcsweptdisksolid):
    '''Entity ifcsweptdisksolidpolygonal definition.

	:param filletradius
	:type filletradius:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__directrix, inherited1__radius, inherited2__innerradius, inherited3__startparam,
                 inherited4__endparam, filletradius, ):
        ifcsweptdisksolid.__init__(self, inherited0__directrix, inherited1__radius, inherited2__innerradius,
                                   inherited3__startparam, inherited4__endparam, )
        self._filletradius = filletradius

    @property
    def filletradius(self):
        return self._filletradius

    @filletradius.setter
    def filletradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._filletradius = ifcpositivelengthmeasure(value)
            else:
                self._filletradius = value
        else:
            self._filletradius = value

    def correctradii(self):
        eval_correctradii_wr = (
                    (not EXISTS(self.filletradius)) or (self.filletradius >= self.self.ifcsweptdisksolid.self.radius))
        if not eval_correctradii_wr:
            raise AssertionError('Rule correctradii violated')
        else:
            return eval_correctradii_wr

    def directrixispolyline(self):
        eval_directrixispolyline_wr = (('IFC4X2.IFCPOLYLINE' == TYPEOF(self.self.ifcsweptdisksolid.self.directrix)) or (
                    ('IFC4X2.IFCINDEXEDPOLYCURVE' == TYPEOF(self.self.ifcsweptdisksolid.self.directrix)) and (
                not EXISTS(self.self.ifcsweptdisksolid.self.directrix.self.segments))))
        if not eval_directrixispolyline_wr:
            raise AssertionError('Rule directrixispolyline violated')
        else:
            return eval_directrixispolyline_wr


####################
# ENTITY ifcdampertype #
####################
class ifcdampertype(ifcflowcontrollertype):
    '''Entity ifcdampertype definition.

	:param predefinedtype
	:type predefinedtype:ifcdampertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowcontrollertype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__applicableoccurrence,
                                       inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                       inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdampertypeenum):
            self._predefinedtype = ifcdampertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcdampertypeenum.userdefined) or (
                    (self.predefinedtype == ifcdampertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcsite #
####################
class ifcsite(ifcspatialstructureelement):
    '''Entity ifcsite definition.

	:param reflatitude
	:type reflatitude:LIST(3,4,'INTEGER', scope = schema_scope)

	:param reflongitude
	:type reflongitude:LIST(3,4,'INTEGER', scope = schema_scope)

	:param refelevation
	:type refelevation:ifclengthmeasure

	:param landtitlenumber
	:type landtitlenumber:ifclabel

	:param siteaddress
	:type siteaddress:ifcpostaladdress
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__longname,
                 inherited8__compositiontype, reflatitude, reflongitude, refelevation, landtitlenumber, siteaddress, ):
        ifcspatialstructureelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation,
                                            inherited7__longname, inherited8__compositiontype, )
        self._reflatitude = reflatitude
        self._reflongitude = reflongitude
        self._refelevation = refelevation
        self._landtitlenumber = landtitlenumber
        self._siteaddress = siteaddress

    @property
    def reflatitude(self):
        return self._reflatitude

    @reflatitude.setter
    def reflatitude(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(3, 4, 'INTEGER', scope=schema_scope)):
                self._reflatitude = LIST(value)
            else:
                self._reflatitude = value
        else:
            self._reflatitude = value

    @property
    def reflongitude(self):
        return self._reflongitude

    @reflongitude.setter
    def reflongitude(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(3, 4, 'INTEGER', scope=schema_scope)):
                self._reflongitude = LIST(value)
            else:
                self._reflongitude = value
        else:
            self._reflongitude = value

    @property
    def refelevation(self):
        return self._refelevation

    @refelevation.setter
    def refelevation(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._refelevation = ifclengthmeasure(value)
            else:
                self._refelevation = value
        else:
            self._refelevation = value

    @property
    def landtitlenumber(self):
        return self._landtitlenumber

    @landtitlenumber.setter
    def landtitlenumber(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._landtitlenumber = ifclabel(value)
            else:
                self._landtitlenumber = value
        else:
            self._landtitlenumber = value

    @property
    def siteaddress(self):
        return self._siteaddress

    @siteaddress.setter
    def siteaddress(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpostaladdress):
                self._siteaddress = ifcpostaladdress(value)
            else:
                self._siteaddress = value
        else:
            self._siteaddress = value


####################
# ENTITY ifccoil #
####################
class ifccoil(ifcenergyconversiondevice):
    '''Entity ifccoil definition.

	:param predefinedtype
	:type predefinedtype:ifccoiltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccoiltypeenum):
                self._predefinedtype = ifccoiltypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifccoiltypeenum.userdefined)) or (
                        (self.predefinedtype == ifccoiltypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCOILTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcrelassociateslibrary #
####################
class ifcrelassociateslibrary(ifcrelassociates):
    '''Entity ifcrelassociateslibrary definition.

	:param relatinglibrary
	:type relatinglibrary:ifclibraryselect
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatedobjects, relatinglibrary, ):
        ifcrelassociates.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                  inherited3__description, inherited4__relatedobjects, )
        self._relatinglibrary = relatinglibrary

    @property
    def relatinglibrary(self):
        return self._relatinglibrary

    @relatinglibrary.setter
    def relatinglibrary(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclibraryselect):
            self._relatinglibrary = ifclibraryselect(value)
        else:
            self._relatinglibrary = value


####################
# ENTITY ifcoutlettype #
####################
class ifcoutlettype(ifcflowterminaltype):
    '''Entity ifcoutlettype definition.

	:param predefinedtype
	:type predefinedtype:ifcoutlettypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowterminaltype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__applicableoccurrence,
                                     inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                     inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcoutlettypeenum):
            self._predefinedtype = ifcoutlettypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcoutlettypeenum.userdefined) or (
                    (self.predefinedtype == ifcoutlettypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifctasktype #
####################
class ifctasktype(ifctypeprocess):
    '''Entity ifctasktype definition.

	:param predefinedtype
	:type predefinedtype:ifctasktypeenum

	:param workmethod
	:type workmethod:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__identification,
                 inherited7__longdescription, inherited8__processtype, predefinedtype, workmethod, ):
        ifctypeprocess.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__identification, inherited7__longdescription, inherited8__processtype, )
        self._predefinedtype = predefinedtype
        self._workmethod = workmethod

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctasktypeenum):
            self._predefinedtype = ifctasktypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def workmethod(self):
        return self._workmethod

    @workmethod.setter
    def workmethod(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._workmethod = ifclabel(value)
            else:
                self._workmethod = value
        else:
            self._workmethod = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifctasktypeenum.userdefined) or (
                    (self.predefinedtype == ifctasktypeenum.userdefined) and EXISTS(
                self.self.ifctypeprocess.self.processtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcvalve #
####################
class ifcvalve(ifcflowcontroller):
    '''Entity ifcvalve definition.

	:param predefinedtype
	:type predefinedtype:ifcvalvetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowcontroller.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcvalvetypeenum):
                self._predefinedtype = ifcvalvetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcvalvetypeenum.userdefined)) or (
                        (self.predefinedtype == ifcvalvetypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCVALVETYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcelectricmotor #
####################
class ifcelectricmotor(ifcenergyconversiondevice):
    '''Entity ifcelectricmotor definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricmotortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcelectricmotortypeenum):
                self._predefinedtype = ifcelectricmotortypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcelectricmotortypeenum.userdefined)) or ((
                                                                                                  self.predefinedtype == ifcelectricmotortypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCELECTRICMOTORTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcgeometricrepresentationsubcontext #
####################
class ifcgeometricrepresentationsubcontext(ifcgeometricrepresentationcontext):
    '''Entity ifcgeometricrepresentationsubcontext definition.

	:param parentcontext
	:type parentcontext:ifcgeometricrepresentationcontext

	:param targetscale
	:type targetscale:ifcpositiveratiomeasure

	:param targetview
	:type targetview:ifcgeometricprojectionenum

	:param userdefinedtargetview
	:type userdefinedtargetview:ifclabel

	:param worldcoordinatesystem
	:type worldcoordinatesystem:ifcaxis2placement

	:param coordinatespacedimension
	:type coordinatespacedimension:ifcdimensioncount

	:param truenorth
	:type truenorth:ifcdirection

	:param precision
	:type precision:ifcreal
	'''

    def __init__(self, inherited0__contextidentifier, inherited1__contexttype, inherited2__coordinatespacedimension,
                 inherited3__precision, inherited4__worldcoordinatesystem, inherited5__truenorth, parentcontext,
                 targetscale, targetview, userdefinedtargetview, ):
        ifcgeometricrepresentationcontext.__init__(self, inherited0__contextidentifier, inherited1__contexttype,
                                                   inherited2__coordinatespacedimension, inherited3__precision,
                                                   inherited4__worldcoordinatesystem, inherited5__truenorth, )
        self._parentcontext = parentcontext
        self._targetscale = targetscale
        self._targetview = targetview
        self._userdefinedtargetview = userdefinedtargetview

    @property
    def parentcontext(self):
        return self._parentcontext

    @parentcontext.setter
    def parentcontext(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcgeometricrepresentationcontext):
            self._parentcontext = ifcgeometricrepresentationcontext(value)
        else:
            self._parentcontext = value

    @property
    def targetscale(self):
        return self._targetscale

    @targetscale.setter
    def targetscale(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositiveratiomeasure):
                self._targetscale = ifcpositiveratiomeasure(value)
            else:
                self._targetscale = value
        else:
            self._targetscale = value

    @property
    def targetview(self):
        return self._targetview

    @targetview.setter
    def targetview(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcgeometricprojectionenum):
            self._targetview = ifcgeometricprojectionenum(value)
        else:
            self._targetview = value

    @property
    def userdefinedtargetview(self):
        return self._userdefinedtargetview

    @userdefinedtargetview.setter
    def userdefinedtargetview(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefinedtargetview = ifclabel(value)
            else:
                self._userdefinedtargetview = value
        else:
            self._userdefinedtargetview = value

    @property
    def worldcoordinatesystem(self):
        attribute_eval = self.parentcontext.self.worldcoordinatesystem
        return attribute_eval

    @worldcoordinatesystem.setter
    def worldcoordinatesystem(self, value):
        # DERIVED argument
        raise AssertionError(
            'Argument worldcoordinatesystem is DERIVED. It is computed and can not be set to any value')

    @property
    def coordinatespacedimension(self):
        attribute_eval = self.parentcontext.self.coordinatespacedimension
        return attribute_eval

    @coordinatespacedimension.setter
    def coordinatespacedimension(self, value):
        # DERIVED argument
        raise AssertionError(
            'Argument coordinatespacedimension is DERIVED. It is computed and can not be set to any value')

    @property
    def truenorth(self):
        attribute_eval = NVL(self.parentcontext.self.truenorth, ifcconvertdirectioninto2d(
            self.self.ifcgeometricrepresentationcontext.self.worldcoordinatesystem.self.p[2]))
        return attribute_eval

    @truenorth.setter
    def truenorth(self, value):
        # DERIVED argument
        raise AssertionError('Argument truenorth is DERIVED. It is computed and can not be set to any value')

    @property
    def precision(self):
        attribute_eval = NVL(self.parentcontext.self.precision, 1e-05)
        return attribute_eval

    @precision.setter
    def precision(self, value):
        # DERIVED argument
        raise AssertionError('Argument precision is DERIVED. It is computed and can not be set to any value')

    def parentnosub(self):
        eval_parentnosub_wr = (not ('IFC4X2.IFCGEOMETRICREPRESENTATIONSUBCONTEXT' == TYPEOF(self.parentcontext)))
        if not eval_parentnosub_wr:
            raise AssertionError('Rule parentnosub violated')
        else:
            return eval_parentnosub_wr

    def usertargetprovided(self):
        eval_usertargetprovided_wr = ((self.targetview != ifcgeometricprojectionenum.userdefined) or (
                    (self.targetview == ifcgeometricprojectionenum.userdefined) and EXISTS(self.userdefinedtargetview)))
        if not eval_usertargetprovided_wr:
            raise AssertionError('Rule usertargetprovided violated')
        else:
            return eval_usertargetprovided_wr

    def nocoordoperation(self):
        eval_nocoordoperation_wr = (
                    SIZEOF(self.self.ifcgeometricrepresentationcontext.self.hascoordinateoperation) == 0)
        if not eval_nocoordoperation_wr:
            raise AssertionError('Rule nocoordoperation violated')
        else:
            return eval_nocoordoperation_wr


####################
# ENTITY ifcreldefinesbytemplate #
####################
class ifcreldefinesbytemplate(ifcreldefines):
    '''Entity ifcreldefinesbytemplate definition.

	:param relatedpropertysets
	:type relatedpropertysets:SET(1,None,'ifcpropertysetdefinition', scope = schema_scope)

	:param relatingtemplate
	:type relatingtemplate:ifcpropertysettemplate
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatedpropertysets, relatingtemplate, ):
        ifcreldefines.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                               inherited3__description, )
        self._relatedpropertysets = relatedpropertysets
        self._relatingtemplate = relatingtemplate

    @property
    def relatedpropertysets(self):
        return self._relatedpropertysets

    @relatedpropertysets.setter
    def relatedpropertysets(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcpropertysetdefinition', scope=schema_scope)):
            self._relatedpropertysets = SET(value)
        else:
            self._relatedpropertysets = value

    @property
    def relatingtemplate(self):
        return self._relatingtemplate

    @relatingtemplate.setter
    def relatingtemplate(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpropertysettemplate):
            self._relatingtemplate = ifcpropertysettemplate(value)
        else:
            self._relatingtemplate = value


####################
# ENTITY ifcwallelementedcase #
####################
class ifcwallelementedcase(ifcwall):
    '''Entity ifcwallelementedcase definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__predefinedtype, ):
        ifcwall.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                         inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                         inherited6__representation, inherited7__tag, inherited8__predefinedtype, )

    def hasdecomposition(self):
        eval_hasdecomposition_wr = (HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby) > 0)
        if not eval_hasdecomposition_wr:
            raise AssertionError('Rule hasdecomposition violated')
        else:
            return eval_hasdecomposition_wr


####################
# ENTITY ifcmaterialconstituent #
####################
class ifcmaterialconstituent(ifcmaterialdefinition):
    '''Entity ifcmaterialconstituent definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param material
	:type material:ifcmaterial

	:param fraction
	:type fraction:ifcnormalisedratiomeasure

	:param category
	:type category:ifclabel

	:param tomaterialconstituentset
	:type tomaterialconstituentset:ifcmaterialconstituentset
	'''

    def __init__(self, name, description, material, fraction, category, ):
        ifcmaterialdefinition.__init__(self, )
        self._name = name
        self._description = description
        self._material = material
        self._fraction = fraction
        self._category = category

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def material(self):
        return self._material

    @material.setter
    def material(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmaterial):
            self._material = ifcmaterial(value)
        else:
            self._material = value

    @property
    def fraction(self):
        return self._fraction

    @fraction.setter
    def fraction(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnormalisedratiomeasure):
                self._fraction = ifcnormalisedratiomeasure(value)
            else:
                self._fraction = value
        else:
            self._fraction = value

    @property
    def category(self):
        return self._category

    @category.setter
    def category(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._category = ifclabel(value)
            else:
                self._category = value
        else:
            self._category = value

    @property
    def tomaterialconstituentset(self):
        return self._tomaterialconstituentset

    @tomaterialconstituentset.setter
    def tomaterialconstituentset(self, value):
        # INVERSE argument
        raise AssertionError(
            'Argument tomaterialconstituentset is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcpolyline #
####################
class ifcpolyline(ifcboundedcurve):
    '''Entity ifcpolyline definition.

	:param points
	:type points:LIST(2,None,'ifccartesianpoint', scope = schema_scope)
	'''

    def __init__(self, points, ):
        ifcboundedcurve.__init__(self, )
        self._points = points

    @property
    def points(self):
        return self._points

    @points.setter
    def points(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, 'ifccartesianpoint', scope=schema_scope)):
            self._points = LIST(value)
        else:
            self._points = value

    def samedim(self):
        eval_samedim_wr = (SIZEOF(None) == 0)
        if not eval_samedim_wr:
            raise AssertionError('Rule samedim violated')
        else:
            return eval_samedim_wr


####################
# ENTITY ifccurveboundedsurface #
####################
class ifccurveboundedsurface(ifcboundedsurface):
    '''Entity ifccurveboundedsurface definition.

	:param basissurface
	:type basissurface:ifcsurface

	:param boundaries
	:type boundaries:SET(1,None,'ifcboundarycurve', scope = schema_scope)

	:param implicitouter
	:type implicitouter:ifcboolean
	'''

    def __init__(self, basissurface, boundaries, implicitouter, ):
        ifcboundedsurface.__init__(self, )
        self._basissurface = basissurface
        self._boundaries = boundaries
        self._implicitouter = implicitouter

    @property
    def basissurface(self):
        return self._basissurface

    @basissurface.setter
    def basissurface(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsurface):
            self._basissurface = ifcsurface(value)
        else:
            self._basissurface = value

    @property
    def boundaries(self):
        return self._boundaries

    @boundaries.setter
    def boundaries(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcboundarycurve', scope=schema_scope)):
            self._boundaries = SET(value)
        else:
            self._boundaries = value

    @property
    def implicitouter(self):
        return self._implicitouter

    @implicitouter.setter
    def implicitouter(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._implicitouter = ifcboolean(value)
        else:
            self._implicitouter = value


####################
# ENTITY ifcdistributionchamberelementtype #
####################
class ifcdistributionchamberelementtype(ifcdistributionflowelementtype):
    '''Entity ifcdistributionchamberelementtype definition.

	:param predefinedtype
	:type predefinedtype:ifcdistributionchamberelementtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcdistributionflowelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                                inherited3__description, inherited4__applicableoccurrence,
                                                inherited5__haspropertysets, inherited6__representationmaps,
                                                inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdistributionchamberelementtypeenum):
            self._predefinedtype = ifcdistributionchamberelementtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcdistributionchamberelementtypeenum.userdefined) or (
                    (self.predefinedtype == ifcdistributionchamberelementtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcrelaggregates #
####################
class ifcrelaggregates(ifcreldecomposes):
    '''Entity ifcrelaggregates definition.

	:param relatingobject
	:type relatingobject:ifcobjectdefinition

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcobjectdefinition', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingobject, relatedobjects, ):
        ifcreldecomposes.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                  inherited3__description, )
        self._relatingobject = relatingobject
        self._relatedobjects = relatedobjects

    @property
    def relatingobject(self):
        return self._relatingobject

    @relatingobject.setter
    def relatingobject(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcobjectdefinition):
            self._relatingobject = ifcobjectdefinition(value)
        else:
            self._relatingobject = value

    @property
    def relatedobjects(self):
        return self._relatedobjects

    @relatedobjects.setter
    def relatedobjects(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcobjectdefinition', scope=schema_scope)):
            self._relatedobjects = SET(value)
        else:
            self._relatedobjects = value

    def noselfreference(self):
        eval_noselfreference_wr = (SIZEOF(None) == 0)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifcrepresentationmap #
####################
class ifcrepresentationmap(BaseEntityClass):
    '''Entity ifcrepresentationmap definition.

	:param mappingorigin
	:type mappingorigin:ifcaxis2placement

	:param mappedrepresentation
	:type mappedrepresentation:ifcrepresentation

	:param hasshapeaspects
	:type hasshapeaspects:SET(0,None,'ifcshapeaspect', scope = schema_scope)

	:param mapusage
	:type mapusage:SET(0,None,'ifcmappeditem', scope = schema_scope)
	'''

    def __init__(self, mappingorigin, mappedrepresentation, ):
        self._mappingorigin = mappingorigin
        self._mappedrepresentation = mappedrepresentation

    @property
    def mappingorigin(self):
        return self._mappingorigin

    @mappingorigin.setter
    def mappingorigin(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcaxis2placement):
            self._mappingorigin = ifcaxis2placement(value)
        else:
            self._mappingorigin = value

    @property
    def mappedrepresentation(self):
        return self._mappedrepresentation

    @mappedrepresentation.setter
    def mappedrepresentation(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcrepresentation):
            self._mappedrepresentation = ifcrepresentation(value)
        else:
            self._mappedrepresentation = value

    @property
    def hasshapeaspects(self):
        return self._hasshapeaspects

    @hasshapeaspects.setter
    def hasshapeaspects(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasshapeaspects is INVERSE. It is computed and can not be set to any value')

    @property
    def mapusage(self):
        return self._mapusage

    @mapusage.setter
    def mapusage(self, value):
        # INVERSE argument
        raise AssertionError('Argument mapusage is INVERSE. It is computed and can not be set to any value')

    def applicablemappedrepr(self):
        eval_applicablemappedrepr_wr = ('IFC4X2.IFCSHAPEMODEL' == TYPEOF(self.mappedrepresentation))
        if not eval_applicablemappedrepr_wr:
            raise AssertionError('Rule applicablemappedrepr violated')
        else:
            return eval_applicablemappedrepr_wr


####################
# ENTITY ifcstructuralsurfaceconnection #
####################
class ifcstructuralsurfaceconnection(ifcstructuralconnection):
    '''Entity ifcstructuralsurfaceconnection definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__appliedcondition, ):
        ifcstructuralconnection.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                         inherited6__representation, inherited7__appliedcondition, )


####################
# ENTITY ifctexturemap #
####################
class ifctexturemap(ifctexturecoordinate):
    '''Entity ifctexturemap definition.

	:param vertices
	:type vertices:LIST(3,None,'ifctexturevertex', scope = schema_scope)

	:param mappedto
	:type mappedto:ifcface
	'''

    def __init__(self, inherited0__maps, vertices, mappedto, ):
        ifctexturecoordinate.__init__(self, inherited0__maps, )
        self._vertices = vertices
        self._mappedto = mappedto

    @property
    def vertices(self):
        return self._vertices

    @vertices.setter
    def vertices(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(3, None, 'ifctexturevertex', scope=schema_scope)):
            self._vertices = LIST(value)
        else:
            self._vertices = value

    @property
    def mappedto(self):
        return self._mappedto

    @mappedto.setter
    def mappedto(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcface):
            self._mappedto = ifcface(value)
        else:
            self._mappedto = value


####################
# ENTITY ifcconstructionmaterialresourcetype #
####################
class ifcconstructionmaterialresourcetype(ifcconstructionresourcetype):
    '''Entity ifcconstructionmaterialresourcetype definition.

	:param predefinedtype
	:type predefinedtype:ifcconstructionmaterialresourcetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__identification,
                 inherited7__longdescription, inherited8__resourcetype, inherited9__basecosts,
                 inherited10__basequantity, predefinedtype, ):
        ifcconstructionresourcetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                             inherited3__description, inherited4__applicableoccurrence,
                                             inherited5__haspropertysets, inherited6__identification,
                                             inherited7__longdescription, inherited8__resourcetype,
                                             inherited9__basecosts, inherited10__basequantity, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcconstructionmaterialresourcetypeenum):
            self._predefinedtype = ifcconstructionmaterialresourcetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    (self.predefinedtype != ifcconstructionmaterialresourcetypeenum.userdefined) or (
                        (self.predefinedtype == ifcconstructionmaterialresourcetypeenum.userdefined) and EXISTS(
                    self.self.ifctyperesource.self.resourcetype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcexternalreferencerelationship #
####################
class ifcexternalreferencerelationship(ifcresourcelevelrelationship):
    '''Entity ifcexternalreferencerelationship definition.

	:param relatingreference
	:type relatingreference:ifcexternalreference

	:param relatedresourceobjects
	:type relatedresourceobjects:SET(1,None,'ifcresourceobjectselect', scope = schema_scope)
	'''

    def __init__(self, inherited0__name, inherited1__description, relatingreference, relatedresourceobjects, ):
        ifcresourcelevelrelationship.__init__(self, inherited0__name, inherited1__description, )
        self._relatingreference = relatingreference
        self._relatedresourceobjects = relatedresourceobjects

    @property
    def relatingreference(self):
        return self._relatingreference

    @relatingreference.setter
    def relatingreference(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcexternalreference):
            self._relatingreference = ifcexternalreference(value)
        else:
            self._relatingreference = value

    @property
    def relatedresourceobjects(self):
        return self._relatedresourceobjects

    @relatedresourceobjects.setter
    def relatedresourceobjects(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcresourceobjectselect', scope=schema_scope)):
            self._relatedresourceobjects = SET(value)
        else:
            self._relatedresourceobjects = value


####################
# ENTITY ifcpresentationstyleassignment #
####################
class ifcpresentationstyleassignment(BaseEntityClass):
    '''Entity ifcpresentationstyleassignment definition.

	:param styles
	:type styles:SET(1,None,'ifcpresentationstyleselect', scope = schema_scope)
	'''

    def __init__(self, styles, ):
        self._styles = styles

    @property
    def styles(self):
        return self._styles

    @styles.setter
    def styles(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcpresentationstyleselect', scope=schema_scope)):
            self._styles = SET(value)
        else:
            self._styles = value


####################
# ENTITY ifcpropertyset #
####################
class ifcpropertyset(ifcpropertysetdefinition):
    '''Entity ifcpropertyset definition.

	:param hasproperties
	:type hasproperties:SET(1,None,'ifcproperty', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 hasproperties, ):
        ifcpropertysetdefinition.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, )
        self._hasproperties = hasproperties

    @property
    def hasproperties(self):
        return self._hasproperties

    @hasproperties.setter
    def hasproperties(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcproperty', scope=schema_scope)):
            self._hasproperties = SET(value)
        else:
            self._hasproperties = value

    def existsname(self):
        eval_existsname_wr = EXISTS(self.self.ifcroot.self.name)
        if not eval_existsname_wr:
            raise AssertionError('Rule existsname violated')
        else:
            return eval_existsname_wr

    def uniquepropertynames(self):
        eval_uniquepropertynames_wr = ifcuniquepropertyname(self.hasproperties)
        if not eval_uniquepropertynames_wr:
            raise AssertionError('Rule uniquepropertynames violated')
        else:
            return eval_uniquepropertynames_wr


####################
# ENTITY ifcflowmeter #
####################
class ifcflowmeter(ifcflowcontroller):
    '''Entity ifcflowmeter definition.

	:param predefinedtype
	:type predefinedtype:ifcflowmetertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowcontroller.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcflowmetertypeenum):
                self._predefinedtype = ifcflowmetertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcflowmetertypeenum.userdefined)) or ((
                                                                                              self.predefinedtype == ifcflowmetertypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCFLOWMETERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcpointonsurface #
####################
class ifcpointonsurface(ifcpoint):
    '''Entity ifcpointonsurface definition.

	:param basissurface
	:type basissurface:ifcsurface

	:param pointparameteru
	:type pointparameteru:ifcparametervalue

	:param pointparameterv
	:type pointparameterv:ifcparametervalue

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, basissurface, pointparameteru, pointparameterv, ):
        ifcpoint.__init__(self, )
        self._basissurface = basissurface
        self._pointparameteru = pointparameteru
        self._pointparameterv = pointparameterv

    @property
    def basissurface(self):
        return self._basissurface

    @basissurface.setter
    def basissurface(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsurface):
            self._basissurface = ifcsurface(value)
        else:
            self._basissurface = value

    @property
    def pointparameteru(self):
        return self._pointparameteru

    @pointparameteru.setter
    def pointparameteru(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcparametervalue):
            self._pointparameteru = ifcparametervalue(value)
        else:
            self._pointparameteru = value

    @property
    def pointparameterv(self):
        return self._pointparameterv

    @pointparameterv.setter
    def pointparameterv(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcparametervalue):
            self._pointparameterv = ifcparametervalue(value)
        else:
            self._pointparameterv = value

    @property
    def dim(self):
        attribute_eval = self.basissurface.self.dim
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcprojectedcrs #
####################
class ifcprojectedcrs(ifccoordinatereferencesystem):
    '''Entity ifcprojectedcrs definition.

	:param mapprojection
	:type mapprojection:ifcidentifier

	:param mapzone
	:type mapzone:ifcidentifier

	:param mapunit
	:type mapunit:ifcnamedunit
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__geodeticdatum, inherited3__verticaldatum,
                 mapprojection, mapzone, mapunit, ):
        ifccoordinatereferencesystem.__init__(self, inherited0__name, inherited1__description,
                                              inherited2__geodeticdatum, inherited3__verticaldatum, )
        self._mapprojection = mapprojection
        self._mapzone = mapzone
        self._mapunit = mapunit

    @property
    def mapprojection(self):
        return self._mapprojection

    @mapprojection.setter
    def mapprojection(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._mapprojection = ifcidentifier(value)
            else:
                self._mapprojection = value
        else:
            self._mapprojection = value

    @property
    def mapzone(self):
        return self._mapzone

    @mapzone.setter
    def mapzone(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._mapzone = ifcidentifier(value)
            else:
                self._mapzone = value
        else:
            self._mapzone = value

    @property
    def mapunit(self):
        return self._mapunit

    @mapunit.setter
    def mapunit(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnamedunit):
                self._mapunit = ifcnamedunit(value)
            else:
                self._mapunit = value
        else:
            self._mapunit = value

    def islengthunit(self):
        eval_islengthunit_wr = ((not EXISTS(self.mapunit)) or (self.mapunit.self.unittype == ifcunitenum.lengthunit))
        if not eval_islengthunit_wr:
            raise AssertionError('Rule islengthunit violated')
        else:
            return eval_islengthunit_wr


####################
# ENTITY ifccablesegment #
####################
class ifccablesegment(ifcflowsegment):
    '''Entity ifccablesegment definition.

	:param predefinedtype
	:type predefinedtype:ifccablesegmenttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowsegment.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccablesegmenttypeenum):
                self._predefinedtype = ifccablesegmenttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifccablesegmenttypeenum.userdefined)) or ((
                                                                                                 self.predefinedtype == ifccablesegmenttypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCABLESEGMENTTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcconstructionproductresourcetype #
####################
class ifcconstructionproductresourcetype(ifcconstructionresourcetype):
    '''Entity ifcconstructionproductresourcetype definition.

	:param predefinedtype
	:type predefinedtype:ifcconstructionproductresourcetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__identification,
                 inherited7__longdescription, inherited8__resourcetype, inherited9__basecosts,
                 inherited10__basequantity, predefinedtype, ):
        ifcconstructionresourcetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                             inherited3__description, inherited4__applicableoccurrence,
                                             inherited5__haspropertysets, inherited6__identification,
                                             inherited7__longdescription, inherited8__resourcetype,
                                             inherited9__basecosts, inherited10__basequantity, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcconstructionproductresourcetypeenum):
            self._predefinedtype = ifcconstructionproductresourcetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    (self.predefinedtype != ifcconstructionproductresourcetypeenum.userdefined) or (
                        (self.predefinedtype == ifcconstructionproductresourcetypeenum.userdefined) and EXISTS(
                    self.self.ifctyperesource.self.resourcetype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcoffsetcurve3d #
####################
class ifcoffsetcurve3d(ifcoffsetcurve):
    '''Entity ifcoffsetcurve3d definition.

	:param distance
	:type distance:ifclengthmeasure

	:param selfintersect
	:type selfintersect:ifclogical

	:param refdirection
	:type refdirection:ifcdirection
	'''

    def __init__(self, inherited0__basiscurve, distance, selfintersect, refdirection, ):
        ifcoffsetcurve.__init__(self, inherited0__basiscurve, )
        self._distance = distance
        self._selfintersect = selfintersect
        self._refdirection = refdirection

    @property
    def distance(self):
        return self._distance

    @distance.setter
    def distance(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._distance = ifclengthmeasure(value)
        else:
            self._distance = value

    @property
    def selfintersect(self):
        return self._selfintersect

    @selfintersect.setter
    def selfintersect(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclogical):
            self._selfintersect = ifclogical(value)
        else:
            self._selfintersect = value

    @property
    def refdirection(self):
        return self._refdirection

    @refdirection.setter
    def refdirection(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdirection):
            self._refdirection = ifcdirection(value)
        else:
            self._refdirection = value

    def dimis2d(self):
        eval_dimis2d_wr = (self.basiscurve.self.dim == 3)
        if not eval_dimis2d_wr:
            raise AssertionError('Rule dimis2d violated')
        else:
            return eval_dimis2d_wr


####################
# ENTITY ifcrelcontainedinspatialstructure #
####################
class ifcrelcontainedinspatialstructure(ifcrelconnects):
    '''Entity ifcrelcontainedinspatialstructure definition.

	:param relatedelements
	:type relatedelements:SET(1,None,'ifcproduct', scope = schema_scope)

	:param relatingstructure
	:type relatingstructure:ifcspatialelement
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatedelements, relatingstructure, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatedelements = relatedelements
        self._relatingstructure = relatingstructure

    @property
    def relatedelements(self):
        return self._relatedelements

    @relatedelements.setter
    def relatedelements(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcproduct', scope=schema_scope)):
            self._relatedelements = SET(value)
        else:
            self._relatedelements = value

    @property
    def relatingstructure(self):
        return self._relatingstructure

    @relatingstructure.setter
    def relatingstructure(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcspatialelement):
            self._relatingstructure = ifcspatialelement(value)
        else:
            self._relatingstructure = value

    def wr31(self):
        eval_wr31_wr = (SIZEOF(None) == 0)
        if not eval_wr31_wr:
            raise AssertionError('Rule wr31 violated')
        else:
            return eval_wr31_wr


####################
# ENTITY ifcpropertyenumeration #
####################
class ifcpropertyenumeration(ifcpropertyabstraction):
    '''Entity ifcpropertyenumeration definition.

	:param name
	:type name:ifclabel

	:param enumerationvalues
	:type enumerationvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param unit
	:type unit:ifcunit
	'''

    def __init__(self, name, enumerationvalues, unit, ):
        ifcpropertyabstraction.__init__(self, )
        self._name = name
        self._enumerationvalues = enumerationvalues
        self._unit = unit

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value

    @property
    def enumerationvalues(self):
        return self._enumerationvalues

    @enumerationvalues.setter
    def enumerationvalues(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcvalue', scope=schema_scope)):
            self._enumerationvalues = LIST(value)
        else:
            self._enumerationvalues = value

    @property
    def unit(self):
        return self._unit

    @unit.setter
    def unit(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcunit):
                self._unit = ifcunit(value)
            else:
                self._unit = value
        else:
            self._unit = value

    def wr01(self):
        eval_wr01_wr = (SIZEOF(None) == 0)
        if not eval_wr01_wr:
            raise AssertionError('Rule wr01 violated')
        else:
            return eval_wr01_wr


####################
# ENTITY ifcprotectivedevicetrippingunittype #
####################
class ifcprotectivedevicetrippingunittype(ifcdistributioncontrolelementtype):
    '''Entity ifcprotectivedevicetrippingunittype definition.

	:param predefinedtype
	:type predefinedtype:ifcprotectivedevicetrippingunittypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcdistributioncontrolelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory,
                                                   inherited2__name, inherited3__description,
                                                   inherited4__applicableoccurrence, inherited5__haspropertysets,
                                                   inherited6__representationmaps, inherited7__tag,
                                                   inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprotectivedevicetrippingunittypeenum):
            self._predefinedtype = ifcprotectivedevicetrippingunittypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    (self.predefinedtype != ifcprotectivedevicetrippingunittypeenum.userdefined) or (
                        (self.predefinedtype == ifcprotectivedevicetrippingunittypeenum.userdefined) and EXISTS(
                    self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcrelconnectswithrealizingelements #
####################
class ifcrelconnectswithrealizingelements(ifcrelconnectselements):
    '''Entity ifcrelconnectswithrealizingelements definition.

	:param realizingelements
	:type realizingelements:SET(1,None,'ifcelement', scope = schema_scope)

	:param connectiontype
	:type connectiontype:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__connectiongeometry, inherited5__relatingelement, inherited6__relatedelement,
                 realizingelements, connectiontype, ):
        ifcrelconnectselements.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__connectiongeometry,
                                        inherited5__relatingelement, inherited6__relatedelement, )
        self._realizingelements = realizingelements
        self._connectiontype = connectiontype

    @property
    def realizingelements(self):
        return self._realizingelements

    @realizingelements.setter
    def realizingelements(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcelement', scope=schema_scope)):
            self._realizingelements = SET(value)
        else:
            self._realizingelements = value

    @property
    def connectiontype(self):
        return self._connectiontype

    @connectiontype.setter
    def connectiontype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._connectiontype = ifclabel(value)
            else:
                self._connectiontype = value
        else:
            self._connectiontype = value


####################
# ENTITY ifcwasteterminaltype #
####################
class ifcwasteterminaltype(ifcflowterminaltype):
    '''Entity ifcwasteterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcwasteterminaltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowterminaltype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__applicableoccurrence,
                                     inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                     inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcwasteterminaltypeenum):
            self._predefinedtype = ifcwasteterminaltypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcwasteterminaltypeenum.userdefined) or (
                    (self.predefinedtype == ifcwasteterminaltypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcworkcalendar #
####################
class ifcworkcalendar(ifccontrol):
    '''Entity ifcworkcalendar definition.

	:param workingtimes
	:type workingtimes:SET(1,None,'ifcworktime', scope = schema_scope)

	:param exceptiontimes
	:type exceptiontimes:SET(1,None,'ifcworktime', scope = schema_scope)

	:param predefinedtype
	:type predefinedtype:ifcworkcalendartypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, workingtimes, exceptiontimes, predefinedtype, ):
        ifccontrol.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__identification, )
        self._workingtimes = workingtimes
        self._exceptiontimes = exceptiontimes
        self._predefinedtype = predefinedtype

    @property
    def workingtimes(self):
        return self._workingtimes

    @workingtimes.setter
    def workingtimes(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'ifcworktime', scope=schema_scope)):
                self._workingtimes = SET(value)
            else:
                self._workingtimes = value
        else:
            self._workingtimes = value

    @property
    def exceptiontimes(self):
        return self._exceptiontimes

    @exceptiontimes.setter
    def exceptiontimes(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'ifcworktime', scope=schema_scope)):
                self._exceptiontimes = SET(value)
            else:
                self._exceptiontimes = value
        else:
            self._exceptiontimes = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcworkcalendartypeenum):
                self._predefinedtype = ifcworkcalendartypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcworkcalendartypeenum.userdefined)) or ((
                                                                                                 self.predefinedtype == ifcworkcalendartypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcbuildingelementproxytype #
####################
class ifcbuildingelementproxytype(ifcbuildingelementtype):
    '''Entity ifcbuildingelementproxytype definition.

	:param predefinedtype
	:type predefinedtype:ifcbuildingelementproxytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcbuildingelementproxytypeenum):
            self._predefinedtype = ifcbuildingelementproxytypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcbuildingelementproxytypeenum.userdefined) or (
                    (self.predefinedtype == ifcbuildingelementproxytypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcderivedunit #
####################
class ifcderivedunit(BaseEntityClass):
    '''Entity ifcderivedunit definition.

	:param elements
	:type elements:SET(1,None,'ifcderivedunitelement', scope = schema_scope)

	:param unittype
	:type unittype:ifcderivedunitenum

	:param userdefinedtype
	:type userdefinedtype:ifclabel

	:param dimensions
	:type dimensions:ifcdimensionalexponents
	'''

    def __init__(self, elements, unittype, userdefinedtype, ):
        self._elements = elements
        self._unittype = unittype
        self._userdefinedtype = userdefinedtype

    @property
    def elements(self):
        return self._elements

    @elements.setter
    def elements(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcderivedunitelement', scope=schema_scope)):
            self._elements = SET(value)
        else:
            self._elements = value

    @property
    def unittype(self):
        return self._unittype

    @unittype.setter
    def unittype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcderivedunitenum):
            self._unittype = ifcderivedunitenum(value)
        else:
            self._unittype = value

    @property
    def userdefinedtype(self):
        return self._userdefinedtype

    @userdefinedtype.setter
    def userdefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefinedtype = ifclabel(value)
            else:
                self._userdefinedtype = value
        else:
            self._userdefinedtype = value

    @property
    def dimensions(self):
        attribute_eval = ifcderivedimensionalexponents(self.elements)
        return attribute_eval

    @dimensions.setter
    def dimensions(self, value):
        # DERIVED argument
        raise AssertionError('Argument dimensions is DERIVED. It is computed and can not be set to any value')

    def wr1(self):
        eval_wr1_wr = ((SIZEOF(self.elements) > 1) or (
                    (SIZEOF(self.elements) == 1) and (self.elements[1].self.exponent != 1)))
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr

    def wr2(self):
        eval_wr2_wr = ((self.unittype != ifcderivedunitenum.userdefined) or (
                    (self.unittype == ifcderivedunitenum.userdefined) and EXISTS(self.self.userdefinedtype)))
        if not eval_wr2_wr:
            raise AssertionError('Rule wr2 violated')
        else:
            return eval_wr2_wr


####################
# ENTITY ifcfantype #
####################
class ifcfantype(ifcflowmovingdevicetype):
    '''Entity ifcfantype definition.

	:param predefinedtype
	:type predefinedtype:ifcfantypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowmovingdevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__applicableoccurrence,
                                         inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                         inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcfantypeenum):
            self._predefinedtype = ifcfantypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcfantypeenum.userdefined) or (
                    (self.predefinedtype == ifcfantypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcmateriallayer #
####################
class ifcmateriallayer(ifcmaterialdefinition):
    '''Entity ifcmateriallayer definition.

	:param material
	:type material:ifcmaterial

	:param layerthickness
	:type layerthickness:ifcnonnegativelengthmeasure

	:param isventilated
	:type isventilated:ifclogical

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param category
	:type category:ifclabel

	:param priority
	:type priority:ifcinteger

	:param tomateriallayerset
	:type tomateriallayerset:ifcmateriallayerset
	'''

    def __init__(self, material, layerthickness, isventilated, name, description, category, priority, ):
        ifcmaterialdefinition.__init__(self, )
        self._material = material
        self._layerthickness = layerthickness
        self._isventilated = isventilated
        self._name = name
        self._description = description
        self._category = category
        self._priority = priority

    @property
    def material(self):
        return self._material

    @material.setter
    def material(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmaterial):
                self._material = ifcmaterial(value)
            else:
                self._material = value
        else:
            self._material = value

    @property
    def layerthickness(self):
        return self._layerthickness

    @layerthickness.setter
    def layerthickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcnonnegativelengthmeasure):
            self._layerthickness = ifcnonnegativelengthmeasure(value)
        else:
            self._layerthickness = value

    @property
    def isventilated(self):
        return self._isventilated

    @isventilated.setter
    def isventilated(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclogical):
                self._isventilated = ifclogical(value)
            else:
                self._isventilated = value
        else:
            self._isventilated = value

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def category(self):
        return self._category

    @category.setter
    def category(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._category = ifclabel(value)
            else:
                self._category = value
        else:
            self._category = value

    @property
    def priority(self):
        return self._priority

    @priority.setter
    def priority(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcinteger):
                self._priority = ifcinteger(value)
            else:
                self._priority = value
        else:
            self._priority = value

    @property
    def tomateriallayerset(self):
        return self._tomateriallayerset

    @tomateriallayerset.setter
    def tomateriallayerset(self, value):
        # INVERSE argument
        raise AssertionError('Argument tomateriallayerset is INVERSE. It is computed and can not be set to any value')

    def normalizedpriority(self):
        eval_normalizedpriority_wr = ((not EXISTS(self.priority)) or ((0 <= self.priority) and (self.priority <= 100)))
        if not eval_normalizedpriority_wr:
            raise AssertionError('Rule normalizedpriority violated')
        else:
            return eval_normalizedpriority_wr


####################
# ENTITY ifcmotorconnection #
####################
class ifcmotorconnection(ifcenergyconversiondevice):
    '''Entity ifcmotorconnection definition.

	:param predefinedtype
	:type predefinedtype:ifcmotorconnectiontypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmotorconnectiontypeenum):
                self._predefinedtype = ifcmotorconnectiontypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcmotorconnectiontypeenum.userdefined)) or ((
                                                                                                    self.predefinedtype == ifcmotorconnectiontypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCMOTORCONNECTIONTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcprotectivedevicetype #
####################
class ifcprotectivedevicetype(ifcflowcontrollertype):
    '''Entity ifcprotectivedevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcprotectivedevicetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowcontrollertype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__applicableoccurrence,
                                       inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                       inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprotectivedevicetypeenum):
            self._predefinedtype = ifcprotectivedevicetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcprotectivedevicetypeenum.userdefined) or (
                    (self.predefinedtype == ifcprotectivedevicetypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcushapeprofiledef #
####################
class ifcushapeprofiledef(ifcparameterizedprofiledef):
    '''Entity ifcushapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param flangewidth
	:type flangewidth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param flangethickness
	:type flangethickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcnonnegativelengthmeasure

	:param edgeradius
	:type edgeradius:ifcnonnegativelengthmeasure

	:param flangeslope
	:type flangeslope:ifcplaneanglemeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, depth, flangewidth,
                 webthickness, flangethickness, filletradius, edgeradius, flangeslope, ):
        ifcparameterizedprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename,
                                            inherited2__position, )
        self._depth = depth
        self._flangewidth = flangewidth
        self._webthickness = webthickness
        self._flangethickness = flangethickness
        self._filletradius = filletradius
        self._edgeradius = edgeradius
        self._flangeslope = flangeslope

    @property
    def depth(self):
        return self._depth

    @depth.setter
    def depth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._depth = ifcpositivelengthmeasure(value)
        else:
            self._depth = value

    @property
    def flangewidth(self):
        return self._flangewidth

    @flangewidth.setter
    def flangewidth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._flangewidth = ifcpositivelengthmeasure(value)
        else:
            self._flangewidth = value

    @property
    def webthickness(self):
        return self._webthickness

    @webthickness.setter
    def webthickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._webthickness = ifcpositivelengthmeasure(value)
        else:
            self._webthickness = value

    @property
    def flangethickness(self):
        return self._flangethickness

    @flangethickness.setter
    def flangethickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._flangethickness = ifcpositivelengthmeasure(value)
        else:
            self._flangethickness = value

    @property
    def filletradius(self):
        return self._filletradius

    @filletradius.setter
    def filletradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._filletradius = ifcnonnegativelengthmeasure(value)
            else:
                self._filletradius = value
        else:
            self._filletradius = value

    @property
    def edgeradius(self):
        return self._edgeradius

    @edgeradius.setter
    def edgeradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._edgeradius = ifcnonnegativelengthmeasure(value)
            else:
                self._edgeradius = value
        else:
            self._edgeradius = value

    @property
    def flangeslope(self):
        return self._flangeslope

    @flangeslope.setter
    def flangeslope(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplaneanglemeasure):
                self._flangeslope = ifcplaneanglemeasure(value)
            else:
                self._flangeslope = value
        else:
            self._flangeslope = value

    def validflangethickness(self):
        eval_validflangethickness_wr = (self.flangethickness < (self.depth / 2))
        if not eval_validflangethickness_wr:
            raise AssertionError('Rule validflangethickness violated')
        else:
            return eval_validflangethickness_wr

    def validwebthickness(self):
        eval_validwebthickness_wr = (self.webthickness < self.flangewidth)
        if not eval_validwebthickness_wr:
            raise AssertionError('Rule validwebthickness violated')
        else:
            return eval_validwebthickness_wr


####################
# ENTITY ifcelectricappliancetype #
####################
class ifcelectricappliancetype(ifcflowterminaltype):
    '''Entity ifcelectricappliancetype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricappliancetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowterminaltype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__applicableoccurrence,
                                     inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                     inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelectricappliancetypeenum):
            self._predefinedtype = ifcelectricappliancetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcelectricappliancetypeenum.userdefined) or (
                    (self.predefinedtype == ifcelectricappliancetypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcstructuralplanaraction #
####################
class ifcstructuralplanaraction(ifcstructuralsurfaceaction):
    '''Entity ifcstructuralplanaraction definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__appliedload, inherited8__globalorlocal, inherited9__destabilizingload,
                 inherited10__projectedortrue, inherited11__predefinedtype, ):
        ifcstructuralsurfaceaction.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation,
                                            inherited7__appliedload, inherited8__globalorlocal,
                                            inherited9__destabilizingload, inherited10__projectedortrue,
                                            inherited11__predefinedtype, )

    def suitableloadtype(self):
        eval_suitableloadtype_wr = (SIZEOF(
            ['IFC4X2.IFCSTRUCTURALLOADPLANARFORCE', 'IFC4X2.IFCSTRUCTURALLOADTEMPERATURE'] * TYPEOF(
                self.self.ifcstructuralactivity.self.appliedload)) == 1)
        if not eval_suitableloadtype_wr:
            raise AssertionError('Rule suitableloadtype violated')
        else:
            return eval_suitableloadtype_wr

    def constpredefinedtype(self):
        eval_constpredefinedtype_wr = (
                    self.self.ifcstructuralsurfaceaction.self.predefinedtype == ifcstructuralsurfaceactivitytypeenum.const)
        if not eval_constpredefinedtype_wr:
            raise AssertionError('Rule constpredefinedtype violated')
        else:
            return eval_constpredefinedtype_wr


####################
# ENTITY ifccolumntype #
####################
class ifccolumntype(ifcbuildingelementtype):
    '''Entity ifccolumntype definition.

	:param predefinedtype
	:type predefinedtype:ifccolumntypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccolumntypeenum):
            self._predefinedtype = ifccolumntypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccolumntypeenum.userdefined) or (
                    (self.predefinedtype == ifccolumntypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifccomplexproperty #
####################
class ifccomplexproperty(ifcproperty):
    '''Entity ifccomplexproperty definition.

	:param usagename
	:type usagename:ifcidentifier

	:param hasproperties
	:type hasproperties:SET(1,None,'ifcproperty', scope = schema_scope)
	'''

    def __init__(self, inherited0__name, inherited1__description, usagename, hasproperties, ):
        ifcproperty.__init__(self, inherited0__name, inherited1__description, )
        self._usagename = usagename
        self._hasproperties = hasproperties

    @property
    def usagename(self):
        return self._usagename

    @usagename.setter
    def usagename(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcidentifier):
            self._usagename = ifcidentifier(value)
        else:
            self._usagename = value

    @property
    def hasproperties(self):
        return self._hasproperties

    @hasproperties.setter
    def hasproperties(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcproperty', scope=schema_scope)):
            self._hasproperties = SET(value)
        else:
            self._hasproperties = value

    def wr21(self):
        eval_wr21_wr = (SIZEOF(None) == 0)
        if not eval_wr21_wr:
            raise AssertionError('Rule wr21 violated')
        else:
            return eval_wr21_wr

    def wr22(self):
        eval_wr22_wr = ifcuniquepropertyname(self.hasproperties)
        if not eval_wr22_wr:
            raise AssertionError('Rule wr22 violated')
        else:
            return eval_wr22_wr


####################
# ENTITY ifcfixedreferencesweptareasolid #
####################
class ifcfixedreferencesweptareasolid(ifcsweptareasolid):
    '''Entity ifcfixedreferencesweptareasolid definition.

	:param directrix
	:type directrix:ifccurve

	:param startparam
	:type startparam:ifcparametervalue

	:param endparam
	:type endparam:ifcparametervalue

	:param fixedreference
	:type fixedreference:ifcdirection
	'''

    def __init__(self, inherited0__sweptarea, inherited1__position, directrix, startparam, endparam, fixedreference, ):
        ifcsweptareasolid.__init__(self, inherited0__sweptarea, inherited1__position, )
        self._directrix = directrix
        self._startparam = startparam
        self._endparam = endparam
        self._fixedreference = fixedreference

    @property
    def directrix(self):
        return self._directrix

    @directrix.setter
    def directrix(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._directrix = ifccurve(value)
        else:
            self._directrix = value

    @property
    def startparam(self):
        return self._startparam

    @startparam.setter
    def startparam(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcparametervalue):
                self._startparam = ifcparametervalue(value)
            else:
                self._startparam = value
        else:
            self._startparam = value

    @property
    def endparam(self):
        return self._endparam

    @endparam.setter
    def endparam(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcparametervalue):
                self._endparam = ifcparametervalue(value)
            else:
                self._endparam = value
        else:
            self._endparam = value

    @property
    def fixedreference(self):
        return self._fixedreference

    @fixedreference.setter
    def fixedreference(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdirection):
            self._fixedreference = ifcdirection(value)
        else:
            self._fixedreference = value

    def directrixbounded(self):
        eval_directrixbounded_wr = ((EXISTS(self.startparam) and EXISTS(self.endparam)) or (
                    SIZEOF(['IFC4X2.IFCCONIC', 'IFC4X2.IFCBOUNDEDCURVE'] * TYPEOF(self.directrix)) == 1))
        if not eval_directrixbounded_wr:
            raise AssertionError('Rule directrixbounded violated')
        else:
            return eval_directrixbounded_wr


####################
# ENTITY ifcplane #
####################
class ifcplane(ifcelementarysurface):
    '''Entity ifcplane definition.
	'''

    def __init__(self, inherited0__position, ):
        ifcelementarysurface.__init__(self, inherited0__position, )


####################
# ENTITY ifcproductdefinitionshape #
####################
class ifcproductdefinitionshape(ifcproductrepresentation):
    '''Entity ifcproductdefinitionshape definition.

	:param shapeofproduct
	:type shapeofproduct:SET(1,None,'ifcproduct', scope = schema_scope)

	:param hasshapeaspects
	:type hasshapeaspects:SET(0,None,'ifcshapeaspect', scope = schema_scope)
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__representations, ):
        ifcproductrepresentation.__init__(self, inherited0__name, inherited1__description,
                                          inherited2__representations, )

    @property
    def shapeofproduct(self):
        return self._shapeofproduct

    @shapeofproduct.setter
    def shapeofproduct(self, value):
        # INVERSE argument
        raise AssertionError('Argument shapeofproduct is INVERSE. It is computed and can not be set to any value')

    @property
    def hasshapeaspects(self):
        return self._hasshapeaspects

    @hasshapeaspects.setter
    def hasshapeaspects(self, value):
        # INVERSE argument
        raise AssertionError('Argument hasshapeaspects is INVERSE. It is computed and can not be set to any value')

    def onlyshapemodel(self):
        eval_onlyshapemodel_wr = (SIZEOF(None) == 0)
        if not eval_onlyshapemodel_wr:
            raise AssertionError('Rule onlyshapemodel violated')
        else:
            return eval_onlyshapemodel_wr


####################
# ENTITY ifcrelreferencedinspatialstructure #
####################
class ifcrelreferencedinspatialstructure(ifcrelconnects):
    '''Entity ifcrelreferencedinspatialstructure definition.

	:param relatedelements
	:type relatedelements:SET(1,None,'ifcproduct', scope = schema_scope)

	:param relatingstructure
	:type relatingstructure:ifcspatialelement
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatedelements, relatingstructure, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatedelements = relatedelements
        self._relatingstructure = relatingstructure

    @property
    def relatedelements(self):
        return self._relatedelements

    @relatedelements.setter
    def relatedelements(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcproduct', scope=schema_scope)):
            self._relatedelements = SET(value)
        else:
            self._relatedelements = value

    @property
    def relatingstructure(self):
        return self._relatingstructure

    @relatingstructure.setter
    def relatingstructure(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcspatialelement):
            self._relatingstructure = ifcspatialelement(value)
        else:
            self._relatingstructure = value

    def allowedrelatedelements(self):
        eval_allowedrelatedelements_wr = (SIZEOF(None) == 0)
        if not eval_allowedrelatedelements_wr:
            raise AssertionError('Rule allowedrelatedelements violated')
        else:
            return eval_allowedrelatedelements_wr


####################
# ENTITY ifcconstructionmaterialresource #
####################
class ifcconstructionmaterialresource(ifcconstructionresource):
    '''Entity ifcconstructionmaterialresource definition.

	:param predefinedtype
	:type predefinedtype:ifcconstructionmaterialresourcetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, inherited6__longdescription, inherited7__usage,
                 inherited8__basecosts, inherited9__basequantity, predefinedtype, ):
        ifcconstructionresource.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__objecttype, inherited5__identification,
                                         inherited6__longdescription, inherited7__usage, inherited8__basecosts,
                                         inherited9__basequantity, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcconstructionmaterialresourcetypeenum):
                self._predefinedtype = ifcconstructionmaterialresourcetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcconstructionmaterialresourcetypeenum.userdefined)) or ((
                                                                                                                 self.predefinedtype == ifcconstructionmaterialresourcetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcslabtype #
####################
class ifcslabtype(ifcbuildingelementtype):
    '''Entity ifcslabtype definition.

	:param predefinedtype
	:type predefinedtype:ifcslabtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcslabtypeenum):
            self._predefinedtype = ifcslabtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcslabtypeenum.userdefined) or (
                    (self.predefinedtype == ifcslabtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcstructuralloadlinearforce #
####################
class ifcstructuralloadlinearforce(ifcstructuralloadstatic):
    '''Entity ifcstructuralloadlinearforce definition.

	:param linearforcex
	:type linearforcex:ifclinearforcemeasure

	:param linearforcey
	:type linearforcey:ifclinearforcemeasure

	:param linearforcez
	:type linearforcez:ifclinearforcemeasure

	:param linearmomentx
	:type linearmomentx:ifclinearmomentmeasure

	:param linearmomenty
	:type linearmomenty:ifclinearmomentmeasure

	:param linearmomentz
	:type linearmomentz:ifclinearmomentmeasure
	'''

    def __init__(self, inherited0__name, linearforcex, linearforcey, linearforcez, linearmomentx, linearmomenty,
                 linearmomentz, ):
        ifcstructuralloadstatic.__init__(self, inherited0__name, )
        self._linearforcex = linearforcex
        self._linearforcey = linearforcey
        self._linearforcez = linearforcez
        self._linearmomentx = linearmomentx
        self._linearmomenty = linearmomenty
        self._linearmomentz = linearmomentz

    @property
    def linearforcex(self):
        return self._linearforcex

    @linearforcex.setter
    def linearforcex(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclinearforcemeasure):
                self._linearforcex = ifclinearforcemeasure(value)
            else:
                self._linearforcex = value
        else:
            self._linearforcex = value

    @property
    def linearforcey(self):
        return self._linearforcey

    @linearforcey.setter
    def linearforcey(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclinearforcemeasure):
                self._linearforcey = ifclinearforcemeasure(value)
            else:
                self._linearforcey = value
        else:
            self._linearforcey = value

    @property
    def linearforcez(self):
        return self._linearforcez

    @linearforcez.setter
    def linearforcez(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclinearforcemeasure):
                self._linearforcez = ifclinearforcemeasure(value)
            else:
                self._linearforcez = value
        else:
            self._linearforcez = value

    @property
    def linearmomentx(self):
        return self._linearmomentx

    @linearmomentx.setter
    def linearmomentx(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclinearmomentmeasure):
                self._linearmomentx = ifclinearmomentmeasure(value)
            else:
                self._linearmomentx = value
        else:
            self._linearmomentx = value

    @property
    def linearmomenty(self):
        return self._linearmomenty

    @linearmomenty.setter
    def linearmomenty(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclinearmomentmeasure):
                self._linearmomenty = ifclinearmomentmeasure(value)
            else:
                self._linearmomenty = value
        else:
            self._linearmomenty = value

    @property
    def linearmomentz(self):
        return self._linearmomentz

    @linearmomentz.setter
    def linearmomentz(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclinearmomentmeasure):
                self._linearmomentz = ifclinearmomentmeasure(value)
            else:
                self._linearmomentz = value
        else:
            self._linearmomentz = value


####################
# ENTITY ifcstyleditem #
####################
class ifcstyleditem(ifcrepresentationitem):
    '''Entity ifcstyleditem definition.

	:param item
	:type item:ifcrepresentationitem

	:param styles
	:type styles:SET(1,None,'ifcstyleassignmentselect', scope = schema_scope)

	:param name
	:type name:ifclabel
	'''

    def __init__(self, item, styles, name, ):
        ifcrepresentationitem.__init__(self, )
        self._item = item
        self._styles = styles
        self._name = name

    @property
    def item(self):
        return self._item

    @item.setter
    def item(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcrepresentationitem):
                self._item = ifcrepresentationitem(value)
            else:
                self._item = value
        else:
            self._item = value

    @property
    def styles(self):
        return self._styles

    @styles.setter
    def styles(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcstyleassignmentselect', scope=schema_scope)):
            self._styles = SET(value)
        else:
            self._styles = value

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    def applicableitem(self):
        eval_applicableitem_wr = (not ('IFC4X2.IFCSTYLEDITEM' == TYPEOF(self.item)))
        if not eval_applicableitem_wr:
            raise AssertionError('Rule applicableitem violated')
        else:
            return eval_applicableitem_wr


####################
# ENTITY ifccurvestylefontandscaling #
####################
class ifccurvestylefontandscaling(ifcpresentationitem):
    '''Entity ifccurvestylefontandscaling definition.

	:param name
	:type name:ifclabel

	:param curvefont
	:type curvefont:ifccurvestylefontselect

	:param curvefontscaling
	:type curvefontscaling:ifcpositiveratiomeasure
	'''

    def __init__(self, name, curvefont, curvefontscaling, ):
        ifcpresentationitem.__init__(self, )
        self._name = name
        self._curvefont = curvefont
        self._curvefontscaling = curvefontscaling

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def curvefont(self):
        return self._curvefont

    @curvefont.setter
    def curvefont(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurvestylefontselect):
            self._curvefont = ifccurvestylefontselect(value)
        else:
            self._curvefont = value

    @property
    def curvefontscaling(self):
        return self._curvefontscaling

    @curvefontscaling.setter
    def curvefontscaling(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositiveratiomeasure):
            self._curvefontscaling = ifcpositiveratiomeasure(value)
        else:
            self._curvefontscaling = value


####################
# ENTITY ifcelectricflowstoragedevice #
####################
class ifcelectricflowstoragedevice(ifcflowstoragedevice):
    '''Entity ifcelectricflowstoragedevice definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricflowstoragedevicetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowstoragedevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                      inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                      inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcelectricflowstoragedevicetypeenum):
                self._predefinedtype = ifcelectricflowstoragedevicetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcelectricflowstoragedevicetypeenum.userdefined)) or ((
                                                                                                              self.predefinedtype == ifcelectricflowstoragedevicetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCELECTRICFLOWSTORAGEDEVICETYPE' == TYPEOF(
                self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcreldefinesbyproperties #
####################
class ifcreldefinesbyproperties(ifcreldefines):
    '''Entity ifcreldefinesbyproperties definition.

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcobjectdefinition', scope = schema_scope)

	:param relatingpropertydefinition
	:type relatingpropertydefinition:ifcpropertysetdefinitionselect
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatedobjects, relatingpropertydefinition, ):
        ifcreldefines.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                               inherited3__description, )
        self._relatedobjects = relatedobjects
        self._relatingpropertydefinition = relatingpropertydefinition

    @property
    def relatedobjects(self):
        return self._relatedobjects

    @relatedobjects.setter
    def relatedobjects(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcobjectdefinition', scope=schema_scope)):
            self._relatedobjects = SET(value)
        else:
            self._relatedobjects = value

    @property
    def relatingpropertydefinition(self):
        return self._relatingpropertydefinition

    @relatingpropertydefinition.setter
    def relatingpropertydefinition(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpropertysetdefinitionselect):
            self._relatingpropertydefinition = ifcpropertysetdefinitionselect(value)
        else:
            self._relatingpropertydefinition = value

    def norelatedtypeobject(self):
        eval_norelatedtypeobject_wr = (SIZEOF(None) == 0)
        if not eval_norelatedtypeobject_wr:
            raise AssertionError('Rule norelatedtypeobject violated')
        else:
            return eval_norelatedtypeobject_wr


####################
# ENTITY ifclibraryreference #
####################
class ifclibraryreference(ifcexternalreference):
    '''Entity ifclibraryreference definition.

	:param description
	:type description:ifctext

	:param language
	:type language:ifclanguageid

	:param referencedlibrary
	:type referencedlibrary:ifclibraryinformation

	:param libraryrefforobjects
	:type libraryrefforobjects:SET(0,None,'ifcrelassociateslibrary', scope = schema_scope)
	'''

    def __init__(self, inherited0__location, inherited1__identification, inherited2__name, description, language,
                 referencedlibrary, ):
        ifcexternalreference.__init__(self, inherited0__location, inherited1__identification, inherited2__name, )
        self._description = description
        self._language = language
        self._referencedlibrary = referencedlibrary

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def language(self):
        return self._language

    @language.setter
    def language(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclanguageid):
                self._language = ifclanguageid(value)
            else:
                self._language = value
        else:
            self._language = value

    @property
    def referencedlibrary(self):
        return self._referencedlibrary

    @referencedlibrary.setter
    def referencedlibrary(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclibraryinformation):
                self._referencedlibrary = ifclibraryinformation(value)
            else:
                self._referencedlibrary = value
        else:
            self._referencedlibrary = value

    @property
    def libraryrefforobjects(self):
        return self._libraryrefforobjects

    @libraryrefforobjects.setter
    def libraryrefforobjects(self, value):
        # INVERSE argument
        raise AssertionError('Argument libraryrefforobjects is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcrelassignstoprocess #
####################
class ifcrelassignstoprocess(ifcrelassigns):
    '''Entity ifcrelassignstoprocess definition.

	:param relatingprocess
	:type relatingprocess:ifcprocessselect

	:param quantityinprocess
	:type quantityinprocess:ifcmeasurewithunit
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatedobjects, inherited5__relatedobjectstype, relatingprocess, quantityinprocess, ):
        ifcrelassigns.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                               inherited3__description, inherited4__relatedobjects, inherited5__relatedobjectstype, )
        self._relatingprocess = relatingprocess
        self._quantityinprocess = quantityinprocess

    @property
    def relatingprocess(self):
        return self._relatingprocess

    @relatingprocess.setter
    def relatingprocess(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprocessselect):
            self._relatingprocess = ifcprocessselect(value)
        else:
            self._relatingprocess = value

    @property
    def quantityinprocess(self):
        return self._quantityinprocess

    @quantityinprocess.setter
    def quantityinprocess(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmeasurewithunit):
                self._quantityinprocess = ifcmeasurewithunit(value)
            else:
                self._quantityinprocess = value
        else:
            self._quantityinprocess = value

    def noselfreference(self):
        eval_noselfreference_wr = (SIZEOF(None) == 0)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifcaxis2placement2d #
####################
class ifcaxis2placement2d(ifcplacement):
    '''Entity ifcaxis2placement2d definition.

	:param refdirection
	:type refdirection:ifcdirection

	:param p
	:type p:LIST(2,2,'ifcdirection', scope = schema_scope)
	'''

    def __init__(self, inherited0__location, refdirection, ):
        ifcplacement.__init__(self, inherited0__location, )
        self._refdirection = refdirection

    @property
    def refdirection(self):
        return self._refdirection

    @refdirection.setter
    def refdirection(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdirection):
                self._refdirection = ifcdirection(value)
            else:
                self._refdirection = value
        else:
            self._refdirection = value

    @property
    def p(self):
        attribute_eval = ifcbuild2axes(self.refdirection)
        return attribute_eval

    @p.setter
    def p(self, value):
        # DERIVED argument
        raise AssertionError('Argument p is DERIVED. It is computed and can not be set to any value')

    def refdiris2d(self):
        eval_refdiris2d_wr = ((not EXISTS(self.refdirection)) or (self.refdirection.self.dim == 2))
        if not eval_refdiris2d_wr:
            raise AssertionError('Rule refdiris2d violated')
        else:
            return eval_refdiris2d_wr

    def locationis2d(self):
        eval_locationis2d_wr = (self.self.ifcplacement.self.location.self.dim == 2)
        if not eval_locationis2d_wr:
            raise AssertionError('Rule locationis2d violated')
        else:
            return eval_locationis2d_wr


####################
# ENTITY ifcelectricflowstoragedevicetype #
####################
class ifcelectricflowstoragedevicetype(ifcflowstoragedevicetype):
    '''Entity ifcelectricflowstoragedevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricflowstoragedevicetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowstoragedevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, inherited4__applicableoccurrence,
                                          inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                          inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelectricflowstoragedevicetypeenum):
            self._predefinedtype = ifcelectricflowstoragedevicetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcelectricflowstoragedevicetypeenum.userdefined) or (
                    (self.predefinedtype == ifcelectricflowstoragedevicetypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcquantitytime #
####################
class ifcquantitytime(ifcphysicalsimplequantity):
    '''Entity ifcquantitytime definition.

	:param timevalue
	:type timevalue:ifctimemeasure

	:param formula
	:type formula:ifclabel
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__unit, timevalue, formula, ):
        ifcphysicalsimplequantity.__init__(self, inherited0__name, inherited1__description, inherited2__unit, )
        self._timevalue = timevalue
        self._formula = formula

    @property
    def timevalue(self):
        return self._timevalue

    @timevalue.setter
    def timevalue(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctimemeasure):
            self._timevalue = ifctimemeasure(value)
        else:
            self._timevalue = value

    @property
    def formula(self):
        return self._formula

    @formula.setter
    def formula(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._formula = ifclabel(value)
            else:
                self._formula = value
        else:
            self._formula = value

    def wr21(self):
        eval_wr21_wr = ((not EXISTS(self.self.ifcphysicalsimplequantity.self.unit)) or (
                    self.self.ifcphysicalsimplequantity.self.unit.self.unittype == ifcunitenum.timeunit))
        if not eval_wr21_wr:
            raise AssertionError('Rule wr21 violated')
        else:
            return eval_wr21_wr

    def wr22(self):
        eval_wr22_wr = (self.timevalue >= 0)
        if not eval_wr22_wr:
            raise AssertionError('Rule wr22 violated')
        else:
            return eval_wr22_wr


####################
# ENTITY ifcvirtualgridintersection #
####################
class ifcvirtualgridintersection(BaseEntityClass):
    '''Entity ifcvirtualgridintersection definition.

	:param intersectingaxes
	:type intersectingaxes:LIST(2,2,'ifcgridaxis', scope = schema_scope)

	:param offsetdistances
	:type offsetdistances:LIST(2,3,'REAL', scope = schema_scope)
	'''

    def __init__(self, intersectingaxes, offsetdistances, ):
        self._intersectingaxes = intersectingaxes
        self._offsetdistances = offsetdistances

    @property
    def intersectingaxes(self):
        return self._intersectingaxes

    @intersectingaxes.setter
    def intersectingaxes(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, 2, 'ifcgridaxis', scope=schema_scope)):
            self._intersectingaxes = LIST(value)
        else:
            self._intersectingaxes = value

    @property
    def offsetdistances(self):
        return self._offsetdistances

    @offsetdistances.setter
    def offsetdistances(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, 3, 'REAL', scope=schema_scope)):
            self._offsetdistances = LIST(value)
        else:
            self._offsetdistances = value


####################
# ENTITY ifcstructuralcurvereaction #
####################
class ifcstructuralcurvereaction(ifcstructuralreaction):
    '''Entity ifcstructuralcurvereaction definition.

	:param predefinedtype
	:type predefinedtype:ifcstructuralcurveactivitytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__appliedload, inherited8__globalorlocal, predefinedtype, ):
        ifcstructuralreaction.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                       inherited6__representation, inherited7__appliedload, inherited8__globalorlocal, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstructuralcurveactivitytypeenum):
            self._predefinedtype = ifcstructuralcurveactivitytypeenum(value)
        else:
            self._predefinedtype = value

    def hasobjecttype(self):
        eval_hasobjecttype_wr = ((self.predefinedtype != ifcstructuralcurveactivitytypeenum.userdefined) or EXISTS(
            self.self.ifcobject.self.objecttype))
        if not eval_hasobjecttype_wr:
            raise AssertionError('Rule hasobjecttype violated')
        else:
            return eval_hasobjecttype_wr

    def suitablepredefinedtype(self):
        eval_suitablepredefinedtype_wr = ((self.predefinedtype != ifcstructuralcurveactivitytypeenum.sinus) and (
                    self.predefinedtype != ifcstructuralcurveactivitytypeenum.parabola))
        if not eval_suitablepredefinedtype_wr:
            raise AssertionError('Rule suitablepredefinedtype violated')
        else:
            return eval_suitablepredefinedtype_wr


####################
# ENTITY ifcannotation #
####################
class ifcannotation(ifcproduct):
    '''Entity ifcannotation definition.

	:param containedinstructure
	:type containedinstructure:SET(0,1,'ifcrelcontainedinspatialstructure', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, ):
        ifcproduct.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, )

    @property
    def containedinstructure(self):
        return self._containedinstructure

    @containedinstructure.setter
    def containedinstructure(self, value):
        # INVERSE argument
        raise AssertionError('Argument containedinstructure is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcmedicaldevice #
####################
class ifcmedicaldevice(ifcflowterminal):
    '''Entity ifcmedicaldevice definition.

	:param predefinedtype
	:type predefinedtype:ifcmedicaldevicetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowterminal.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmedicaldevicetypeenum):
                self._predefinedtype = ifcmedicaldevicetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcmedicaldevicetypeenum.userdefined)) or ((
                                                                                                  self.predefinedtype == ifcmedicaldevicetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCMEDICALDEVICETYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcindexedcolourmap #
####################
class ifcindexedcolourmap(ifcpresentationitem):
    '''Entity ifcindexedcolourmap definition.

	:param mappedto
	:type mappedto:ifctessellatedfaceset

	:param opacity
	:type opacity:ifcnormalisedratiomeasure

	:param colours
	:type colours:ifccolourrgblist

	:param colourindex
	:type colourindex:LIST(1,None,'INTEGER', scope = schema_scope)
	'''

    def __init__(self, mappedto, opacity, colours, colourindex, ):
        ifcpresentationitem.__init__(self, )
        self._mappedto = mappedto
        self._opacity = opacity
        self._colours = colours
        self._colourindex = colourindex

    @property
    def mappedto(self):
        return self._mappedto

    @mappedto.setter
    def mappedto(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctessellatedfaceset):
            self._mappedto = ifctessellatedfaceset(value)
        else:
            self._mappedto = value

    @property
    def opacity(self):
        return self._opacity

    @opacity.setter
    def opacity(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnormalisedratiomeasure):
                self._opacity = ifcnormalisedratiomeasure(value)
            else:
                self._opacity = value
        else:
            self._opacity = value

    @property
    def colours(self):
        return self._colours

    @colours.setter
    def colours(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccolourrgblist):
            self._colours = ifccolourrgblist(value)
        else:
            self._colours = value

    @property
    def colourindex(self):
        return self._colourindex

    @colourindex.setter
    def colourindex(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'INTEGER', scope=schema_scope)):
            self._colourindex = LIST(value)
        else:
            self._colourindex = value


####################
# ENTITY ifcinterceptor #
####################
class ifcinterceptor(ifcflowtreatmentdevice):
    '''Entity ifcinterceptor definition.

	:param predefinedtype
	:type predefinedtype:ifcinterceptortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowtreatmentdevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                        inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcinterceptortypeenum):
                self._predefinedtype = ifcinterceptortypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcinterceptortypeenum.userdefined)) or ((
                                                                                                self.predefinedtype == ifcinterceptortypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCINTERCEPTORTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcpropertytablevalue #
####################
class ifcpropertytablevalue(ifcsimpleproperty):
    '''Entity ifcpropertytablevalue definition.

	:param definingvalues
	:type definingvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param definedvalues
	:type definedvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param expression
	:type expression:ifctext

	:param definingunit
	:type definingunit:ifcunit

	:param definedunit
	:type definedunit:ifcunit

	:param curveinterpolation
	:type curveinterpolation:ifccurveinterpolationenum
	'''

    def __init__(self, inherited0__name, inherited1__description, definingvalues, definedvalues, expression,
                 definingunit, definedunit, curveinterpolation, ):
        ifcsimpleproperty.__init__(self, inherited0__name, inherited1__description, )
        self._definingvalues = definingvalues
        self._definedvalues = definedvalues
        self._expression = expression
        self._definingunit = definingunit
        self._definedunit = definedunit
        self._curveinterpolation = curveinterpolation

    @property
    def definingvalues(self):
        return self._definingvalues

    @definingvalues.setter
    def definingvalues(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcvalue', scope=schema_scope)):
                self._definingvalues = LIST(value)
            else:
                self._definingvalues = value
        else:
            self._definingvalues = value

    @property
    def definedvalues(self):
        return self._definedvalues

    @definedvalues.setter
    def definedvalues(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcvalue', scope=schema_scope)):
                self._definedvalues = LIST(value)
            else:
                self._definedvalues = value
        else:
            self._definedvalues = value

    @property
    def expression(self):
        return self._expression

    @expression.setter
    def expression(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._expression = ifctext(value)
            else:
                self._expression = value
        else:
            self._expression = value

    @property
    def definingunit(self):
        return self._definingunit

    @definingunit.setter
    def definingunit(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcunit):
                self._definingunit = ifcunit(value)
            else:
                self._definingunit = value
        else:
            self._definingunit = value

    @property
    def definedunit(self):
        return self._definedunit

    @definedunit.setter
    def definedunit(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcunit):
                self._definedunit = ifcunit(value)
            else:
                self._definedunit = value
        else:
            self._definedunit = value

    @property
    def curveinterpolation(self):
        return self._curveinterpolation

    @curveinterpolation.setter
    def curveinterpolation(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccurveinterpolationenum):
                self._curveinterpolation = ifccurveinterpolationenum(value)
            else:
                self._curveinterpolation = value
        else:
            self._curveinterpolation = value

    def wr21(self):
        eval_wr21_wr = (((not EXISTS(self.definingvalues)) and (not EXISTS(self.definedvalues))) or (
                    SIZEOF(self.definingvalues) == SIZEOF(self.definedvalues)))
        if not eval_wr21_wr:
            raise AssertionError('Rule wr21 violated')
        else:
            return eval_wr21_wr

    def wr22(self):
        eval_wr22_wr = ((not EXISTS(self.definingvalues)) or (SIZEOF(None) == 0))
        if not eval_wr22_wr:
            raise AssertionError('Rule wr22 violated')
        else:
            return eval_wr22_wr

    def wr23(self):
        eval_wr23_wr = ((not EXISTS(self.definedvalues)) or (SIZEOF(None) == 0))
        if not eval_wr23_wr:
            raise AssertionError('Rule wr23 violated')
        else:
            return eval_wr23_wr


####################
# ENTITY ifcelectricappliance #
####################
class ifcelectricappliance(ifcflowterminal):
    '''Entity ifcelectricappliance definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricappliancetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowterminal.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcelectricappliancetypeenum):
                self._predefinedtype = ifcelectricappliancetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcelectricappliancetypeenum.userdefined)) or ((
                                                                                                      self.predefinedtype == ifcelectricappliancetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCELECTRICAPPLIANCETYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcprotectivedevicetrippingunit #
####################
class ifcprotectivedevicetrippingunit(ifcdistributioncontrolelement):
    '''Entity ifcprotectivedevicetrippingunit definition.

	:param predefinedtype
	:type predefinedtype:ifcprotectivedevicetrippingunittypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcdistributioncontrolelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__objecttype,
                                               inherited5__objectplacement, inherited6__representation,
                                               inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcprotectivedevicetrippingunittypeenum):
                self._predefinedtype = ifcprotectivedevicetrippingunittypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcprotectivedevicetrippingunittypeenum.userdefined)) or ((
                                                                                                                 self.predefinedtype == ifcprotectivedevicetrippingunittypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCPROTECTIVEDEVICETRIPPINGUNITTYPE' == TYPEOF(
                self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcreinforcingbar #
####################
class ifcreinforcingbar(ifcreinforcingelement):
    '''Entity ifcreinforcingbar definition.

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param crosssectionarea
	:type crosssectionarea:ifcareameasure

	:param barlength
	:type barlength:ifcpositivelengthmeasure

	:param predefinedtype
	:type predefinedtype:ifcreinforcingbartypeenum

	:param barsurface
	:type barsurface:ifcreinforcingbarsurfaceenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__steelgrade, nominaldiameter, crosssectionarea, barlength, predefinedtype, barsurface, ):
        ifcreinforcingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                       inherited6__representation, inherited7__tag, inherited8__steelgrade, )
        self._nominaldiameter = nominaldiameter
        self._crosssectionarea = crosssectionarea
        self._barlength = barlength
        self._predefinedtype = predefinedtype
        self._barsurface = barsurface

    @property
    def nominaldiameter(self):
        return self._nominaldiameter

    @nominaldiameter.setter
    def nominaldiameter(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._nominaldiameter = ifcpositivelengthmeasure(value)
            else:
                self._nominaldiameter = value
        else:
            self._nominaldiameter = value

    @property
    def crosssectionarea(self):
        return self._crosssectionarea

    @crosssectionarea.setter
    def crosssectionarea(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcareameasure):
                self._crosssectionarea = ifcareameasure(value)
            else:
                self._crosssectionarea = value
        else:
            self._crosssectionarea = value

    @property
    def barlength(self):
        return self._barlength

    @barlength.setter
    def barlength(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._barlength = ifcpositivelengthmeasure(value)
            else:
                self._barlength = value
        else:
            self._barlength = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreinforcingbartypeenum):
                self._predefinedtype = ifcreinforcingbartypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def barsurface(self):
        return self._barsurface

    @barsurface.setter
    def barsurface(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreinforcingbarsurfaceenum):
                self._barsurface = ifcreinforcingbarsurfaceenum(value)
            else:
                self._barsurface = value
        else:
            self._barsurface = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcreinforcingbartypeenum.userdefined)) or ((
                                                                                                   self.predefinedtype == ifcreinforcingbartypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCREINFORCINGBARTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifccomplexpropertytemplate #
####################
class ifccomplexpropertytemplate(ifcpropertytemplate):
    '''Entity ifccomplexpropertytemplate definition.

	:param usagename
	:type usagename:ifclabel

	:param templatetype
	:type templatetype:ifccomplexpropertytemplatetypeenum

	:param haspropertytemplates
	:type haspropertytemplates:SET(1,None,'ifcpropertytemplate', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 usagename, templatetype, haspropertytemplates, ):
        ifcpropertytemplate.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, )
        self._usagename = usagename
        self._templatetype = templatetype
        self._haspropertytemplates = haspropertytemplates

    @property
    def usagename(self):
        return self._usagename

    @usagename.setter
    def usagename(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._usagename = ifclabel(value)
            else:
                self._usagename = value
        else:
            self._usagename = value

    @property
    def templatetype(self):
        return self._templatetype

    @templatetype.setter
    def templatetype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccomplexpropertytemplatetypeenum):
                self._templatetype = ifccomplexpropertytemplatetypeenum(value)
            else:
                self._templatetype = value
        else:
            self._templatetype = value

    @property
    def haspropertytemplates(self):
        return self._haspropertytemplates

    @haspropertytemplates.setter
    def haspropertytemplates(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'ifcpropertytemplate', scope=schema_scope)):
                self._haspropertytemplates = SET(value)
            else:
                self._haspropertytemplates = value
        else:
            self._haspropertytemplates = value

    def uniquepropertynames(self):
        eval_uniquepropertynames_wr = ifcuniquepropertytemplatenames(self.haspropertytemplates)
        if not eval_uniquepropertynames_wr:
            raise AssertionError('Rule uniquepropertynames violated')
        else:
            return eval_uniquepropertynames_wr

    def noselfreference(self):
        eval_noselfreference_wr = (SIZEOF(None) == 0)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifccovering #
####################
class ifccovering(ifcbuildingelement):
    '''Entity ifccovering definition.

	:param predefinedtype
	:type predefinedtype:ifccoveringtypeenum

	:param coversspaces
	:type coversspaces:SET(0,1,'ifcrelcoversspaces', scope = schema_scope)

	:param coverselements
	:type coverselements:SET(0,1,'ifcrelcoversbldgelements', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccoveringtypeenum):
                self._predefinedtype = ifccoveringtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def coversspaces(self):
        return self._coversspaces

    @coversspaces.setter
    def coversspaces(self, value):
        # INVERSE argument
        raise AssertionError('Argument coversspaces is INVERSE. It is computed and can not be set to any value')

    @property
    def coverselements(self):
        return self._coverselements

    @coverselements.setter
    def coverselements(self, value):
        # INVERSE argument
        raise AssertionError('Argument coverselements is INVERSE. It is computed and can not be set to any value')

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifccoveringtypeenum.userdefined)) or (
                        (self.predefinedtype == ifccoveringtypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCOVERINGTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcorganization #
####################
class ifcorganization(BaseEntityClass):
    '''Entity ifcorganization definition.

	:param identification
	:type identification:ifcidentifier

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param roles
	:type roles:LIST(1,None,'ifcactorrole', scope = schema_scope)

	:param addresses
	:type addresses:LIST(1,None,'ifcaddress', scope = schema_scope)

	:param isrelatedby
	:type isrelatedby:SET(0,None,'ifcorganizationrelationship', scope = schema_scope)

	:param relates
	:type relates:SET(0,None,'ifcorganizationrelationship', scope = schema_scope)

	:param engages
	:type engages:SET(0,None,'ifcpersonandorganization', scope = schema_scope)
	'''

    def __init__(self, identification, name, description, roles, addresses, ):
        self._identification = identification
        self._name = name
        self._description = description
        self._roles = roles
        self._addresses = addresses

    @property
    def identification(self):
        return self._identification

    @identification.setter
    def identification(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._identification = ifcidentifier(value)
            else:
                self._identification = value
        else:
            self._identification = value

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._name = ifclabel(value)
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def roles(self):
        return self._roles

    @roles.setter
    def roles(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcactorrole', scope=schema_scope)):
                self._roles = LIST(value)
            else:
                self._roles = value
        else:
            self._roles = value

    @property
    def addresses(self):
        return self._addresses

    @addresses.setter
    def addresses(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcaddress', scope=schema_scope)):
                self._addresses = LIST(value)
            else:
                self._addresses = value
        else:
            self._addresses = value

    @property
    def isrelatedby(self):
        return self._isrelatedby

    @isrelatedby.setter
    def isrelatedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument isrelatedby is INVERSE. It is computed and can not be set to any value')

    @property
    def relates(self):
        return self._relates

    @relates.setter
    def relates(self, value):
        # INVERSE argument
        raise AssertionError('Argument relates is INVERSE. It is computed and can not be set to any value')

    @property
    def engages(self):
        return self._engages

    @engages.setter
    def engages(self, value):
        # INVERSE argument
        raise AssertionError('Argument engages is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifccartesianpoint #
####################
class ifccartesianpoint(ifcpoint):
    '''Entity ifccartesianpoint definition.

	:param coordinates
	:type coordinates:LIST(1,3,'REAL', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, coordinates, ):
        ifcpoint.__init__(self, )
        self._coordinates = coordinates

    @property
    def coordinates(self):
        return self._coordinates

    @coordinates.setter
    def coordinates(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, 3, 'REAL', scope=schema_scope)):
            self._coordinates = LIST(value)
        else:
            self._coordinates = value

    @property
    def dim(self):
        attribute_eval = HIINDEX(self.coordinates)
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')

    def cp2dor3d(self):
        eval_cp2dor3d_wr = (HIINDEX(self.coordinates) >= 2)
        if not eval_cp2dor3d_wr:
            raise AssertionError('Rule cp2dor3d violated')
        else:
            return eval_cp2dor3d_wr


####################
# ENTITY ifccartesianpointlist3d #
####################
class ifccartesianpointlist3d(ifccartesianpointlist):
    '''Entity ifccartesianpointlist3d definition.

	:param coordlist
	:type coordlist:LIST(1,None,LIST(3,3,'REAL', scope = schema_scope))

	:param taglist
	:type taglist:LIST(1,None,'STRING', scope = schema_scope)
	'''

    def __init__(self, coordlist, taglist, ):
        ifccartesianpointlist.__init__(self, )
        self._coordlist = coordlist
        self._taglist = taglist

    @property
    def coordlist(self):
        return self._coordlist

    @coordlist.setter
    def coordlist(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, LIST(3, 3, 'REAL', scope=schema_scope))):
            self._coordlist = LIST(value)
        else:
            self._coordlist = value

    @property
    def taglist(self):
        return self._taglist

    @taglist.setter
    def taglist(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'STRING', scope=schema_scope)):
                self._taglist = LIST(value)
            else:
                self._taglist = value
        else:
            self._taglist = value


####################
# ENTITY ifcrelassociatesapproval #
####################
class ifcrelassociatesapproval(ifcrelassociates):
    '''Entity ifcrelassociatesapproval definition.

	:param relatingapproval
	:type relatingapproval:ifcapproval
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatedobjects, relatingapproval, ):
        ifcrelassociates.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                  inherited3__description, inherited4__relatedobjects, )
        self._relatingapproval = relatingapproval

    @property
    def relatingapproval(self):
        return self._relatingapproval

    @relatingapproval.setter
    def relatingapproval(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcapproval):
            self._relatingapproval = ifcapproval(value)
        else:
            self._relatingapproval = value


####################
# ENTITY ifcfilter #
####################
class ifcfilter(ifcflowtreatmentdevice):
    '''Entity ifcfilter definition.

	:param predefinedtype
	:type predefinedtype:ifcfiltertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowtreatmentdevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                        inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcfiltertypeenum):
                self._predefinedtype = ifcfiltertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcfiltertypeenum.userdefined)) or (
                        (self.predefinedtype == ifcfiltertypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCFILTERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcrectanglehollowprofiledef #
####################
class ifcrectanglehollowprofiledef(ifcrectangleprofiledef):
    '''Entity ifcrectanglehollowprofiledef definition.

	:param wallthickness
	:type wallthickness:ifcpositivelengthmeasure

	:param innerfilletradius
	:type innerfilletradius:ifcnonnegativelengthmeasure

	:param outerfilletradius
	:type outerfilletradius:ifcnonnegativelengthmeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, inherited3__xdim,
                 inherited4__ydim, wallthickness, innerfilletradius, outerfilletradius, ):
        ifcrectangleprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position,
                                        inherited3__xdim, inherited4__ydim, )
        self._wallthickness = wallthickness
        self._innerfilletradius = innerfilletradius
        self._outerfilletradius = outerfilletradius

    @property
    def wallthickness(self):
        return self._wallthickness

    @wallthickness.setter
    def wallthickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._wallthickness = ifcpositivelengthmeasure(value)
        else:
            self._wallthickness = value

    @property
    def innerfilletradius(self):
        return self._innerfilletradius

    @innerfilletradius.setter
    def innerfilletradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._innerfilletradius = ifcnonnegativelengthmeasure(value)
            else:
                self._innerfilletradius = value
        else:
            self._innerfilletradius = value

    @property
    def outerfilletradius(self):
        return self._outerfilletradius

    @outerfilletradius.setter
    def outerfilletradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._outerfilletradius = ifcnonnegativelengthmeasure(value)
            else:
                self._outerfilletradius = value
        else:
            self._outerfilletradius = value

    def validwallthickness(self):
        eval_validwallthickness_wr = ((self.wallthickness < (self.self.ifcrectangleprofiledef.self.xdim / 2)) and (
                    self.wallthickness < (self.self.ifcrectangleprofiledef.self.ydim / 2)))
        if not eval_validwallthickness_wr:
            raise AssertionError('Rule validwallthickness violated')
        else:
            return eval_validwallthickness_wr

    def validinnerradius(self):
        eval_validinnerradius_wr = ((not EXISTS(self.innerfilletradius)) or ((self.innerfilletradius <= (
                    (self.self.ifcrectangleprofiledef.self.xdim / 2) - self.wallthickness)) and (
                                                                                         self.innerfilletradius <= ((
                                                                                                                                self.self.ifcrectangleprofiledef.self.ydim / 2) - self.wallthickness))))
        if not eval_validinnerradius_wr:
            raise AssertionError('Rule validinnerradius violated')
        else:
            return eval_validinnerradius_wr

    def validouterradius(self):
        eval_validouterradius_wr = ((not EXISTS(self.outerfilletradius)) or (
                    (self.outerfilletradius <= (self.self.ifcrectangleprofiledef.self.xdim / 2)) and (
                        self.outerfilletradius <= (self.self.ifcrectangleprofiledef.self.ydim / 2))))
        if not eval_validouterradius_wr:
            raise AssertionError('Rule validouterradius violated')
        else:
            return eval_validouterradius_wr


####################
# ENTITY ifcbooleanclippingresult #
####################
class ifcbooleanclippingresult(ifcbooleanresult):
    '''Entity ifcbooleanclippingresult definition.
	'''

    def __init__(self, inherited0__operator, inherited1__firstoperand, inherited2__secondoperand, ):
        ifcbooleanresult.__init__(self, inherited0__operator, inherited1__firstoperand, inherited2__secondoperand, )

    def firstoperandtype(self):
        eval_firstoperandtype_wr = ((('IFC4X2.IFCSWEPTAREASOLID' == TYPEOF(self.firstoperand)) or (
                    'IFC4X2.IFCSWEPTDISCSOLID' == TYPEOF(self.firstoperand))) or (
                                                'IFC4X2.IFCBOOLEANCLIPPINGRESULT' == TYPEOF(self.firstoperand)))
        if not eval_firstoperandtype_wr:
            raise AssertionError('Rule firstoperandtype violated')
        else:
            return eval_firstoperandtype_wr

    def secondoperandtype(self):
        eval_secondoperandtype_wr = ('IFC4X2.IFCHALFSPACESOLID' == TYPEOF(self.secondoperand))
        if not eval_secondoperandtype_wr:
            raise AssertionError('Rule secondoperandtype violated')
        else:
            return eval_secondoperandtype_wr

    def operatortype(self):
        eval_operatortype_wr = (self.operator == ifcbooleanoperator.difference)
        if not eval_operatortype_wr:
            raise AssertionError('Rule operatortype violated')
        else:
            return eval_operatortype_wr


####################
# ENTITY ifcchiller #
####################
class ifcchiller(ifcenergyconversiondevice):
    '''Entity ifcchiller definition.

	:param predefinedtype
	:type predefinedtype:ifcchillertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcchillertypeenum):
                self._predefinedtype = ifcchillertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcchillertypeenum.userdefined)) or (
                        (self.predefinedtype == ifcchillertypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCHILLERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifccommunicationsappliancetype #
####################
class ifccommunicationsappliancetype(ifcflowterminaltype):
    '''Entity ifccommunicationsappliancetype definition.

	:param predefinedtype
	:type predefinedtype:ifccommunicationsappliancetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowterminaltype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__applicableoccurrence,
                                     inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                     inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccommunicationsappliancetypeenum):
            self._predefinedtype = ifccommunicationsappliancetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccommunicationsappliancetypeenum.userdefined) or (
                    (self.predefinedtype == ifccommunicationsappliancetypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifccurtainwall #
####################
class ifccurtainwall(ifcbuildingelement):
    '''Entity ifccurtainwall definition.

	:param predefinedtype
	:type predefinedtype:ifccurtainwalltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcbuildingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                    inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccurtainwalltypeenum):
                self._predefinedtype = ifccurtainwalltypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifccurtainwalltypeenum.userdefined)) or ((
                                                                                                self.predefinedtype == ifccurtainwalltypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCURTAINWALLTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcdamper #
####################
class ifcdamper(ifcflowcontroller):
    '''Entity ifcdamper definition.

	:param predefinedtype
	:type predefinedtype:ifcdampertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowcontroller.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                   inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                   inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdampertypeenum):
                self._predefinedtype = ifcdampertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcdampertypeenum.userdefined)) or (
                        (self.predefinedtype == ifcdampertypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCDAMPERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcflowinstrumenttype #
####################
class ifcflowinstrumenttype(ifcdistributioncontrolelementtype):
    '''Entity ifcflowinstrumenttype definition.

	:param predefinedtype
	:type predefinedtype:ifcflowinstrumenttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcdistributioncontrolelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory,
                                                   inherited2__name, inherited3__description,
                                                   inherited4__applicableoccurrence, inherited5__haspropertysets,
                                                   inherited6__representationmaps, inherited7__tag,
                                                   inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcflowinstrumenttypeenum):
            self._predefinedtype = ifcflowinstrumenttypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcflowinstrumenttypeenum.userdefined) or (
                    (self.predefinedtype == ifcflowinstrumenttypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcmateriallayerwithoffsets #
####################
class ifcmateriallayerwithoffsets(ifcmateriallayer):
    '''Entity ifcmateriallayerwithoffsets definition.

	:param offsetdirection
	:type offsetdirection:ifclayersetdirectionenum

	:param offsetvalues
	:type offsetvalues:ARRAY(1,2,'REAL', scope = schema_scope)
	'''

    def __init__(self, inherited0__material, inherited1__layerthickness, inherited2__isventilated, inherited3__name,
                 inherited4__description, inherited5__category, inherited6__priority, offsetdirection, offsetvalues, ):
        ifcmateriallayer.__init__(self, inherited0__material, inherited1__layerthickness, inherited2__isventilated,
                                  inherited3__name, inherited4__description, inherited5__category,
                                  inherited6__priority, )
        self._offsetdirection = offsetdirection
        self._offsetvalues = offsetvalues

    @property
    def offsetdirection(self):
        return self._offsetdirection

    @offsetdirection.setter
    def offsetdirection(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclayersetdirectionenum):
            self._offsetdirection = ifclayersetdirectionenum(value)
        else:
            self._offsetdirection = value

    @property
    def offsetvalues(self):
        return self._offsetvalues

    @offsetvalues.setter
    def offsetvalues(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ARRAY(1, 2, 'REAL', scope=schema_scope)):
            self._offsetvalues = ARRAY(value)
        else:
            self._offsetvalues = value


####################
# ENTITY ifcmaterialprofileset #
####################
class ifcmaterialprofileset(ifcmaterialdefinition):
    '''Entity ifcmaterialprofileset definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param materialprofiles
	:type materialprofiles:LIST(1,None,'ifcmaterialprofile', scope = schema_scope)

	:param compositeprofile
	:type compositeprofile:ifccompositeprofiledef
	'''

    def __init__(self, name, description, materialprofiles, compositeprofile, ):
        ifcmaterialdefinition.__init__(self, )
        self._name = name
        self._description = description
        self._materialprofiles = materialprofiles
        self._compositeprofile = compositeprofile

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._description = ifctext(value)
            else:
                self._description = value
        else:
            self._description = value

    @property
    def materialprofiles(self):
        return self._materialprofiles

    @materialprofiles.setter
    def materialprofiles(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcmaterialprofile', scope=schema_scope)):
            self._materialprofiles = LIST(value)
        else:
            self._materialprofiles = value

    @property
    def compositeprofile(self):
        return self._compositeprofile

    @compositeprofile.setter
    def compositeprofile(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccompositeprofiledef):
                self._compositeprofile = ifccompositeprofiledef(value)
            else:
                self._compositeprofile = value
        else:
            self._compositeprofile = value


####################
# ENTITY ifcresourceconstraintrelationship #
####################
class ifcresourceconstraintrelationship(ifcresourcelevelrelationship):
    '''Entity ifcresourceconstraintrelationship definition.

	:param relatingconstraint
	:type relatingconstraint:ifcconstraint

	:param relatedresourceobjects
	:type relatedresourceobjects:SET(1,None,'ifcresourceobjectselect', scope = schema_scope)
	'''

    def __init__(self, inherited0__name, inherited1__description, relatingconstraint, relatedresourceobjects, ):
        ifcresourcelevelrelationship.__init__(self, inherited0__name, inherited1__description, )
        self._relatingconstraint = relatingconstraint
        self._relatedresourceobjects = relatedresourceobjects

    @property
    def relatingconstraint(self):
        return self._relatingconstraint

    @relatingconstraint.setter
    def relatingconstraint(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcconstraint):
            self._relatingconstraint = ifcconstraint(value)
        else:
            self._relatingconstraint = value

    @property
    def relatedresourceobjects(self):
        return self._relatedresourceobjects

    @relatedresourceobjects.setter
    def relatedresourceobjects(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcresourceobjectselect', scope=schema_scope)):
            self._relatedresourceobjects = SET(value)
        else:
            self._relatedresourceobjects = value


####################
# ENTITY ifcfurniture #
####################
class ifcfurniture(ifcfurnishingelement):
    '''Entity ifcfurniture definition.

	:param predefinedtype
	:type predefinedtype:ifcfurnituretypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcfurnishingelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                      inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                      inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcfurnituretypeenum):
                self._predefinedtype = ifcfurnituretypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcfurnituretypeenum.userdefined)) or ((
                                                                                              self.predefinedtype == ifcfurnituretypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCFURNITURETYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcdimensionalexponents #
####################
class ifcdimensionalexponents(BaseEntityClass):
    '''Entity ifcdimensionalexponents definition.

	:param lengthexponent
	:type lengthexponent:Integer

	:param massexponent
	:type massexponent:Integer

	:param timeexponent
	:type timeexponent:Integer

	:param electriccurrentexponent
	:type electriccurrentexponent:Integer

	:param thermodynamictemperatureexponent
	:type thermodynamictemperatureexponent:Integer

	:param amountofsubstanceexponent
	:type amountofsubstanceexponent:Integer

	:param luminousintensityexponent
	:type luminousintensityexponent:Integer
	'''

    def __init__(self, lengthexponent, massexponent, timeexponent, electriccurrentexponent,
                 thermodynamictemperatureexponent, amountofsubstanceexponent, luminousintensityexponent, ):
        self._lengthexponent = lengthexponent
        self._massexponent = massexponent
        self._timeexponent = timeexponent
        self._electriccurrentexponent = electriccurrentexponent
        self._thermodynamictemperatureexponent = thermodynamictemperatureexponent
        self._amountofsubstanceexponent = amountofsubstanceexponent
        self._luminousintensityexponent = luminousintensityexponent

    @property
    def lengthexponent(self):
        return self._lengthexponent

    @lengthexponent.setter
    def lengthexponent(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, Integer):
            self._lengthexponent = Integer(value)
        else:
            self._lengthexponent = value

    @property
    def massexponent(self):
        return self._massexponent

    @massexponent.setter
    def massexponent(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, Integer):
            self._massexponent = Integer(value)
        else:
            self._massexponent = value

    @property
    def timeexponent(self):
        return self._timeexponent

    @timeexponent.setter
    def timeexponent(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, Integer):
            self._timeexponent = Integer(value)
        else:
            self._timeexponent = value

    @property
    def electriccurrentexponent(self):
        return self._electriccurrentexponent

    @electriccurrentexponent.setter
    def electriccurrentexponent(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, Integer):
            self._electriccurrentexponent = Integer(value)
        else:
            self._electriccurrentexponent = value

    @property
    def thermodynamictemperatureexponent(self):
        return self._thermodynamictemperatureexponent

    @thermodynamictemperatureexponent.setter
    def thermodynamictemperatureexponent(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, Integer):
            self._thermodynamictemperatureexponent = Integer(value)
        else:
            self._thermodynamictemperatureexponent = value

    @property
    def amountofsubstanceexponent(self):
        return self._amountofsubstanceexponent

    @amountofsubstanceexponent.setter
    def amountofsubstanceexponent(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, Integer):
            self._amountofsubstanceexponent = Integer(value)
        else:
            self._amountofsubstanceexponent = value

    @property
    def luminousintensityexponent(self):
        return self._luminousintensityexponent

    @luminousintensityexponent.setter
    def luminousintensityexponent(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, Integer):
            self._luminousintensityexponent = Integer(value)
        else:
            self._luminousintensityexponent = value


####################
# ENTITY ifcjunctionbox #
####################
class ifcjunctionbox(ifcflowfitting):
    '''Entity ifcjunctionbox definition.

	:param predefinedtype
	:type predefinedtype:ifcjunctionboxtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowfitting.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcjunctionboxtypeenum):
                self._predefinedtype = ifcjunctionboxtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcjunctionboxtypeenum.userdefined)) or ((
                                                                                                self.predefinedtype == ifcjunctionboxtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCJUNCTIONBOXTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcrelconnectsstructuralactivity #
####################
class ifcrelconnectsstructuralactivity(ifcrelconnects):
    '''Entity ifcrelconnectsstructuralactivity definition.

	:param relatingelement
	:type relatingelement:ifcstructuralactivityassignmentselect

	:param relatedstructuralactivity
	:type relatedstructuralactivity:ifcstructuralactivity
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingelement, relatedstructuralactivity, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatingelement = relatingelement
        self._relatedstructuralactivity = relatedstructuralactivity

    @property
    def relatingelement(self):
        return self._relatingelement

    @relatingelement.setter
    def relatingelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstructuralactivityassignmentselect):
            self._relatingelement = ifcstructuralactivityassignmentselect(value)
        else:
            self._relatingelement = value

    @property
    def relatedstructuralactivity(self):
        return self._relatedstructuralactivity

    @relatedstructuralactivity.setter
    def relatedstructuralactivity(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstructuralactivity):
            self._relatedstructuralactivity = ifcstructuralactivity(value)
        else:
            self._relatedstructuralactivity = value


####################
# ENTITY ifcstackterminal #
####################
class ifcstackterminal(ifcflowterminal):
    '''Entity ifcstackterminal definition.

	:param predefinedtype
	:type predefinedtype:ifcstackterminaltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowterminal.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcstackterminaltypeenum):
                self._predefinedtype = ifcstackterminaltypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcstackterminaltypeenum.userdefined)) or ((
                                                                                                  self.predefinedtype == ifcstackterminaltypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCSTACKTERMINALTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifccompressor #
####################
class ifccompressor(ifcflowmovingdevice):
    '''Entity ifccompressor definition.

	:param predefinedtype
	:type predefinedtype:ifccompressortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowmovingdevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccompressortypeenum):
                self._predefinedtype = ifccompressortypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifccompressortypeenum.userdefined)) or ((
                                                                                               self.predefinedtype == ifccompressortypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCOMPRESSORTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcbearingtype #
####################
class ifcbearingtype(ifcbuildingelementtype):
    '''Entity ifcbearingtype definition.

	:param predefinedtype
	:type predefinedtype:ifcbearingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcbearingtypeenum):
            self._predefinedtype = ifcbearingtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcbearingtypeenum.userdefined) or (
                    (self.predefinedtype == ifcbearingtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcburner #
####################
class ifcburner(ifcenergyconversiondevice):
    '''Entity ifcburner definition.

	:param predefinedtype
	:type predefinedtype:ifcburnertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcburnertypeenum):
                self._predefinedtype = ifcburnertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcburnertypeenum.userdefined)) or (
                        (self.predefinedtype == ifcburnertypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCBURNERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifccrewresourcetype #
####################
class ifccrewresourcetype(ifcconstructionresourcetype):
    '''Entity ifccrewresourcetype definition.

	:param predefinedtype
	:type predefinedtype:ifccrewresourcetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__identification,
                 inherited7__longdescription, inherited8__resourcetype, inherited9__basecosts,
                 inherited10__basequantity, predefinedtype, ):
        ifcconstructionresourcetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                             inherited3__description, inherited4__applicableoccurrence,
                                             inherited5__haspropertysets, inherited6__identification,
                                             inherited7__longdescription, inherited8__resourcetype,
                                             inherited9__basecosts, inherited10__basequantity, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccrewresourcetypeenum):
            self._predefinedtype = ifccrewresourcetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccrewresourcetypeenum.userdefined) or (
                    (self.predefinedtype == ifccrewresourcetypeenum.userdefined) and EXISTS(
                self.self.ifctyperesource.self.resourcetype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcstructuralpointaction #
####################
class ifcstructuralpointaction(ifcstructuralaction):
    '''Entity ifcstructuralpointaction definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__appliedload, inherited8__globalorlocal, inherited9__destabilizingload, ):
        ifcstructuralaction.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                     inherited6__representation, inherited7__appliedload, inherited8__globalorlocal,
                                     inherited9__destabilizingload, )

    def suitableloadtype(self):
        eval_suitableloadtype_wr = (SIZEOF(
            ['IFC4X2.IFCSTRUCTURALLOADSINGLEFORCE', 'IFC4X2.IFCSTRUCTURALLOADSINGLEDISPLACEMENT'] * TYPEOF(
                self.self.ifcstructuralactivity.self.appliedload)) == 1)
        if not eval_suitableloadtype_wr:
            raise AssertionError('Rule suitableloadtype violated')
        else:
            return eval_suitableloadtype_wr


####################
# ENTITY ifctrimmedcurve #
####################
class ifctrimmedcurve(ifcboundedcurve):
    '''Entity ifctrimmedcurve definition.

	:param basiscurve
	:type basiscurve:ifccurve

	:param trim1
	:type trim1:SET(1,2,'ifctrimmingselect', scope = schema_scope)

	:param trim2
	:type trim2:SET(1,2,'ifctrimmingselect', scope = schema_scope)

	:param senseagreement
	:type senseagreement:ifcboolean

	:param masterrepresentation
	:type masterrepresentation:ifctrimmingpreference
	'''

    def __init__(self, basiscurve, trim1, trim2, senseagreement, masterrepresentation, ):
        ifcboundedcurve.__init__(self, )
        self._basiscurve = basiscurve
        self._trim1 = trim1
        self._trim2 = trim2
        self._senseagreement = senseagreement
        self._masterrepresentation = masterrepresentation

    @property
    def basiscurve(self):
        return self._basiscurve

    @basiscurve.setter
    def basiscurve(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._basiscurve = ifccurve(value)
        else:
            self._basiscurve = value

    @property
    def trim1(self):
        return self._trim1

    @trim1.setter
    def trim1(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, 2, 'ifctrimmingselect', scope=schema_scope)):
            self._trim1 = SET(value)
        else:
            self._trim1 = value

    @property
    def trim2(self):
        return self._trim2

    @trim2.setter
    def trim2(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, 2, 'ifctrimmingselect', scope=schema_scope)):
            self._trim2 = SET(value)
        else:
            self._trim2 = value

    @property
    def senseagreement(self):
        return self._senseagreement

    @senseagreement.setter
    def senseagreement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._senseagreement = ifcboolean(value)
        else:
            self._senseagreement = value

    @property
    def masterrepresentation(self):
        return self._masterrepresentation

    @masterrepresentation.setter
    def masterrepresentation(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctrimmingpreference):
            self._masterrepresentation = ifctrimmingpreference(value)
        else:
            self._masterrepresentation = value

    def trim1valuesconsistent(self):
        eval_trim1valuesconsistent_wr = ((HIINDEX(self.trim1) == 1) or (TYPEOF(self.trim1[1]) != TYPEOF(self.trim1[2])))
        if not eval_trim1valuesconsistent_wr:
            raise AssertionError('Rule trim1valuesconsistent violated')
        else:
            return eval_trim1valuesconsistent_wr

    def trim2valuesconsistent(self):
        eval_trim2valuesconsistent_wr = ((HIINDEX(self.trim2) == 1) or (TYPEOF(self.trim2[1]) != TYPEOF(self.trim2[2])))
        if not eval_trim2valuesconsistent_wr:
            raise AssertionError('Rule trim2valuesconsistent violated')
        else:
            return eval_trim2valuesconsistent_wr

    def notrimofboundedcurves(self):
        eval_notrimofboundedcurves_wr = (not ('IFC4X2.IFCBOUNDEDCURVE' == TYPEOF(self.basiscurve)))
        if not eval_notrimofboundedcurves_wr:
            raise AssertionError('Rule notrimofboundedcurves violated')
        else:
            return eval_notrimofboundedcurves_wr


####################
# ENTITY ifcunitarycontrolelementtype #
####################
class ifcunitarycontrolelementtype(ifcdistributioncontrolelementtype):
    '''Entity ifcunitarycontrolelementtype definition.

	:param predefinedtype
	:type predefinedtype:ifcunitarycontrolelementtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcdistributioncontrolelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory,
                                                   inherited2__name, inherited3__description,
                                                   inherited4__applicableoccurrence, inherited5__haspropertysets,
                                                   inherited6__representationmaps, inherited7__tag,
                                                   inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcunitarycontrolelementtypeenum):
            self._predefinedtype = ifcunitarycontrolelementtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcunitarycontrolelementtypeenum.userdefined) or (
                    (self.predefinedtype == ifcunitarycontrolelementtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcevent #
####################
class ifcevent(ifcprocess):
    '''Entity ifcevent definition.

	:param predefinedtype
	:type predefinedtype:ifceventtypeenum

	:param eventtriggertype
	:type eventtriggertype:ifceventtriggertypeenum

	:param userdefinedeventtriggertype
	:type userdefinedeventtriggertype:ifclabel

	:param eventoccurencetime
	:type eventoccurencetime:ifceventtime
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, inherited6__longdescription, predefinedtype,
                 eventtriggertype, userdefinedeventtriggertype, eventoccurencetime, ):
        ifcprocess.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__identification,
                            inherited6__longdescription, )
        self._predefinedtype = predefinedtype
        self._eventtriggertype = eventtriggertype
        self._userdefinedeventtriggertype = userdefinedeventtriggertype
        self._eventoccurencetime = eventoccurencetime

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifceventtypeenum):
                self._predefinedtype = ifceventtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def eventtriggertype(self):
        return self._eventtriggertype

    @eventtriggertype.setter
    def eventtriggertype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifceventtriggertypeenum):
                self._eventtriggertype = ifceventtriggertypeenum(value)
            else:
                self._eventtriggertype = value
        else:
            self._eventtriggertype = value

    @property
    def userdefinedeventtriggertype(self):
        return self._userdefinedeventtriggertype

    @userdefinedeventtriggertype.setter
    def userdefinedeventtriggertype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._userdefinedeventtriggertype = ifclabel(value)
            else:
                self._userdefinedeventtriggertype = value
        else:
            self._userdefinedeventtriggertype = value

    @property
    def eventoccurencetime(self):
        return self._eventoccurencetime

    @eventoccurencetime.setter
    def eventoccurencetime(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifceventtime):
                self._eventoccurencetime = ifceventtime(value)
            else:
                self._eventoccurencetime = value
        else:
            self._eventoccurencetime = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifceventtypeenum.userdefined)) or (
                        (self.predefinedtype == ifceventtypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = (((not EXISTS(self.eventtriggertype)) or (
                    self.eventtriggertype != ifceventtriggertypeenum.userdefined)) or ((
                                                                                                   self.eventtriggertype == ifceventtriggertypeenum.userdefined) and EXISTS(
            self.userdefinedeventtriggertype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcrelassignstoactor #
####################
class ifcrelassignstoactor(ifcrelassigns):
    '''Entity ifcrelassignstoactor definition.

	:param relatingactor
	:type relatingactor:ifcactor

	:param actingrole
	:type actingrole:ifcactorrole
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatedobjects, inherited5__relatedobjectstype, relatingactor, actingrole, ):
        ifcrelassigns.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                               inherited3__description, inherited4__relatedobjects, inherited5__relatedobjectstype, )
        self._relatingactor = relatingactor
        self._actingrole = actingrole

    @property
    def relatingactor(self):
        return self._relatingactor

    @relatingactor.setter
    def relatingactor(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcactor):
            self._relatingactor = ifcactor(value)
        else:
            self._relatingactor = value

    @property
    def actingrole(self):
        return self._actingrole

    @actingrole.setter
    def actingrole(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcactorrole):
                self._actingrole = ifcactorrole(value)
            else:
                self._actingrole = value
        else:
            self._actingrole = value

    def noselfreference(self):
        eval_noselfreference_wr = (SIZEOF(None) == 0)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifctable #
####################
class ifctable(BaseEntityClass):
    '''Entity ifctable definition.

	:param name
	:type name:ifclabel

	:param rows
	:type rows:LIST(1,None,'ifctablerow', scope = schema_scope)

	:param columns
	:type columns:LIST(1,None,'ifctablecolumn', scope = schema_scope)

	:param numberofcellsinrow
	:type numberofcellsinrow:ifcinteger

	:param numberofheadings
	:type numberofheadings:ifcinteger

	:param numberofdatarows
	:type numberofdatarows:ifcinteger
	'''

    def __init__(self, name, rows, columns, ):
        self._name = name
        self._rows = rows
        self._columns = columns

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._name = ifclabel(value)
            else:
                self._name = value
        else:
            self._name = value

    @property
    def rows(self):
        return self._rows

    @rows.setter
    def rows(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifctablerow', scope=schema_scope)):
                self._rows = LIST(value)
            else:
                self._rows = value
        else:
            self._rows = value

    @property
    def columns(self):
        return self._columns

    @columns.setter
    def columns(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifctablecolumn', scope=schema_scope)):
                self._columns = LIST(value)
            else:
                self._columns = value
        else:
            self._columns = value

    @property
    def numberofcellsinrow(self):
        attribute_eval = HIINDEX(self.rows[1].self.rowcells)
        return attribute_eval

    @numberofcellsinrow.setter
    def numberofcellsinrow(self, value):
        # DERIVED argument
        raise AssertionError('Argument numberofcellsinrow is DERIVED. It is computed and can not be set to any value')

    @property
    def numberofheadings(self):
        attribute_eval = SIZEOF(None)
        return attribute_eval

    @numberofheadings.setter
    def numberofheadings(self, value):
        # DERIVED argument
        raise AssertionError('Argument numberofheadings is DERIVED. It is computed and can not be set to any value')

    @property
    def numberofdatarows(self):
        attribute_eval = SIZEOF(None)
        return attribute_eval

    @numberofdatarows.setter
    def numberofdatarows(self, value):
        # DERIVED argument
        raise AssertionError('Argument numberofdatarows is DERIVED. It is computed and can not be set to any value')

    def wr1(self):
        eval_wr1_wr = (SIZEOF(None) == 0)
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr

    def wr2(self):
        eval_wr2_wr = ((0 <= self.numberofheadings) and (self.numberofheadings <= 1))
        if not eval_wr2_wr:
            raise AssertionError('Rule wr2 violated')
        else:
            return eval_wr2_wr


####################
# ENTITY ifcdistanceexpression #
####################
class ifcdistanceexpression(ifcgeometricrepresentationitem):
    '''Entity ifcdistanceexpression definition.

	:param distancealong
	:type distancealong:ifclengthmeasure

	:param offsetlateral
	:type offsetlateral:ifclengthmeasure

	:param offsetvertical
	:type offsetvertical:ifclengthmeasure

	:param offsetlongitudinal
	:type offsetlongitudinal:ifclengthmeasure

	:param alonghorizontal
	:type alonghorizontal:ifcboolean
	'''

    def __init__(self, distancealong, offsetlateral, offsetvertical, offsetlongitudinal, alonghorizontal, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._distancealong = distancealong
        self._offsetlateral = offsetlateral
        self._offsetvertical = offsetvertical
        self._offsetlongitudinal = offsetlongitudinal
        self._alonghorizontal = alonghorizontal

    @property
    def distancealong(self):
        return self._distancealong

    @distancealong.setter
    def distancealong(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._distancealong = ifclengthmeasure(value)
        else:
            self._distancealong = value

    @property
    def offsetlateral(self):
        return self._offsetlateral

    @offsetlateral.setter
    def offsetlateral(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._offsetlateral = ifclengthmeasure(value)
            else:
                self._offsetlateral = value
        else:
            self._offsetlateral = value

    @property
    def offsetvertical(self):
        return self._offsetvertical

    @offsetvertical.setter
    def offsetvertical(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._offsetvertical = ifclengthmeasure(value)
            else:
                self._offsetvertical = value
        else:
            self._offsetvertical = value

    @property
    def offsetlongitudinal(self):
        return self._offsetlongitudinal

    @offsetlongitudinal.setter
    def offsetlongitudinal(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._offsetlongitudinal = ifclengthmeasure(value)
            else:
                self._offsetlongitudinal = value
        else:
            self._offsetlongitudinal = value

    @property
    def alonghorizontal(self):
        return self._alonghorizontal

    @alonghorizontal.setter
    def alonghorizontal(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._alonghorizontal = ifcboolean(value)
            else:
                self._alonghorizontal = value
        else:
            self._alonghorizontal = value


####################
# ENTITY ifcpersonandorganization #
####################
class ifcpersonandorganization(BaseEntityClass):
    '''Entity ifcpersonandorganization definition.

	:param theperson
	:type theperson:ifcperson

	:param theorganization
	:type theorganization:ifcorganization

	:param roles
	:type roles:LIST(1,None,'ifcactorrole', scope = schema_scope)
	'''

    def __init__(self, theperson, theorganization, roles, ):
        self._theperson = theperson
        self._theorganization = theorganization
        self._roles = roles

    @property
    def theperson(self):
        return self._theperson

    @theperson.setter
    def theperson(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcperson):
            self._theperson = ifcperson(value)
        else:
            self._theperson = value

    @property
    def theorganization(self):
        return self._theorganization

    @theorganization.setter
    def theorganization(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcorganization):
            self._theorganization = ifcorganization(value)
        else:
            self._theorganization = value

    @property
    def roles(self):
        return self._roles

    @roles.setter
    def roles(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcactorrole', scope=schema_scope)):
                self._roles = LIST(value)
            else:
                self._roles = value
        else:
            self._roles = value


####################
# ENTITY ifcstructuralpointconnection #
####################
class ifcstructuralpointconnection(ifcstructuralconnection):
    '''Entity ifcstructuralpointconnection definition.

	:param conditioncoordinatesystem
	:type conditioncoordinatesystem:ifcaxis2placement3d
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__appliedcondition, conditioncoordinatesystem, ):
        ifcstructuralconnection.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                         inherited6__representation, inherited7__appliedcondition, )
        self._conditioncoordinatesystem = conditioncoordinatesystem

    @property
    def conditioncoordinatesystem(self):
        return self._conditioncoordinatesystem

    @conditioncoordinatesystem.setter
    def conditioncoordinatesystem(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcaxis2placement3d):
                self._conditioncoordinatesystem = ifcaxis2placement3d(value)
            else:
                self._conditioncoordinatesystem = value
        else:
            self._conditioncoordinatesystem = value


####################
# ENTITY ifccenterlineprofiledef #
####################
class ifccenterlineprofiledef(ifcarbitraryopenprofiledef):
    '''Entity ifccenterlineprofiledef definition.

	:param thickness
	:type thickness:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__curve, thickness, ):
        ifcarbitraryopenprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename, inherited2__curve, )
        self._thickness = thickness

    @property
    def thickness(self):
        return self._thickness

    @thickness.setter
    def thickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._thickness = ifcpositivelengthmeasure(value)
        else:
            self._thickness = value


####################
# ENTITY ifcpipesegmenttype #
####################
class ifcpipesegmenttype(ifcflowsegmenttype):
    '''Entity ifcpipesegmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifcpipesegmenttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowsegmenttype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__applicableoccurrence,
                                    inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                    inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpipesegmenttypeenum):
            self._predefinedtype = ifcpipesegmenttypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcpipesegmenttypeenum.userdefined) or (
                    (self.predefinedtype == ifcpipesegmenttypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcblobtexture #
####################
class ifcblobtexture(ifcsurfacetexture):
    '''Entity ifcblobtexture definition.

	:param rasterformat
	:type rasterformat:ifcidentifier

	:param rastercode
	:type rastercode:ifcbinary
	'''

    def __init__(self, inherited0__repeats, inherited1__repeatt, inherited2__mode, inherited3__texturetransform,
                 inherited4__parameter, rasterformat, rastercode, ):
        ifcsurfacetexture.__init__(self, inherited0__repeats, inherited1__repeatt, inherited2__mode,
                                   inherited3__texturetransform, inherited4__parameter, )
        self._rasterformat = rasterformat
        self._rastercode = rastercode

    @property
    def rasterformat(self):
        return self._rasterformat

    @rasterformat.setter
    def rasterformat(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcidentifier):
            self._rasterformat = ifcidentifier(value)
        else:
            self._rasterformat = value

    @property
    def rastercode(self):
        return self._rastercode

    @rastercode.setter
    def rastercode(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcbinary):
            self._rastercode = ifcbinary(value)
        else:
            self._rastercode = value

    def supportedrasterformat(self):
        eval_supportedrasterformat_wr = (self.self.rasterformat == ['BMP', 'JPG', 'GIF', 'PNG'])
        if not eval_supportedrasterformat_wr:
            raise AssertionError('Rule supportedrasterformat violated')
        else:
            return eval_supportedrasterformat_wr

    def rastercodebytestream(self):
        eval_rastercodebytestream_wr = ((BLENGTH(self.rastercode) % 8) == 0)
        if not eval_rastercodebytestream_wr:
            raise AssertionError('Rule rastercodebytestream violated')
        else:
            return eval_rastercodebytestream_wr


####################
# ENTITY ifccablefittingtype #
####################
class ifccablefittingtype(ifcflowfittingtype):
    '''Entity ifccablefittingtype definition.

	:param predefinedtype
	:type predefinedtype:ifccablefittingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowfittingtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__applicableoccurrence,
                                    inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                    inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccablefittingtypeenum):
            self._predefinedtype = ifccablefittingtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccablefittingtypeenum.userdefined) or (
                    (self.predefinedtype == ifccablefittingtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcownerhistory #
####################
class ifcownerhistory(BaseEntityClass):
    '''Entity ifcownerhistory definition.

	:param owninguser
	:type owninguser:ifcpersonandorganization

	:param owningapplication
	:type owningapplication:ifcapplication

	:param state
	:type state:ifcstateenum

	:param changeaction
	:type changeaction:ifcchangeactionenum

	:param lastmodifieddate
	:type lastmodifieddate:ifctimestamp

	:param lastmodifyinguser
	:type lastmodifyinguser:ifcpersonandorganization

	:param lastmodifyingapplication
	:type lastmodifyingapplication:ifcapplication

	:param creationdate
	:type creationdate:ifctimestamp
	'''

    def __init__(self, owninguser, owningapplication, state, changeaction, lastmodifieddate, lastmodifyinguser,
                 lastmodifyingapplication, creationdate, ):
        self._owninguser = owninguser
        self._owningapplication = owningapplication
        self._state = state
        self._changeaction = changeaction
        self._lastmodifieddate = lastmodifieddate
        self._lastmodifyinguser = lastmodifyinguser
        self._lastmodifyingapplication = lastmodifyingapplication
        self._creationdate = creationdate

    @property
    def owninguser(self):
        return self._owninguser

    @owninguser.setter
    def owninguser(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpersonandorganization):
            self._owninguser = ifcpersonandorganization(value)
        else:
            self._owninguser = value

    @property
    def owningapplication(self):
        return self._owningapplication

    @owningapplication.setter
    def owningapplication(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcapplication):
            self._owningapplication = ifcapplication(value)
        else:
            self._owningapplication = value

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcstateenum):
                self._state = ifcstateenum(value)
            else:
                self._state = value
        else:
            self._state = value

    @property
    def changeaction(self):
        return self._changeaction

    @changeaction.setter
    def changeaction(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcchangeactionenum):
                self._changeaction = ifcchangeactionenum(value)
            else:
                self._changeaction = value
        else:
            self._changeaction = value

    @property
    def lastmodifieddate(self):
        return self._lastmodifieddate

    @lastmodifieddate.setter
    def lastmodifieddate(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctimestamp):
                self._lastmodifieddate = ifctimestamp(value)
            else:
                self._lastmodifieddate = value
        else:
            self._lastmodifieddate = value

    @property
    def lastmodifyinguser(self):
        return self._lastmodifyinguser

    @lastmodifyinguser.setter
    def lastmodifyinguser(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpersonandorganization):
                self._lastmodifyinguser = ifcpersonandorganization(value)
            else:
                self._lastmodifyinguser = value
        else:
            self._lastmodifyinguser = value

    @property
    def lastmodifyingapplication(self):
        return self._lastmodifyingapplication

    @lastmodifyingapplication.setter
    def lastmodifyingapplication(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcapplication):
                self._lastmodifyingapplication = ifcapplication(value)
            else:
                self._lastmodifyingapplication = value
        else:
            self._lastmodifyingapplication = value

    @property
    def creationdate(self):
        return self._creationdate

    @creationdate.setter
    def creationdate(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctimestamp):
            self._creationdate = ifctimestamp(value)
        else:
            self._creationdate = value

    def correctchangeaction(self):
        eval_correctchangeaction_wr = ((EXISTS(self.lastmodifieddate) or (
                    (not EXISTS(self.lastmodifieddate)) and (not EXISTS(self.changeaction)))) or (((not EXISTS(
            self.lastmodifieddate)) and EXISTS(self.changeaction)) and ((
                                                                                    self.changeaction == ifcchangeactionenum.notdefined) or (
                                                                                    self.changeaction == ifcchangeactionenum.nochange))))
        if not eval_correctchangeaction_wr:
            raise AssertionError('Rule correctchangeaction violated')
        else:
            return eval_correctchangeaction_wr


####################
# ENTITY ifcproject #
####################
class ifcproject(ifccontext):
    '''Entity ifcproject definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__longname, inherited6__phase, inherited7__representationcontexts,
                 inherited8__unitsincontext, ):
        ifccontext.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__longname, inherited6__phase,
                            inherited7__representationcontexts, inherited8__unitsincontext, )

    def hasname(self):
        eval_hasname_wr = EXISTS(self.self.ifcroot.self.name)
        if not eval_hasname_wr:
            raise AssertionError('Rule hasname violated')
        else:
            return eval_hasname_wr

    def correctcontext(self):
        eval_correctcontext_wr = ((not EXISTS(self.self.ifccontext.self.representationcontexts)) or (SIZEOF(None) == 0))
        if not eval_correctcontext_wr:
            raise AssertionError('Rule correctcontext violated')
        else:
            return eval_correctcontext_wr

    def nodecomposition(self):
        eval_nodecomposition_wr = (SIZEOF(self.self.ifcobjectdefinition.self.decomposes) == 0)
        if not eval_nodecomposition_wr:
            raise AssertionError('Rule nodecomposition violated')
        else:
            return eval_nodecomposition_wr


####################
# ENTITY ifcsurfacestylewithtextures #
####################
class ifcsurfacestylewithtextures(ifcpresentationitem):
    '''Entity ifcsurfacestylewithtextures definition.

	:param textures
	:type textures:LIST(1,None,'ifcsurfacetexture', scope = schema_scope)
	'''

    def __init__(self, textures, ):
        ifcpresentationitem.__init__(self, )
        self._textures = textures

    @property
    def textures(self):
        return self._textures

    @textures.setter
    def textures(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcsurfacetexture', scope=schema_scope)):
            self._textures = LIST(value)
        else:
            self._textures = value


####################
# ENTITY ifclightfixturetype #
####################
class ifclightfixturetype(ifcflowterminaltype):
    '''Entity ifclightfixturetype definition.

	:param predefinedtype
	:type predefinedtype:ifclightfixturetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowterminaltype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__applicableoccurrence,
                                     inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                     inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclightfixturetypeenum):
            self._predefinedtype = ifclightfixturetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifclightfixturetypeenum.userdefined) or (
                    (self.predefinedtype == ifclightfixturetypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcsolardevice #
####################
class ifcsolardevice(ifcenergyconversiondevice):
    '''Entity ifcsolardevice definition.

	:param predefinedtype
	:type predefinedtype:ifcsolardevicetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsolardevicetypeenum):
                self._predefinedtype = ifcsolardevicetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcsolardevicetypeenum.userdefined)) or ((
                                                                                                self.predefinedtype == ifcsolardevicetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCSOLARDEVICETYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcworkschedule #
####################
class ifcworkschedule(ifcworkcontrol):
    '''Entity ifcworkschedule definition.

	:param predefinedtype
	:type predefinedtype:ifcworkscheduletypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, inherited6__creationdate, inherited7__creators,
                 inherited8__purpose, inherited9__duration, inherited10__totalfloat, inherited11__starttime,
                 inherited12__finishtime, predefinedtype, ):
        ifcworkcontrol.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__objecttype, inherited5__identification,
                                inherited6__creationdate, inherited7__creators, inherited8__purpose,
                                inherited9__duration, inherited10__totalfloat, inherited11__starttime,
                                inherited12__finishtime, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcworkscheduletypeenum):
                self._predefinedtype = ifcworkscheduletypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcworkscheduletypeenum.userdefined)) or ((
                                                                                                 self.predefinedtype == ifcworkscheduletypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcproxy #
####################
class ifcproxy(ifcproduct):
    '''Entity ifcproxy definition.

	:param proxytype
	:type proxytype:ifcobjecttypeenum

	:param tag
	:type tag:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, proxytype, tag, ):
        ifcproduct.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, )
        self._proxytype = proxytype
        self._tag = tag

    @property
    def proxytype(self):
        return self._proxytype

    @proxytype.setter
    def proxytype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcobjecttypeenum):
            self._proxytype = ifcobjecttypeenum(value)
        else:
            self._proxytype = value

    @property
    def tag(self):
        return self._tag

    @tag.setter
    def tag(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._tag = ifclabel(value)
            else:
                self._tag = value
        else:
            self._tag = value

    def wr1(self):
        eval_wr1_wr = EXISTS(self.self.ifcroot.self.name)
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


####################
# ENTITY ifccablefitting #
####################
class ifccablefitting(ifcflowfitting):
    '''Entity ifccablefitting definition.

	:param predefinedtype
	:type predefinedtype:ifccablefittingtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowfitting.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccablefittingtypeenum):
                self._predefinedtype = ifccablefittingtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifccablefittingtypeenum.userdefined)) or ((
                                                                                                 self.predefinedtype == ifccablefittingtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCABLEFITTINGTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifccurvestyle #
####################
class ifccurvestyle(ifcpresentationstyle):
    '''Entity ifccurvestyle definition.

	:param curvefont
	:type curvefont:ifccurvefontorscaledcurvefontselect

	:param curvewidth
	:type curvewidth:ifcsizeselect

	:param curvecolour
	:type curvecolour:ifccolour

	:param modelordraughting
	:type modelordraughting:ifcboolean
	'''

    def __init__(self, inherited0__name, curvefont, curvewidth, curvecolour, modelordraughting, ):
        ifcpresentationstyle.__init__(self, inherited0__name, )
        self._curvefont = curvefont
        self._curvewidth = curvewidth
        self._curvecolour = curvecolour
        self._modelordraughting = modelordraughting

    @property
    def curvefont(self):
        return self._curvefont

    @curvefont.setter
    def curvefont(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccurvefontorscaledcurvefontselect):
                self._curvefont = ifccurvefontorscaledcurvefontselect(value)
            else:
                self._curvefont = value
        else:
            self._curvefont = value

    @property
    def curvewidth(self):
        return self._curvewidth

    @curvewidth.setter
    def curvewidth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcsizeselect):
                self._curvewidth = ifcsizeselect(value)
            else:
                self._curvewidth = value
        else:
            self._curvewidth = value

    @property
    def curvecolour(self):
        return self._curvecolour

    @curvecolour.setter
    def curvecolour(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccolour):
                self._curvecolour = ifccolour(value)
            else:
                self._curvecolour = value
        else:
            self._curvecolour = value

    @property
    def modelordraughting(self):
        return self._modelordraughting

    @modelordraughting.setter
    def modelordraughting(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboolean):
                self._modelordraughting = ifcboolean(value)
            else:
                self._modelordraughting = value
        else:
            self._modelordraughting = value

    def measureofwidth(self):
        eval_measureofwidth_wr = (((not EXISTS(self.curvewidth)) or (
                    'IFC4X2.IFCPOSITIVELENGTHMEASURE' == TYPEOF(self.curvewidth))) or (
                                              ('IFC4X2.IFCDESCRIPTIVEMEASURE' == TYPEOF(self.curvewidth)) and (
                                                  self.curvewidth == 'by layer')))
        if not eval_measureofwidth_wr:
            raise AssertionError('Rule measureofwidth violated')
        else:
            return eval_measureofwidth_wr

    def identifiablecurvestyle(self):
        eval_identifiablecurvestyle_wr = (
                    (EXISTS(self.curvefont) or EXISTS(self.curvewidth)) or EXISTS(self.curvecolour))
        if not eval_identifiablecurvestyle_wr:
            raise AssertionError('Rule identifiablecurvestyle violated')
        else:
            return eval_identifiablecurvestyle_wr


####################
# ENTITY ifccshapeprofiledef #
####################
class ifccshapeprofiledef(ifcparameterizedprofiledef):
    '''Entity ifccshapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param width
	:type width:ifcpositivelengthmeasure

	:param wallthickness
	:type wallthickness:ifcpositivelengthmeasure

	:param girth
	:type girth:ifcpositivelengthmeasure

	:param internalfilletradius
	:type internalfilletradius:ifcnonnegativelengthmeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, depth, width,
                 wallthickness, girth, internalfilletradius, ):
        ifcparameterizedprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename,
                                            inherited2__position, )
        self._depth = depth
        self._width = width
        self._wallthickness = wallthickness
        self._girth = girth
        self._internalfilletradius = internalfilletradius

    @property
    def depth(self):
        return self._depth

    @depth.setter
    def depth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._depth = ifcpositivelengthmeasure(value)
        else:
            self._depth = value

    @property
    def width(self):
        return self._width

    @width.setter
    def width(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._width = ifcpositivelengthmeasure(value)
        else:
            self._width = value

    @property
    def wallthickness(self):
        return self._wallthickness

    @wallthickness.setter
    def wallthickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._wallthickness = ifcpositivelengthmeasure(value)
        else:
            self._wallthickness = value

    @property
    def girth(self):
        return self._girth

    @girth.setter
    def girth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._girth = ifcpositivelengthmeasure(value)
        else:
            self._girth = value

    @property
    def internalfilletradius(self):
        return self._internalfilletradius

    @internalfilletradius.setter
    def internalfilletradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._internalfilletradius = ifcnonnegativelengthmeasure(value)
            else:
                self._internalfilletradius = value
        else:
            self._internalfilletradius = value

    def validgirth(self):
        eval_validgirth_wr = (self.girth < (self.depth / 2))
        if not eval_validgirth_wr:
            raise AssertionError('Rule validgirth violated')
        else:
            return eval_validgirth_wr

    def validinternalfilletradius(self):
        eval_validinternalfilletradius_wr = ((not EXISTS(self.internalfilletradius)) or (
                    (self.internalfilletradius <= ((self.width / 2) - self.wallthickness)) and (
                        self.internalfilletradius <= ((self.depth / 2) - self.wallthickness))))
        if not eval_validinternalfilletradius_wr:
            raise AssertionError('Rule validinternalfilletradius violated')
        else:
            return eval_validinternalfilletradius_wr

    def validwallthickness(self):
        eval_validwallthickness_wr = (
                    (self.wallthickness < (self.width / 2)) and (self.wallthickness < (self.depth / 2)))
        if not eval_validwallthickness_wr:
            raise AssertionError('Rule validwallthickness violated')
        else:
            return eval_validwallthickness_wr


####################
# ENTITY ifcwindowstandardcase #
####################
class ifcwindowstandardcase(ifcwindow):
    '''Entity ifcwindowstandardcase definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__overallheight, inherited9__overallwidth, inherited10__predefinedtype,
                 inherited11__partitioningtype, inherited12__userdefinedpartitioningtype, ):
        ifcwindow.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                           inherited6__representation, inherited7__tag, inherited8__overallheight,
                           inherited9__overallwidth, inherited10__predefinedtype, inherited11__partitioningtype,
                           inherited12__userdefinedpartitioningtype, )


####################
# ENTITY ifccartesiantransformationoperator2dnonuniform #
####################
class ifccartesiantransformationoperator2dnonuniform(ifccartesiantransformationoperator2d):
    '''Entity ifccartesiantransformationoperator2dnonuniform definition.

	:param scale2
	:type scale2:ifcreal

	:param scl2
	:type scl2:ifcreal
	'''

    def __init__(self, inherited0__axis1, inherited1__axis2, inherited2__localorigin, inherited3__scale, scale2, ):
        ifccartesiantransformationoperator2d.__init__(self, inherited0__axis1, inherited1__axis2,
                                                      inherited2__localorigin, inherited3__scale, )
        self._scale2 = scale2

    @property
    def scale2(self):
        return self._scale2

    @scale2.setter
    def scale2(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreal):
                self._scale2 = ifcreal(value)
            else:
                self._scale2 = value
        else:
            self._scale2 = value

    @property
    def scl2(self):
        attribute_eval = NVL(self.scale2, self.self.ifccartesiantransformationoperator.self.scl)
        return attribute_eval

    @scl2.setter
    def scl2(self, value):
        # DERIVED argument
        raise AssertionError('Argument scl2 is DERIVED. It is computed and can not be set to any value')

    def scale2greaterzero(self):
        eval_scale2greaterzero_wr = (self.scl2 > 0)
        if not eval_scale2greaterzero_wr:
            raise AssertionError('Rule scale2greaterzero violated')
        else:
            return eval_scale2greaterzero_wr


####################
# ENTITY ifccoolingtower #
####################
class ifccoolingtower(ifcenergyconversiondevice):
    '''Entity ifccoolingtower definition.

	:param predefinedtype
	:type predefinedtype:ifccoolingtowertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccoolingtowertypeenum):
                self._predefinedtype = ifccoolingtowertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifccoolingtowertypeenum.userdefined)) or ((
                                                                                                 self.predefinedtype == ifccoolingtowertypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCOOLINGTOWERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcelementassemblytype #
####################
class ifcelementassemblytype(ifcelementtype):
    '''Entity ifcelementassemblytype definition.

	:param predefinedtype
	:type predefinedtype:ifcelementassemblytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__representationmaps, inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelementassemblytypeenum):
            self._predefinedtype = ifcelementassemblytypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcelementassemblytypeenum.userdefined) or (
                    (self.predefinedtype == ifcelementassemblytypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcextrudedareasolidtapered #
####################
class ifcextrudedareasolidtapered(ifcextrudedareasolid):
    '''Entity ifcextrudedareasolidtapered definition.

	:param endsweptarea
	:type endsweptarea:ifcprofiledef
	'''

    def __init__(self, inherited0__sweptarea, inherited1__position, inherited2__extrudeddirection, inherited3__depth,
                 endsweptarea, ):
        ifcextrudedareasolid.__init__(self, inherited0__sweptarea, inherited1__position, inherited2__extrudeddirection,
                                      inherited3__depth, )
        self._endsweptarea = endsweptarea

    @property
    def endsweptarea(self):
        return self._endsweptarea

    @endsweptarea.setter
    def endsweptarea(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcprofiledef):
            self._endsweptarea = ifcprofiledef(value)
        else:
            self._endsweptarea = value

    def correctprofileassignment(self):
        eval_correctprofileassignment_wr = ifctaperedsweptareaprofiles(self.self.ifcsweptareasolid.self.sweptarea,
                                                                       self.self.endsweptarea)
        if not eval_correctprofileassignment_wr:
            raise AssertionError('Rule correctprofileassignment violated')
        else:
            return eval_correctprofileassignment_wr


####################
# ENTITY ifcorientationexpression #
####################
class ifcorientationexpression(ifcgeometricrepresentationitem):
    '''Entity ifcorientationexpression definition.

	:param lateralaxisdirection
	:type lateralaxisdirection:ifcdirection

	:param verticalaxisdirection
	:type verticalaxisdirection:ifcdirection
	'''

    def __init__(self, lateralaxisdirection, verticalaxisdirection, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._lateralaxisdirection = lateralaxisdirection
        self._verticalaxisdirection = verticalaxisdirection

    @property
    def lateralaxisdirection(self):
        return self._lateralaxisdirection

    @lateralaxisdirection.setter
    def lateralaxisdirection(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdirection):
            self._lateralaxisdirection = ifcdirection(value)
        else:
            self._lateralaxisdirection = value

    @property
    def verticalaxisdirection(self):
        return self._verticalaxisdirection

    @verticalaxisdirection.setter
    def verticalaxisdirection(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdirection):
            self._verticalaxisdirection = ifcdirection(value)
        else:
            self._verticalaxisdirection = value


####################
# ENTITY ifcrooftype #
####################
class ifcrooftype(ifcbuildingelementtype):
    '''Entity ifcrooftype definition.

	:param predefinedtype
	:type predefinedtype:ifcrooftypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcrooftypeenum):
            self._predefinedtype = ifcrooftypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcrooftypeenum.userdefined) or (
                    (self.predefinedtype == ifcrooftypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcalignmentcurve #
####################
class ifcalignmentcurve(ifcboundedcurve):
    '''Entity ifcalignmentcurve definition.

	:param horizontal
	:type horizontal:ifcalignment2dhorizontal

	:param vertical
	:type vertical:ifcalignment2dvertical

	:param tag
	:type tag:ifclabel
	'''

    def __init__(self, horizontal, vertical, tag, ):
        ifcboundedcurve.__init__(self, )
        self._horizontal = horizontal
        self._vertical = vertical
        self._tag = tag

    @property
    def horizontal(self):
        return self._horizontal

    @horizontal.setter
    def horizontal(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcalignment2dhorizontal):
            self._horizontal = ifcalignment2dhorizontal(value)
        else:
            self._horizontal = value

    @property
    def vertical(self):
        return self._vertical

    @vertical.setter
    def vertical(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcalignment2dvertical):
                self._vertical = ifcalignment2dvertical(value)
            else:
                self._vertical = value
        else:
            self._vertical = value

    @property
    def tag(self):
        return self._tag

    @tag.setter
    def tag(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._tag = ifclabel(value)
            else:
                self._tag = value
        else:
            self._tag = value


####################
# ENTITY ifccoolingtowertype #
####################
class ifccoolingtowertype(ifcenergyconversiondevicetype):
    '''Entity ifccoolingtowertype definition.

	:param predefinedtype
	:type predefinedtype:ifccoolingtowertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccoolingtowertypeenum):
            self._predefinedtype = ifccoolingtowertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccoolingtowertypeenum.userdefined) or (
                    (self.predefinedtype == ifccoolingtowertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifccondenser #
####################
class ifccondenser(ifcenergyconversiondevice):
    '''Entity ifccondenser definition.

	:param predefinedtype
	:type predefinedtype:ifccondensertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccondensertypeenum):
                self._predefinedtype = ifccondensertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifccondensertypeenum.userdefined)) or ((
                                                                                              self.predefinedtype == ifccondensertypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCONDENSERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcconstructionequipmentresource #
####################
class ifcconstructionequipmentresource(ifcconstructionresource):
    '''Entity ifcconstructionequipmentresource definition.

	:param predefinedtype
	:type predefinedtype:ifcconstructionequipmentresourcetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, inherited6__longdescription, inherited7__usage,
                 inherited8__basecosts, inherited9__basequantity, predefinedtype, ):
        ifcconstructionresource.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__objecttype, inherited5__identification,
                                         inherited6__longdescription, inherited7__usage, inherited8__basecosts,
                                         inherited9__basequantity, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcconstructionequipmentresourcetypeenum):
                self._predefinedtype = ifcconstructionequipmentresourcetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcconstructionequipmentresourcetypeenum.userdefined)) or ((
                                                                                                                  self.predefinedtype == ifcconstructionequipmentresourcetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcedgeloop #
####################
class ifcedgeloop(ifcloop):
    '''Entity ifcedgeloop definition.

	:param edgelist
	:type edgelist:LIST(1,None,'ifcorientededge', scope = schema_scope)

	:param ne
	:type ne:ifcinteger
	'''

    def __init__(self, edgelist, ):
        ifcloop.__init__(self, )
        self._edgelist = edgelist

    @property
    def edgelist(self):
        return self._edgelist

    @edgelist.setter
    def edgelist(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcorientededge', scope=schema_scope)):
            self._edgelist = LIST(value)
        else:
            self._edgelist = value

    @property
    def ne(self):
        attribute_eval = SIZEOF(self.edgelist)
        return attribute_eval

    @ne.setter
    def ne(self, value):
        # DERIVED argument
        raise AssertionError('Argument ne is DERIVED. It is computed and can not be set to any value')

    def isclosed(self):
        eval_isclosed_wr = (self.edgelist[1].self.edgestart == self.edgelist[self.ne].self.edgeend)
        if not eval_isclosed_wr:
            raise AssertionError('Rule isclosed violated')
        else:
            return eval_isclosed_wr

    def iscontinuous(self):
        eval_iscontinuous_wr = ifcloopheadtotail(self)
        if not eval_iscontinuous_wr:
            raise AssertionError('Rule iscontinuous violated')
        else:
            return eval_iscontinuous_wr


####################
# ENTITY ifcpropertyreferencevalue #
####################
class ifcpropertyreferencevalue(ifcsimpleproperty):
    '''Entity ifcpropertyreferencevalue definition.

	:param usagename
	:type usagename:ifctext

	:param propertyreference
	:type propertyreference:ifcobjectreferenceselect
	'''

    def __init__(self, inherited0__name, inherited1__description, usagename, propertyreference, ):
        ifcsimpleproperty.__init__(self, inherited0__name, inherited1__description, )
        self._usagename = usagename
        self._propertyreference = propertyreference

    @property
    def usagename(self):
        return self._usagename

    @usagename.setter
    def usagename(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._usagename = ifctext(value)
            else:
                self._usagename = value
        else:
            self._usagename = value

    @property
    def propertyreference(self):
        return self._propertyreference

    @propertyreference.setter
    def propertyreference(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcobjectreferenceselect):
                self._propertyreference = ifcobjectreferenceselect(value)
            else:
                self._propertyreference = value
        else:
            self._propertyreference = value


####################
# ENTITY ifcrelassociatesmaterial #
####################
class ifcrelassociatesmaterial(ifcrelassociates):
    '''Entity ifcrelassociatesmaterial definition.

	:param relatingmaterial
	:type relatingmaterial:ifcmaterialselect
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatedobjects, relatingmaterial, ):
        ifcrelassociates.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                  inherited3__description, inherited4__relatedobjects, )
        self._relatingmaterial = relatingmaterial

    @property
    def relatingmaterial(self):
        return self._relatingmaterial

    @relatingmaterial.setter
    def relatingmaterial(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmaterialselect):
            self._relatingmaterial = ifcmaterialselect(value)
        else:
            self._relatingmaterial = value

    def novoidelement(self):
        eval_novoidelement_wr = (SIZEOF(None) == 0)
        if not eval_novoidelement_wr:
            raise AssertionError('Rule novoidelement violated')
        else:
            return eval_novoidelement_wr

    def allowedelements(self):
        eval_allowedelements_wr = (SIZEOF(None) == 0)
        if not eval_allowedelements_wr:
            raise AssertionError('Rule allowedelements violated')
        else:
            return eval_allowedelements_wr


####################
# ENTITY ifcsphericalsurface #
####################
class ifcsphericalsurface(ifcelementarysurface):
    '''Entity ifcsphericalsurface definition.

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''

    def __init__(self, inherited0__position, radius, ):
        ifcelementarysurface.__init__(self, inherited0__position, )
        self._radius = radius

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._radius = ifcpositivelengthmeasure(value)
        else:
            self._radius = value


####################
# ENTITY ifcsurfaceoflinearextrusion #
####################
class ifcsurfaceoflinearextrusion(ifcsweptsurface):
    '''Entity ifcsurfaceoflinearextrusion definition.

	:param extrudeddirection
	:type extrudeddirection:ifcdirection

	:param depth
	:type depth:ifclengthmeasure

	:param extrusionaxis
	:type extrusionaxis:ifcvector
	'''

    def __init__(self, inherited0__sweptcurve, inherited1__position, extrudeddirection, depth, ):
        ifcsweptsurface.__init__(self, inherited0__sweptcurve, inherited1__position, )
        self._extrudeddirection = extrudeddirection
        self._depth = depth

    @property
    def extrudeddirection(self):
        return self._extrudeddirection

    @extrudeddirection.setter
    def extrudeddirection(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdirection):
            self._extrudeddirection = ifcdirection(value)
        else:
            self._extrudeddirection = value

    @property
    def depth(self):
        return self._depth

    @depth.setter
    def depth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._depth = ifclengthmeasure(value)
        else:
            self._depth = value

    @property
    def extrusionaxis(self):
        attribute_eval = (
                    (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcvector(self.extrudeddirection,
                                                                                               self.depth))
        return attribute_eval

    @extrusionaxis.setter
    def extrusionaxis(self, value):
        # DERIVED argument
        raise AssertionError('Argument extrusionaxis is DERIVED. It is computed and can not be set to any value')

    def depthgreaterzero(self):
        eval_depthgreaterzero_wr = (self.depth > 0)
        if not eval_depthgreaterzero_wr:
            raise AssertionError('Rule depthgreaterzero violated')
        else:
            return eval_depthgreaterzero_wr


####################
# ENTITY ifcchillertype #
####################
class ifcchillertype(ifcenergyconversiondevicetype):
    '''Entity ifcchillertype definition.

	:param predefinedtype
	:type predefinedtype:ifcchillertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcchillertypeenum):
            self._predefinedtype = ifcchillertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcchillertypeenum.userdefined) or (
                    (self.predefinedtype == ifcchillertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcenginetype #
####################
class ifcenginetype(ifcenergyconversiondevicetype):
    '''Entity ifcenginetype definition.

	:param predefinedtype
	:type predefinedtype:ifcenginetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcenginetypeenum):
            self._predefinedtype = ifcenginetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcenginetypeenum.userdefined) or (
                    (self.predefinedtype == ifcenginetypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcsurfacestylelighting #
####################
class ifcsurfacestylelighting(ifcpresentationitem):
    '''Entity ifcsurfacestylelighting definition.

	:param diffusetransmissioncolour
	:type diffusetransmissioncolour:ifccolourrgb

	:param diffusereflectioncolour
	:type diffusereflectioncolour:ifccolourrgb

	:param transmissioncolour
	:type transmissioncolour:ifccolourrgb

	:param reflectancecolour
	:type reflectancecolour:ifccolourrgb
	'''

    def __init__(self, diffusetransmissioncolour, diffusereflectioncolour, transmissioncolour, reflectancecolour, ):
        ifcpresentationitem.__init__(self, )
        self._diffusetransmissioncolour = diffusetransmissioncolour
        self._diffusereflectioncolour = diffusereflectioncolour
        self._transmissioncolour = transmissioncolour
        self._reflectancecolour = reflectancecolour

    @property
    def diffusetransmissioncolour(self):
        return self._diffusetransmissioncolour

    @diffusetransmissioncolour.setter
    def diffusetransmissioncolour(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccolourrgb):
            self._diffusetransmissioncolour = ifccolourrgb(value)
        else:
            self._diffusetransmissioncolour = value

    @property
    def diffusereflectioncolour(self):
        return self._diffusereflectioncolour

    @diffusereflectioncolour.setter
    def diffusereflectioncolour(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccolourrgb):
            self._diffusereflectioncolour = ifccolourrgb(value)
        else:
            self._diffusereflectioncolour = value

    @property
    def transmissioncolour(self):
        return self._transmissioncolour

    @transmissioncolour.setter
    def transmissioncolour(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccolourrgb):
            self._transmissioncolour = ifccolourrgb(value)
        else:
            self._transmissioncolour = value

    @property
    def reflectancecolour(self):
        return self._reflectancecolour

    @reflectancecolour.setter
    def reflectancecolour(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccolourrgb):
            self._reflectancecolour = ifccolourrgb(value)
        else:
            self._reflectancecolour = value


####################
# ENTITY ifctextstylefordefinedfont #
####################
class ifctextstylefordefinedfont(ifcpresentationitem):
    '''Entity ifctextstylefordefinedfont definition.

	:param colour
	:type colour:ifccolour

	:param backgroundcolour
	:type backgroundcolour:ifccolour
	'''

    def __init__(self, colour, backgroundcolour, ):
        ifcpresentationitem.__init__(self, )
        self._colour = colour
        self._backgroundcolour = backgroundcolour

    @property
    def colour(self):
        return self._colour

    @colour.setter
    def colour(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccolour):
            self._colour = ifccolour(value)
        else:
            self._colour = value

    @property
    def backgroundcolour(self):
        return self._backgroundcolour

    @backgroundcolour.setter
    def backgroundcolour(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccolour):
                self._backgroundcolour = ifccolour(value)
            else:
                self._backgroundcolour = value
        else:
            self._backgroundcolour = value


####################
# ENTITY ifcsectionedspine #
####################
class ifcsectionedspine(ifcgeometricrepresentationitem):
    '''Entity ifcsectionedspine definition.

	:param spinecurve
	:type spinecurve:ifccompositecurve

	:param crosssections
	:type crosssections:LIST(2,None,'ifcprofiledef', scope = schema_scope)

	:param crosssectionpositions
	:type crosssectionpositions:LIST(2,None,'ifcaxis2placement3d', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, spinecurve, crosssections, crosssectionpositions, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._spinecurve = spinecurve
        self._crosssections = crosssections
        self._crosssectionpositions = crosssectionpositions

    @property
    def spinecurve(self):
        return self._spinecurve

    @spinecurve.setter
    def spinecurve(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccompositecurve):
            self._spinecurve = ifccompositecurve(value)
        else:
            self._spinecurve = value

    @property
    def crosssections(self):
        return self._crosssections

    @crosssections.setter
    def crosssections(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, 'ifcprofiledef', scope=schema_scope)):
            self._crosssections = LIST(value)
        else:
            self._crosssections = value

    @property
    def crosssectionpositions(self):
        return self._crosssectionpositions

    @crosssectionpositions.setter
    def crosssectionpositions(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(2, None, 'ifcaxis2placement3d', scope=schema_scope)):
            self._crosssectionpositions = LIST(value)
        else:
            self._crosssectionpositions = value

    @property
    def dim(self):
        attribute_eval = 3
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')

    def correspondingsectionpositions(self):
        eval_correspondingsectionpositions_wr = (SIZEOF(self.crosssections) == SIZEOF(self.crosssectionpositions))
        if not eval_correspondingsectionpositions_wr:
            raise AssertionError('Rule correspondingsectionpositions violated')
        else:
            return eval_correspondingsectionpositions_wr

    def consistentprofiletypes(self):
        eval_consistentprofiletypes_wr = (SIZEOF(None) == 0)
        if not eval_consistentprofiletypes_wr:
            raise AssertionError('Rule consistentprofiletypes violated')
        else:
            return eval_consistentprofiletypes_wr

    def spinecurvedim(self):
        eval_spinecurvedim_wr = (self.spinecurve.self.dim == 3)
        if not eval_spinecurvedim_wr:
            raise AssertionError('Rule spinecurvedim violated')
        else:
            return eval_spinecurvedim_wr


####################
# ENTITY ifcelectricgenerator #
####################
class ifcelectricgenerator(ifcenergyconversiondevice):
    '''Entity ifcelectricgenerator definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricgeneratortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcelectricgeneratortypeenum):
                self._predefinedtype = ifcelectricgeneratortypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcelectricgeneratortypeenum.userdefined)) or ((
                                                                                                      self.predefinedtype == ifcelectricgeneratortypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCELECTRICGENERATORTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcpointoncurve #
####################
class ifcpointoncurve(ifcpoint):
    '''Entity ifcpointoncurve definition.

	:param basiscurve
	:type basiscurve:ifccurve

	:param pointparameter
	:type pointparameter:ifcparametervalue

	:param dim
	:type dim:ifcdimensioncount
	'''

    def __init__(self, basiscurve, pointparameter, ):
        ifcpoint.__init__(self, )
        self._basiscurve = basiscurve
        self._pointparameter = pointparameter

    @property
    def basiscurve(self):
        return self._basiscurve

    @basiscurve.setter
    def basiscurve(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._basiscurve = ifccurve(value)
        else:
            self._basiscurve = value

    @property
    def pointparameter(self):
        return self._pointparameter

    @pointparameter.setter
    def pointparameter(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcparametervalue):
            self._pointparameter = ifcparametervalue(value)
        else:
            self._pointparameter = value

    @property
    def dim(self):
        attribute_eval = self.basiscurve.self.dim
        return attribute_eval

    @dim.setter
    def dim(self, value):
        # DERIVED argument
        raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')


####################
# ENTITY ifcprojectorder #
####################
class ifcprojectorder(ifccontrol):
    '''Entity ifcprojectorder definition.

	:param predefinedtype
	:type predefinedtype:ifcprojectordertypeenum

	:param status
	:type status:ifclabel

	:param longdescription
	:type longdescription:ifctext
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, predefinedtype, status, longdescription, ):
        ifccontrol.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__identification, )
        self._predefinedtype = predefinedtype
        self._status = status
        self._longdescription = longdescription

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcprojectordertypeenum):
                self._predefinedtype = ifcprojectordertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def status(self):
        return self._status

    @status.setter
    def status(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._status = ifclabel(value)
            else:
                self._status = value
        else:
            self._status = value

    @property
    def longdescription(self):
        return self._longdescription

    @longdescription.setter
    def longdescription(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctext):
                self._longdescription = ifctext(value)
            else:
                self._longdescription = value
        else:
            self._longdescription = value


####################
# ENTITY ifcrelfillselement #
####################
class ifcrelfillselement(ifcrelconnects):
    '''Entity ifcrelfillselement definition.

	:param relatingopeningelement
	:type relatingopeningelement:ifcopeningelement

	:param relatedbuildingelement
	:type relatedbuildingelement:ifcelement
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingopeningelement, relatedbuildingelement, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatingopeningelement = relatingopeningelement
        self._relatedbuildingelement = relatedbuildingelement

    @property
    def relatingopeningelement(self):
        return self._relatingopeningelement

    @relatingopeningelement.setter
    def relatingopeningelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcopeningelement):
            self._relatingopeningelement = ifcopeningelement(value)
        else:
            self._relatingopeningelement = value

    @property
    def relatedbuildingelement(self):
        return self._relatedbuildingelement

    @relatedbuildingelement.setter
    def relatedbuildingelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelement):
            self._relatedbuildingelement = ifcelement(value)
        else:
            self._relatedbuildingelement = value


####################
# ENTITY ifcrelinterfereselements #
####################
class ifcrelinterfereselements(ifcrelconnects):
    '''Entity ifcrelinterfereselements definition.

	:param relatingelement
	:type relatingelement:ifcelement

	:param relatedelement
	:type relatedelement:ifcelement

	:param interferencegeometry
	:type interferencegeometry:ifcconnectiongeometry

	:param interferencetype
	:type interferencetype:ifcidentifier

	:param impliedorder
	:type impliedorder:Logical
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingelement, relatedelement, interferencegeometry, interferencetype, impliedorder, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatingelement = relatingelement
        self._relatedelement = relatedelement
        self._interferencegeometry = interferencegeometry
        self._interferencetype = interferencetype
        self._impliedorder = impliedorder

    @property
    def relatingelement(self):
        return self._relatingelement

    @relatingelement.setter
    def relatingelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelement):
            self._relatingelement = ifcelement(value)
        else:
            self._relatingelement = value

    @property
    def relatedelement(self):
        return self._relatedelement

    @relatedelement.setter
    def relatedelement(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelement):
            self._relatedelement = ifcelement(value)
        else:
            self._relatedelement = value

    @property
    def interferencegeometry(self):
        return self._interferencegeometry

    @interferencegeometry.setter
    def interferencegeometry(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcconnectiongeometry):
                self._interferencegeometry = ifcconnectiongeometry(value)
            else:
                self._interferencegeometry = value
        else:
            self._interferencegeometry = value

    @property
    def interferencetype(self):
        return self._interferencetype

    @interferencetype.setter
    def interferencetype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcidentifier):
                self._interferencetype = ifcidentifier(value)
            else:
                self._interferencetype = value
        else:
            self._interferencetype = value

    @property
    def impliedorder(self):
        return self._impliedorder

    @impliedorder.setter
    def impliedorder(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, Logical):
            self._impliedorder = Logical(value)
        else:
            self._impliedorder = value

    def noselfreference(self):
        eval_noselfreference_wr = (self.relatingelement != self.relatedelement)
        if not eval_noselfreference_wr:
            raise AssertionError('Rule noselfreference violated')
        else:
            return eval_noselfreference_wr


####################
# ENTITY ifctransportelementtype #
####################
class ifctransportelementtype(ifcelementtype):
    '''Entity ifctransportelementtype definition.

	:param predefinedtype
	:type predefinedtype:ifctransportelementtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, inherited4__applicableoccurrence, inherited5__haspropertysets,
                                inherited6__representationmaps, inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifctransportelementtypeenum):
            self._predefinedtype = ifctransportelementtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifctransportelementtypeenum.userdefined) or (
                    (self.predefinedtype == ifctransportelementtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcbeamtype #
####################
class ifcbeamtype(ifcbuildingelementtype):
    '''Entity ifcbeamtype definition.

	:param predefinedtype
	:type predefinedtype:ifcbeamtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcbeamtypeenum):
            self._predefinedtype = ifcbeamtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcbeamtypeenum.userdefined) or (
                    (self.predefinedtype == ifcbeamtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifccivilelement #
####################
class ifccivilelement(ifcelement):
    '''Entity ifccivilelement definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag, ):
        ifcelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, inherited7__tag, )


####################
# ENTITY ifcboiler #
####################
class ifcboiler(ifcenergyconversiondevice):
    '''Entity ifcboiler definition.

	:param predefinedtype
	:type predefinedtype:ifcboilertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcboilertypeenum):
                self._predefinedtype = ifcboilertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcboilertypeenum.userdefined)) or (
                        (self.predefinedtype == ifcboilertypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCBOILERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcalignment2dversegparabolicarc #
####################
class ifcalignment2dversegparabolicarc(ifcalignment2dverticalsegment):
    '''Entity ifcalignment2dversegparabolicarc definition.

	:param parabolaconstant
	:type parabolaconstant:ifcpositivelengthmeasure

	:param isconvex
	:type isconvex:ifcboolean
	'''

    def __init__(self, inherited0__tangentialcontinuity, inherited1__starttag, inherited2__endtag,
                 inherited3__startdistalong, inherited4__horizontallength, inherited5__startheight,
                 inherited6__startgradient, parabolaconstant, isconvex, ):
        ifcalignment2dverticalsegment.__init__(self, inherited0__tangentialcontinuity, inherited1__starttag,
                                               inherited2__endtag, inherited3__startdistalong,
                                               inherited4__horizontallength, inherited5__startheight,
                                               inherited6__startgradient, )
        self._parabolaconstant = parabolaconstant
        self._isconvex = isconvex

    @property
    def parabolaconstant(self):
        return self._parabolaconstant

    @parabolaconstant.setter
    def parabolaconstant(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._parabolaconstant = ifcpositivelengthmeasure(value)
        else:
            self._parabolaconstant = value

    @property
    def isconvex(self):
        return self._isconvex

    @isconvex.setter
    def isconvex(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._isconvex = ifcboolean(value)
        else:
            self._isconvex = value


####################
# ENTITY ifcgeographicelement #
####################
class ifcgeographicelement(ifcelement):
    '''Entity ifcgeographicelement definition.

	:param predefinedtype
	:type predefinedtype:ifcgeographicelementtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                            inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                            inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcgeographicelementtypeenum):
                self._predefinedtype = ifcgeographicelementtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcgeographicelementtypeenum.userdefined)) or ((
                                                                                                      self.predefinedtype == ifcgeographicelementtypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCGEOGRAPHICELEMENTTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcindexedpolygonalfacewithvoids #
####################
class ifcindexedpolygonalfacewithvoids(ifcindexedpolygonalface):
    '''Entity ifcindexedpolygonalfacewithvoids definition.

	:param innercoordindices
	:type innercoordindices:LIST(1,None,LIST(3,None,'INTEGER', scope = schema_scope))
	'''

    def __init__(self, inherited0__coordindex, innercoordindices, ):
        ifcindexedpolygonalface.__init__(self, inherited0__coordindex, )
        self._innercoordindices = innercoordindices

    @property
    def innercoordindices(self):
        return self._innercoordindices

    @innercoordindices.setter
    def innercoordindices(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, LIST(3, None, 'INTEGER', scope=schema_scope))):
            self._innercoordindices = LIST(value)
        else:
            self._innercoordindices = value


####################
# ENTITY ifcalignment2dhorizontal #
####################
class ifcalignment2dhorizontal(ifcgeometricrepresentationitem):
    '''Entity ifcalignment2dhorizontal definition.

	:param startdistalong
	:type startdistalong:ifclengthmeasure

	:param segments
	:type segments:LIST(1,None,'ifcalignment2dhorizontalsegment', scope = schema_scope)

	:param toalignmentcurve
	:type toalignmentcurve:SET(1,None,'ifcalignmentcurve', scope = schema_scope)
	'''

    def __init__(self, startdistalong, segments, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._startdistalong = startdistalong
        self._segments = segments

    @property
    def startdistalong(self):
        return self._startdistalong

    @startdistalong.setter
    def startdistalong(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._startdistalong = ifclengthmeasure(value)
            else:
                self._startdistalong = value
        else:
            self._startdistalong = value

    @property
    def segments(self):
        return self._segments

    @segments.setter
    def segments(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcalignment2dhorizontalsegment', scope=schema_scope)):
            self._segments = LIST(value)
        else:
            self._segments = value

    @property
    def toalignmentcurve(self):
        return self._toalignmentcurve

    @toalignmentcurve.setter
    def toalignmentcurve(self, value):
        # INVERSE argument
        raise AssertionError('Argument toalignmentcurve is INVERSE. It is computed and can not be set to any value')


####################
# ENTITY ifcaxis2placement3d #
####################
class ifcaxis2placement3d(ifcplacement):
    '''Entity ifcaxis2placement3d definition.

	:param axis
	:type axis:ifcdirection

	:param refdirection
	:type refdirection:ifcdirection

	:param p
	:type p:LIST(3,3,'ifcdirection', scope = schema_scope)
	'''

    def __init__(self, inherited0__location, axis, refdirection, ):
        ifcplacement.__init__(self, inherited0__location, )
        self._axis = axis
        self._refdirection = refdirection

    @property
    def axis(self):
        return self._axis

    @axis.setter
    def axis(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdirection):
                self._axis = ifcdirection(value)
            else:
                self._axis = value
        else:
            self._axis = value

    @property
    def refdirection(self):
        return self._refdirection

    @refdirection.setter
    def refdirection(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdirection):
                self._refdirection = ifcdirection(value)
            else:
                self._refdirection = value
        else:
            self._refdirection = value

    @property
    def p(self):
        attribute_eval = ifcbuildaxes(self.axis, self.refdirection)
        return attribute_eval

    @p.setter
    def p(self, value):
        # DERIVED argument
        raise AssertionError('Argument p is DERIVED. It is computed and can not be set to any value')

    def locationis3d(self):
        eval_locationis3d_wr = (self.self.ifcplacement.self.location.self.dim == 3)
        if not eval_locationis3d_wr:
            raise AssertionError('Rule locationis3d violated')
        else:
            return eval_locationis3d_wr

    def axisis3d(self):
        eval_axisis3d_wr = ((not EXISTS(self.axis)) or (self.axis.self.dim == 3))
        if not eval_axisis3d_wr:
            raise AssertionError('Rule axisis3d violated')
        else:
            return eval_axisis3d_wr

    def refdiris3d(self):
        eval_refdiris3d_wr = ((not EXISTS(self.refdirection)) or (self.refdirection.self.dim == 3))
        if not eval_refdiris3d_wr:
            raise AssertionError('Rule refdiris3d violated')
        else:
            return eval_refdiris3d_wr

    def axistorefdirposition(self):
        eval_axistorefdirposition_wr = (((not EXISTS(self.axis)) or (not EXISTS(self.refdirection))) or (
                    ifccrossproduct(self.axis, self.refdirection).self.magnitude > 0))
        if not eval_axistorefdirposition_wr:
            raise AssertionError('Rule axistorefdirposition violated')
        else:
            return eval_axistorefdirposition_wr

    def axisandrefdirprovision(self):
        eval_axisandrefdirprovision_wr = (not (EXISTS(self.axis) != EXISTS(self.refdirection)))
        if not eval_axisandrefdirprovision_wr:
            raise AssertionError('Rule axisandrefdirprovision violated')
        else:
            return eval_axisandrefdirprovision_wr


####################
# ENTITY ifcirregulartimeseries #
####################
class ifcirregulartimeseries(ifctimeseries):
    '''Entity ifcirregulartimeseries definition.

	:param values
	:type values:LIST(1,None,'ifcirregulartimeseriesvalue', scope = schema_scope)
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__starttime, inherited3__endtime,
                 inherited4__timeseriesdatatype, inherited5__dataorigin, inherited6__userdefineddataorigin,
                 inherited7__unit, values, ):
        ifctimeseries.__init__(self, inherited0__name, inherited1__description, inherited2__starttime,
                               inherited3__endtime, inherited4__timeseriesdatatype, inherited5__dataorigin,
                               inherited6__userdefineddataorigin, inherited7__unit, )
        self._values = values

    @property
    def values(self):
        return self._values

    @values.setter
    def values(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcirregulartimeseriesvalue', scope=schema_scope)):
            self._values = LIST(value)
        else:
            self._values = value


####################
# ENTITY ifcfailureconnectioncondition #
####################
class ifcfailureconnectioncondition(ifcstructuralconnectioncondition):
    '''Entity ifcfailureconnectioncondition definition.

	:param tensionfailurex
	:type tensionfailurex:ifcforcemeasure

	:param tensionfailurey
	:type tensionfailurey:ifcforcemeasure

	:param tensionfailurez
	:type tensionfailurez:ifcforcemeasure

	:param compressionfailurex
	:type compressionfailurex:ifcforcemeasure

	:param compressionfailurey
	:type compressionfailurey:ifcforcemeasure

	:param compressionfailurez
	:type compressionfailurez:ifcforcemeasure
	'''

    def __init__(self, inherited0__name, tensionfailurex, tensionfailurey, tensionfailurez, compressionfailurex,
                 compressionfailurey, compressionfailurez, ):
        ifcstructuralconnectioncondition.__init__(self, inherited0__name, )
        self._tensionfailurex = tensionfailurex
        self._tensionfailurey = tensionfailurey
        self._tensionfailurez = tensionfailurez
        self._compressionfailurex = compressionfailurex
        self._compressionfailurey = compressionfailurey
        self._compressionfailurez = compressionfailurez

    @property
    def tensionfailurex(self):
        return self._tensionfailurex

    @tensionfailurex.setter
    def tensionfailurex(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcforcemeasure):
                self._tensionfailurex = ifcforcemeasure(value)
            else:
                self._tensionfailurex = value
        else:
            self._tensionfailurex = value

    @property
    def tensionfailurey(self):
        return self._tensionfailurey

    @tensionfailurey.setter
    def tensionfailurey(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcforcemeasure):
                self._tensionfailurey = ifcforcemeasure(value)
            else:
                self._tensionfailurey = value
        else:
            self._tensionfailurey = value

    @property
    def tensionfailurez(self):
        return self._tensionfailurez

    @tensionfailurez.setter
    def tensionfailurez(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcforcemeasure):
                self._tensionfailurez = ifcforcemeasure(value)
            else:
                self._tensionfailurez = value
        else:
            self._tensionfailurez = value

    @property
    def compressionfailurex(self):
        return self._compressionfailurex

    @compressionfailurex.setter
    def compressionfailurex(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcforcemeasure):
                self._compressionfailurex = ifcforcemeasure(value)
            else:
                self._compressionfailurex = value
        else:
            self._compressionfailurex = value

    @property
    def compressionfailurey(self):
        return self._compressionfailurey

    @compressionfailurey.setter
    def compressionfailurey(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcforcemeasure):
                self._compressionfailurey = ifcforcemeasure(value)
            else:
                self._compressionfailurey = value
        else:
            self._compressionfailurey = value

    @property
    def compressionfailurez(self):
        return self._compressionfailurez

    @compressionfailurez.setter
    def compressionfailurez(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcforcemeasure):
                self._compressionfailurez = ifcforcemeasure(value)
            else:
                self._compressionfailurez = value
        else:
            self._compressionfailurez = value


####################
# ENTITY ifcconversionbasedunitwithoffset #
####################
class ifcconversionbasedunitwithoffset(ifcconversionbasedunit):
    '''Entity ifcconversionbasedunitwithoffset definition.

	:param conversionoffset
	:type conversionoffset:ifcreal
	'''

    def __init__(self, inherited0__dimensions, inherited1__unittype, inherited2__name, inherited3__conversionfactor,
                 conversionoffset, ):
        ifcconversionbasedunit.__init__(self, inherited0__dimensions, inherited1__unittype, inherited2__name,
                                        inherited3__conversionfactor, )
        self._conversionoffset = conversionoffset

    @property
    def conversionoffset(self):
        return self._conversionoffset

    @conversionoffset.setter
    def conversionoffset(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcreal):
            self._conversionoffset = ifcreal(value)
        else:
            self._conversionoffset = value


####################
# ENTITY ifcsectionreinforcementproperties #
####################
class ifcsectionreinforcementproperties(ifcpredefinedproperties):
    '''Entity ifcsectionreinforcementproperties definition.

	:param longitudinalstartposition
	:type longitudinalstartposition:ifclengthmeasure

	:param longitudinalendposition
	:type longitudinalendposition:ifclengthmeasure

	:param transverseposition
	:type transverseposition:ifclengthmeasure

	:param reinforcementrole
	:type reinforcementrole:ifcreinforcingbarroleenum

	:param sectiondefinition
	:type sectiondefinition:ifcsectionproperties

	:param crosssectionreinforcementdefinitions
	:type crosssectionreinforcementdefinitions:SET(1,None,'ifcreinforcementbarproperties', scope = schema_scope)
	'''

    def __init__(self, longitudinalstartposition, longitudinalendposition, transverseposition, reinforcementrole,
                 sectiondefinition, crosssectionreinforcementdefinitions, ):
        ifcpredefinedproperties.__init__(self, )
        self._longitudinalstartposition = longitudinalstartposition
        self._longitudinalendposition = longitudinalendposition
        self._transverseposition = transverseposition
        self._reinforcementrole = reinforcementrole
        self._sectiondefinition = sectiondefinition
        self._crosssectionreinforcementdefinitions = crosssectionreinforcementdefinitions

    @property
    def longitudinalstartposition(self):
        return self._longitudinalstartposition

    @longitudinalstartposition.setter
    def longitudinalstartposition(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._longitudinalstartposition = ifclengthmeasure(value)
        else:
            self._longitudinalstartposition = value

    @property
    def longitudinalendposition(self):
        return self._longitudinalendposition

    @longitudinalendposition.setter
    def longitudinalendposition(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclengthmeasure):
            self._longitudinalendposition = ifclengthmeasure(value)
        else:
            self._longitudinalendposition = value

    @property
    def transverseposition(self):
        return self._transverseposition

    @transverseposition.setter
    def transverseposition(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._transverseposition = ifclengthmeasure(value)
            else:
                self._transverseposition = value
        else:
            self._transverseposition = value

    @property
    def reinforcementrole(self):
        return self._reinforcementrole

    @reinforcementrole.setter
    def reinforcementrole(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcreinforcingbarroleenum):
            self._reinforcementrole = ifcreinforcingbarroleenum(value)
        else:
            self._reinforcementrole = value

    @property
    def sectiondefinition(self):
        return self._sectiondefinition

    @sectiondefinition.setter
    def sectiondefinition(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsectionproperties):
            self._sectiondefinition = ifcsectionproperties(value)
        else:
            self._sectiondefinition = value

    @property
    def crosssectionreinforcementdefinitions(self):
        return self._crosssectionreinforcementdefinitions

    @crosssectionreinforcementdefinitions.setter
    def crosssectionreinforcementdefinitions(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcreinforcementbarproperties', scope=schema_scope)):
            self._crosssectionreinforcementdefinitions = SET(value)
        else:
            self._crosssectionreinforcementdefinitions = value


####################
# ENTITY ifcsurfacereinforcementarea #
####################
class ifcsurfacereinforcementarea(ifcstructuralloadorresult):
    '''Entity ifcsurfacereinforcementarea definition.

	:param surfacereinforcement1
	:type surfacereinforcement1:LIST(2,3,'REAL', scope = schema_scope)

	:param surfacereinforcement2
	:type surfacereinforcement2:LIST(2,3,'REAL', scope = schema_scope)

	:param shearreinforcement
	:type shearreinforcement:ifcratiomeasure
	'''

    def __init__(self, inherited0__name, surfacereinforcement1, surfacereinforcement2, shearreinforcement, ):
        ifcstructuralloadorresult.__init__(self, inherited0__name, )
        self._surfacereinforcement1 = surfacereinforcement1
        self._surfacereinforcement2 = surfacereinforcement2
        self._shearreinforcement = shearreinforcement

    @property
    def surfacereinforcement1(self):
        return self._surfacereinforcement1

    @surfacereinforcement1.setter
    def surfacereinforcement1(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(2, 3, 'REAL', scope=schema_scope)):
                self._surfacereinforcement1 = LIST(value)
            else:
                self._surfacereinforcement1 = value
        else:
            self._surfacereinforcement1 = value

    @property
    def surfacereinforcement2(self):
        return self._surfacereinforcement2

    @surfacereinforcement2.setter
    def surfacereinforcement2(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(2, 3, 'REAL', scope=schema_scope)):
                self._surfacereinforcement2 = LIST(value)
            else:
                self._surfacereinforcement2 = value
        else:
            self._surfacereinforcement2 = value

    @property
    def shearreinforcement(self):
        return self._shearreinforcement

    @shearreinforcement.setter
    def shearreinforcement(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcratiomeasure):
                self._shearreinforcement = ifcratiomeasure(value)
            else:
                self._shearreinforcement = value
        else:
            self._shearreinforcement = value

    def surfaceandorshearareaspecified(self):
        eval_surfaceandorshearareaspecified_wr = (
                    (EXISTS(self.surfacereinforcement1) or EXISTS(self.surfacereinforcement2)) or EXISTS(
                self.shearreinforcement))
        if not eval_surfaceandorshearareaspecified_wr:
            raise AssertionError('Rule surfaceandorshearareaspecified violated')
        else:
            return eval_surfaceandorshearareaspecified_wr

    def nonnegativearea1(self):
        eval_nonnegativearea1_wr = ((not EXISTS(self.surfacereinforcement1)) or (
                    ((self.surfacereinforcement1[1] >= 0) and (self.surfacereinforcement1[2] >= 0)) and (
                        (SIZEOF(self.surfacereinforcement1) == 1) or (self.surfacereinforcement1[1] >= 0))))
        if not eval_nonnegativearea1_wr:
            raise AssertionError('Rule nonnegativearea1 violated')
        else:
            return eval_nonnegativearea1_wr

    def nonnegativearea2(self):
        eval_nonnegativearea2_wr = ((not EXISTS(self.surfacereinforcement2)) or (
                    ((self.surfacereinforcement2[1] >= 0) and (self.surfacereinforcement2[2] >= 0)) and (
                        (SIZEOF(self.surfacereinforcement2) == 1) or (self.surfacereinforcement2[1] >= 0))))
        if not eval_nonnegativearea2_wr:
            raise AssertionError('Rule nonnegativearea2 violated')
        else:
            return eval_nonnegativearea2_wr

    def nonnegativearea3(self):
        eval_nonnegativearea3_wr = ((not EXISTS(self.shearreinforcement)) or (self.shearreinforcement >= 0))
        if not eval_nonnegativearea3_wr:
            raise AssertionError('Rule nonnegativearea3 violated')
        else:
            return eval_nonnegativearea3_wr


####################
# ENTITY ifcvibrationdampertype #
####################
class ifcvibrationdampertype(ifcelementcomponenttype):
    '''Entity ifcvibrationdampertype definition.

	:param predefinedtype
	:type predefinedtype:ifcvibrationdampertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcelementcomponenttype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__applicableoccurrence,
                                         inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                         inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcvibrationdampertypeenum):
                self._predefinedtype = ifcvibrationdampertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcvibrationdampertypeenum.userdefined) or (
                    (self.predefinedtype == ifcvibrationdampertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcasymmetricishapeprofiledef #
####################
class ifcasymmetricishapeprofiledef(ifcparameterizedprofiledef):
    '''Entity ifcasymmetricishapeprofiledef definition.

	:param bottomflangewidth
	:type bottomflangewidth:ifcpositivelengthmeasure

	:param overalldepth
	:type overalldepth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param bottomflangethickness
	:type bottomflangethickness:ifcpositivelengthmeasure

	:param bottomflangefilletradius
	:type bottomflangefilletradius:ifcnonnegativelengthmeasure

	:param topflangewidth
	:type topflangewidth:ifcpositivelengthmeasure

	:param topflangethickness
	:type topflangethickness:ifcpositivelengthmeasure

	:param topflangefilletradius
	:type topflangefilletradius:ifcnonnegativelengthmeasure

	:param bottomflangeedgeradius
	:type bottomflangeedgeradius:ifcnonnegativelengthmeasure

	:param bottomflangeslope
	:type bottomflangeslope:ifcplaneanglemeasure

	:param topflangeedgeradius
	:type topflangeedgeradius:ifcnonnegativelengthmeasure

	:param topflangeslope
	:type topflangeslope:ifcplaneanglemeasure
	'''

    def __init__(self, inherited0__profiletype, inherited1__profilename, inherited2__position, bottomflangewidth,
                 overalldepth, webthickness, bottomflangethickness, bottomflangefilletradius, topflangewidth,
                 topflangethickness, topflangefilletradius, bottomflangeedgeradius, bottomflangeslope,
                 topflangeedgeradius, topflangeslope, ):
        ifcparameterizedprofiledef.__init__(self, inherited0__profiletype, inherited1__profilename,
                                            inherited2__position, )
        self._bottomflangewidth = bottomflangewidth
        self._overalldepth = overalldepth
        self._webthickness = webthickness
        self._bottomflangethickness = bottomflangethickness
        self._bottomflangefilletradius = bottomflangefilletradius
        self._topflangewidth = topflangewidth
        self._topflangethickness = topflangethickness
        self._topflangefilletradius = topflangefilletradius
        self._bottomflangeedgeradius = bottomflangeedgeradius
        self._bottomflangeslope = bottomflangeslope
        self._topflangeedgeradius = topflangeedgeradius
        self._topflangeslope = topflangeslope

    @property
    def bottomflangewidth(self):
        return self._bottomflangewidth

    @bottomflangewidth.setter
    def bottomflangewidth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._bottomflangewidth = ifcpositivelengthmeasure(value)
        else:
            self._bottomflangewidth = value

    @property
    def overalldepth(self):
        return self._overalldepth

    @overalldepth.setter
    def overalldepth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._overalldepth = ifcpositivelengthmeasure(value)
        else:
            self._overalldepth = value

    @property
    def webthickness(self):
        return self._webthickness

    @webthickness.setter
    def webthickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._webthickness = ifcpositivelengthmeasure(value)
        else:
            self._webthickness = value

    @property
    def bottomflangethickness(self):
        return self._bottomflangethickness

    @bottomflangethickness.setter
    def bottomflangethickness(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._bottomflangethickness = ifcpositivelengthmeasure(value)
        else:
            self._bottomflangethickness = value

    @property
    def bottomflangefilletradius(self):
        return self._bottomflangefilletradius

    @bottomflangefilletradius.setter
    def bottomflangefilletradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._bottomflangefilletradius = ifcnonnegativelengthmeasure(value)
            else:
                self._bottomflangefilletradius = value
        else:
            self._bottomflangefilletradius = value

    @property
    def topflangewidth(self):
        return self._topflangewidth

    @topflangewidth.setter
    def topflangewidth(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpositivelengthmeasure):
            self._topflangewidth = ifcpositivelengthmeasure(value)
        else:
            self._topflangewidth = value

    @property
    def topflangethickness(self):
        return self._topflangethickness

    @topflangethickness.setter
    def topflangethickness(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._topflangethickness = ifcpositivelengthmeasure(value)
            else:
                self._topflangethickness = value
        else:
            self._topflangethickness = value

    @property
    def topflangefilletradius(self):
        return self._topflangefilletradius

    @topflangefilletradius.setter
    def topflangefilletradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._topflangefilletradius = ifcnonnegativelengthmeasure(value)
            else:
                self._topflangefilletradius = value
        else:
            self._topflangefilletradius = value

    @property
    def bottomflangeedgeradius(self):
        return self._bottomflangeedgeradius

    @bottomflangeedgeradius.setter
    def bottomflangeedgeradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._bottomflangeedgeradius = ifcnonnegativelengthmeasure(value)
            else:
                self._bottomflangeedgeradius = value
        else:
            self._bottomflangeedgeradius = value

    @property
    def bottomflangeslope(self):
        return self._bottomflangeslope

    @bottomflangeslope.setter
    def bottomflangeslope(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplaneanglemeasure):
                self._bottomflangeslope = ifcplaneanglemeasure(value)
            else:
                self._bottomflangeslope = value
        else:
            self._bottomflangeslope = value

    @property
    def topflangeedgeradius(self):
        return self._topflangeedgeradius

    @topflangeedgeradius.setter
    def topflangeedgeradius(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcnonnegativelengthmeasure):
                self._topflangeedgeradius = ifcnonnegativelengthmeasure(value)
            else:
                self._topflangeedgeradius = value
        else:
            self._topflangeedgeradius = value

    @property
    def topflangeslope(self):
        return self._topflangeslope

    @topflangeslope.setter
    def topflangeslope(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcplaneanglemeasure):
                self._topflangeslope = ifcplaneanglemeasure(value)
            else:
                self._topflangeslope = value
        else:
            self._topflangeslope = value

    def validflangethickness(self):
        eval_validflangethickness_wr = ((not EXISTS(self.topflangethickness)) or (
                    (self.bottomflangethickness + self.topflangethickness) < self.overalldepth))
        if not eval_validflangethickness_wr:
            raise AssertionError('Rule validflangethickness violated')
        else:
            return eval_validflangethickness_wr

    def validwebthickness(self):
        eval_validwebthickness_wr = (
                    (self.webthickness < self.bottomflangewidth) and (self.webthickness < self.topflangewidth))
        if not eval_validwebthickness_wr:
            raise AssertionError('Rule validwebthickness violated')
        else:
            return eval_validwebthickness_wr

    def validbottomfilletradius(self):
        eval_validbottomfilletradius_wr = ((not EXISTS(self.bottomflangefilletradius)) or (
                    self.bottomflangefilletradius <= ((self.bottomflangewidth - self.webthickness) / 2)))
        if not eval_validbottomfilletradius_wr:
            raise AssertionError('Rule validbottomfilletradius violated')
        else:
            return eval_validbottomfilletradius_wr

    def validtopfilletradius(self):
        eval_validtopfilletradius_wr = ((not EXISTS(self.topflangefilletradius)) or (
                    self.topflangefilletradius <= ((self.topflangewidth - self.webthickness) / 2)))
        if not eval_validtopfilletradius_wr:
            raise AssertionError('Rule validtopfilletradius violated')
        else:
            return eval_validtopfilletradius_wr


####################
# ENTITY ifcpiletype #
####################
class ifcpiletype(ifcdeepfoundationtype):
    '''Entity ifcpiletype definition.

	:param predefinedtype
	:type predefinedtype:ifcpiletypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcdeepfoundationtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__applicableoccurrence,
                                       inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                       inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcpiletypeenum):
            self._predefinedtype = ifcpiletypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcpiletypeenum.userdefined) or (
                    (self.predefinedtype == ifcpiletypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcreparametrisedcompositecurvesegment #
####################
class ifcreparametrisedcompositecurvesegment(ifccompositecurvesegment):
    '''Entity ifcreparametrisedcompositecurvesegment definition.

	:param paramlength
	:type paramlength:ifcparametervalue
	'''

    def __init__(self, inherited0__transition, inherited1__samesense, inherited2__parentcurve, paramlength, ):
        ifccompositecurvesegment.__init__(self, inherited0__transition, inherited1__samesense,
                                          inherited2__parentcurve, )
        self._paramlength = paramlength

    @property
    def paramlength(self):
        return self._paramlength

    @paramlength.setter
    def paramlength(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcparametervalue):
            self._paramlength = ifcparametervalue(value)
        else:
            self._paramlength = value

    def positivelengthparameter(self):
        eval_positivelengthparameter_wr = (self.paramlength > 0)
        if not eval_positivelengthparameter_wr:
            raise AssertionError('Rule positivelengthparameter violated')
        else:
            return eval_positivelengthparameter_wr


####################
# ENTITY ifcvibrationisolatortype #
####################
class ifcvibrationisolatortype(ifcelementcomponenttype):
    '''Entity ifcvibrationisolatortype definition.

	:param predefinedtype
	:type predefinedtype:ifcvibrationisolatortypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcelementcomponenttype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__applicableoccurrence,
                                         inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                         inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcvibrationisolatortypeenum):
            self._predefinedtype = ifcvibrationisolatortypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcvibrationisolatortypeenum.userdefined) or (
                    (self.predefinedtype == ifcvibrationisolatortypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifclinearplacement #
####################
class ifclinearplacement(ifcobjectplacement):
    '''Entity ifclinearplacement definition.

	:param placementmeasuredalong
	:type placementmeasuredalong:ifccurve

	:param distance
	:type distance:ifcdistanceexpression

	:param orientation
	:type orientation:ifcorientationexpression

	:param cartesianposition
	:type cartesianposition:ifcaxis2placement3d
	'''

    def __init__(self, inherited0__placementrelto, placementmeasuredalong, distance, orientation, cartesianposition, ):
        ifcobjectplacement.__init__(self, inherited0__placementrelto, )
        self._placementmeasuredalong = placementmeasuredalong
        self._distance = distance
        self._orientation = orientation
        self._cartesianposition = cartesianposition

    @property
    def placementmeasuredalong(self):
        return self._placementmeasuredalong

    @placementmeasuredalong.setter
    def placementmeasuredalong(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._placementmeasuredalong = ifccurve(value)
        else:
            self._placementmeasuredalong = value

    @property
    def distance(self):
        return self._distance

    @distance.setter
    def distance(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdistanceexpression):
            self._distance = ifcdistanceexpression(value)
        else:
            self._distance = value

    @property
    def orientation(self):
        return self._orientation

    @orientation.setter
    def orientation(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcorientationexpression):
                self._orientation = ifcorientationexpression(value)
            else:
                self._orientation = value
        else:
            self._orientation = value

    @property
    def cartesianposition(self):
        return self._cartesianposition

    @cartesianposition.setter
    def cartesianposition(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcaxis2placement3d):
                self._cartesianposition = ifcaxis2placement3d(value)
            else:
                self._cartesianposition = value
        else:
            self._cartesianposition = value


####################
# ENTITY ifctriangulatedirregularnetwork #
####################
class ifctriangulatedirregularnetwork(ifctriangulatedfaceset):
    '''Entity ifctriangulatedirregularnetwork definition.

	:param flags
	:type flags:LIST(1,None,'INTEGER', scope = schema_scope)
	'''

    def __init__(self, inherited0__coordinates, inherited1__normals, inherited2__closed, inherited3__coordindex,
                 inherited4__pnindex, flags, ):
        ifctriangulatedfaceset.__init__(self, inherited0__coordinates, inherited1__normals, inherited2__closed,
                                        inherited3__coordindex, inherited4__pnindex, )
        self._flags = flags

    @property
    def flags(self):
        return self._flags

    @flags.setter
    def flags(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'INTEGER', scope=schema_scope)):
            self._flags = LIST(value)
        else:
            self._flags = value

    def notclosed(self):
        eval_notclosed_wr = (self.self.ifctriangulatedfaceset.self.closed == FALSE)
        if not eval_notclosed_wr:
            raise AssertionError('Rule notclosed violated')
        else:
            return eval_notclosed_wr


####################
# ENTITY ifcworktime #
####################
class ifcworktime(ifcschedulingtime):
    '''Entity ifcworktime definition.

	:param recurrencepattern
	:type recurrencepattern:ifcrecurrencepattern

	:param start
	:type start:ifcdate

	:param finish
	:type finish:ifcdate
	'''

    def __init__(self, inherited0__name, inherited1__dataorigin, inherited2__userdefineddataorigin, recurrencepattern,
                 start, finish, ):
        ifcschedulingtime.__init__(self, inherited0__name, inherited1__dataorigin, inherited2__userdefineddataorigin, )
        self._recurrencepattern = recurrencepattern
        self._start = start
        self._finish = finish

    @property
    def recurrencepattern(self):
        return self._recurrencepattern

    @recurrencepattern.setter
    def recurrencepattern(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcrecurrencepattern):
                self._recurrencepattern = ifcrecurrencepattern(value)
            else:
                self._recurrencepattern = value
        else:
            self._recurrencepattern = value

    @property
    def start(self):
        return self._start

    @start.setter
    def start(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdate):
                self._start = ifcdate(value)
            else:
                self._start = value
        else:
            self._start = value

    @property
    def finish(self):
        return self._finish

    @finish.setter
    def finish(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcdate):
                self._finish = ifcdate(value)
            else:
                self._finish = value
        else:
            self._finish = value


####################
# ENTITY ifcintersectioncurve #
####################
class ifcintersectioncurve(ifcsurfacecurve):
    '''Entity ifcintersectioncurve definition.
	'''

    def __init__(self, inherited0__curve3d, inherited1__associatedgeometry, inherited2__masterrepresentation, ):
        ifcsurfacecurve.__init__(self, inherited0__curve3d, inherited1__associatedgeometry,
                                 inherited2__masterrepresentation, )

    def twopcurves(self):
        eval_twopcurves_wr = (SIZEOF(self.self.ifcsurfacecurve.self.associatedgeometry) == 2)
        if not eval_twopcurves_wr:
            raise AssertionError('Rule twopcurves violated')
        else:
            return eval_twopcurves_wr

    def distinctsurfaces(self):
        eval_distinctsurfaces_wr = (
                    ifcassociatedsurface(self.self.ifcsurfacecurve.self.associatedgeometry[1]) != ifcassociatedsurface(
                self.self.ifcsurfacecurve.self.associatedgeometry[2]))
        if not eval_distinctsurfaces_wr:
            raise AssertionError('Rule distinctsurfaces violated')
        else:
            return eval_distinctsurfaces_wr


####################
# ENTITY ifcwalltype #
####################
class ifcwalltype(ifcbuildingelementtype):
    '''Entity ifcwalltype definition.

	:param predefinedtype
	:type predefinedtype:ifcwalltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcwalltypeenum):
            self._predefinedtype = ifcwalltypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcwalltypeenum.userdefined) or (
                    (self.predefinedtype == ifcwalltypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcannotationfillarea #
####################
class ifcannotationfillarea(ifcgeometricrepresentationitem):
    '''Entity ifcannotationfillarea definition.

	:param outerboundary
	:type outerboundary:ifccurve

	:param innerboundaries
	:type innerboundaries:SET(1,None,'ifccurve', scope = schema_scope)
	'''

    def __init__(self, outerboundary, innerboundaries, ):
        ifcgeometricrepresentationitem.__init__(self, )
        self._outerboundary = outerboundary
        self._innerboundaries = innerboundaries

    @property
    def outerboundary(self):
        return self._outerboundary

    @outerboundary.setter
    def outerboundary(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._outerboundary = ifccurve(value)
        else:
            self._outerboundary = value

    @property
    def innerboundaries(self):
        return self._innerboundaries

    @innerboundaries.setter
    def innerboundaries(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, SET(1, None, 'ifccurve', scope=schema_scope)):
                self._innerboundaries = SET(value)
            else:
                self._innerboundaries = value
        else:
            self._innerboundaries = value


####################
# ENTITY ifccooledbeamtype #
####################
class ifccooledbeamtype(ifcenergyconversiondevicetype):
    '''Entity ifccooledbeamtype definition.

	:param predefinedtype
	:type predefinedtype:ifccooledbeamtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcenergyconversiondevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__applicableoccurrence,
                                               inherited5__haspropertysets, inherited6__representationmaps,
                                               inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccooledbeamtypeenum):
            self._predefinedtype = ifccooledbeamtypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccooledbeamtypeenum.userdefined) or (
                    (self.predefinedtype == ifccooledbeamtypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcpropertylistvalue #
####################
class ifcpropertylistvalue(ifcsimpleproperty):
    '''Entity ifcpropertylistvalue definition.

	:param listvalues
	:type listvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param unit
	:type unit:ifcunit
	'''

    def __init__(self, inherited0__name, inherited1__description, listvalues, unit, ):
        ifcsimpleproperty.__init__(self, inherited0__name, inherited1__description, )
        self._listvalues = listvalues
        self._unit = unit

    @property
    def listvalues(self):
        return self._listvalues

    @listvalues.setter
    def listvalues(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcvalue', scope=schema_scope)):
                self._listvalues = LIST(value)
            else:
                self._listvalues = value
        else:
            self._listvalues = value

    @property
    def unit(self):
        return self._unit

    @unit.setter
    def unit(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcunit):
                self._unit = ifcunit(value)
            else:
                self._unit = value
        else:
            self._unit = value

    def wr31(self):
        eval_wr31_wr = (SIZEOF(None) == 0)
        if not eval_wr31_wr:
            raise AssertionError('Rule wr31 violated')
        else:
            return eval_wr31_wr


####################
# ENTITY ifctransformer #
####################
class ifctransformer(ifcenergyconversiondevice):
    '''Entity ifctransformer definition.

	:param predefinedtype
	:type predefinedtype:ifctransformertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifctransformertypeenum):
                self._predefinedtype = ifctransformertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifctransformertypeenum.userdefined)) or ((
                                                                                                self.predefinedtype == ifctransformertypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCTRANFORMERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcspatialzonetype #
####################
class ifcspatialzonetype(ifcspatialelementtype):
    '''Entity ifcspatialzonetype definition.

	:param predefinedtype
	:type predefinedtype:ifcspatialzonetypeenum

	:param longname
	:type longname:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, longname, ):
        ifcspatialelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__applicableoccurrence,
                                       inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                       inherited8__elementtype, )
        self._predefinedtype = predefinedtype
        self._longname = longname

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcspatialzonetypeenum):
            self._predefinedtype = ifcspatialzonetypeenum(value)
        else:
            self._predefinedtype = value

    @property
    def longname(self):
        return self._longname

    @longname.setter
    def longname(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._longname = ifclabel(value)
            else:
                self._longname = value
        else:
            self._longname = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcspatialzonetypeenum.userdefined) or (
                    (self.predefinedtype == ifcspatialzonetypeenum.userdefined) and EXISTS(
                self.self.ifcspatialelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcwindowpanelproperties #
####################
class ifcwindowpanelproperties(ifcpredefinedpropertyset):
    '''Entity ifcwindowpanelproperties definition.

	:param operationtype
	:type operationtype:ifcwindowpaneloperationenum

	:param panelposition
	:type panelposition:ifcwindowpanelpositionenum

	:param framedepth
	:type framedepth:ifcpositivelengthmeasure

	:param framethickness
	:type framethickness:ifcpositivelengthmeasure

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 operationtype, panelposition, framedepth, framethickness, shapeaspectstyle, ):
        ifcpredefinedpropertyset.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                          inherited3__description, )
        self._operationtype = operationtype
        self._panelposition = panelposition
        self._framedepth = framedepth
        self._framethickness = framethickness
        self._shapeaspectstyle = shapeaspectstyle

    @property
    def operationtype(self):
        return self._operationtype

    @operationtype.setter
    def operationtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcwindowpaneloperationenum):
            self._operationtype = ifcwindowpaneloperationenum(value)
        else:
            self._operationtype = value

    @property
    def panelposition(self):
        return self._panelposition

    @panelposition.setter
    def panelposition(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcwindowpanelpositionenum):
            self._panelposition = ifcwindowpanelpositionenum(value)
        else:
            self._panelposition = value

    @property
    def framedepth(self):
        return self._framedepth

    @framedepth.setter
    def framedepth(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._framedepth = ifcpositivelengthmeasure(value)
            else:
                self._framedepth = value
        else:
            self._framedepth = value

    @property
    def framethickness(self):
        return self._framethickness

    @framethickness.setter
    def framethickness(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcpositivelengthmeasure):
                self._framethickness = ifcpositivelengthmeasure(value)
            else:
                self._framethickness = value
        else:
            self._framethickness = value

    @property
    def shapeaspectstyle(self):
        return self._shapeaspectstyle

    @shapeaspectstyle.setter
    def shapeaspectstyle(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcshapeaspect):
                self._shapeaspectstyle = ifcshapeaspect(value)
            else:
                self._shapeaspectstyle = value
        else:
            self._shapeaspectstyle = value

    def applicabletotype(self):
        eval_applicabletotype_wr = (EXISTS(self.self.ifcpropertysetdefinition.self.definestype[1]) and (
                    ('IFC4X2.IFCWINDOWTYPE' == TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1])) or (
                        'IFC4X2.IFCWINDOWSTYLE' == TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1]))))
        if not eval_applicabletotype_wr:
            raise AssertionError('Rule applicabletotype violated')
        else:
            return eval_applicabletotype_wr


####################
# ENTITY ifczone #
####################
class ifczone(ifcsystem):
    '''Entity ifczone definition.

	:param longname
	:type longname:ifclabel
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, longname, ):
        ifcsystem.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                           inherited3__description, inherited4__objecttype, )
        self._longname = longname

    @property
    def longname(self):
        return self._longname

    @longname.setter
    def longname(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._longname = ifclabel(value)
            else:
                self._longname = value
        else:
            self._longname = value

    def wr1(self):
        eval_wr1_wr = ((SIZEOF(self.self.ifcgroup.self.isgroupedby) == 0) or (SIZEOF(None) == 0))
        if not eval_wr1_wr:
            raise AssertionError('Rule wr1 violated')
        else:
            return eval_wr1_wr


####################
# ENTITY ifcconstructionequipmentresourcetype #
####################
class ifcconstructionequipmentresourcetype(ifcconstructionresourcetype):
    '''Entity ifcconstructionequipmentresourcetype definition.

	:param predefinedtype
	:type predefinedtype:ifcconstructionequipmentresourcetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__identification,
                 inherited7__longdescription, inherited8__resourcetype, inherited9__basecosts,
                 inherited10__basequantity, predefinedtype, ):
        ifcconstructionresourcetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                             inherited3__description, inherited4__applicableoccurrence,
                                             inherited5__haspropertysets, inherited6__identification,
                                             inherited7__longdescription, inherited8__resourcetype,
                                             inherited9__basecosts, inherited10__basequantity, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcconstructionequipmentresourcetypeenum):
            self._predefinedtype = ifcconstructionequipmentresourcetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    (self.predefinedtype != ifcconstructionequipmentresourcetypeenum.userdefined) or (
                        (self.predefinedtype == ifcconstructionequipmentresourcetypeenum.userdefined) and EXISTS(
                    self.self.ifctyperesource.self.resourcetype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcrelassociatesdocument #
####################
class ifcrelassociatesdocument(ifcrelassociates):
    '''Entity ifcrelassociatesdocument definition.

	:param relatingdocument
	:type relatingdocument:ifcdocumentselect
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__relatedobjects, relatingdocument, ):
        ifcrelassociates.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                  inherited3__description, inherited4__relatedobjects, )
        self._relatingdocument = relatingdocument

    @property
    def relatingdocument(self):
        return self._relatingdocument

    @relatingdocument.setter
    def relatingdocument(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdocumentselect):
            self._relatingdocument = ifcdocumentselect(value)
        else:
            self._relatingdocument = value


####################
# ENTITY ifcrelservicesbuildings #
####################
class ifcrelservicesbuildings(ifcrelconnects):
    '''Entity ifcrelservicesbuildings definition.

	:param relatingsystem
	:type relatingsystem:ifcsystem

	:param relatedbuildings
	:type relatedbuildings:SET(1,None,'ifcspatialelement', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 relatingsystem, relatedbuildings, ):
        ifcrelconnects.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                inherited3__description, )
        self._relatingsystem = relatingsystem
        self._relatedbuildings = relatedbuildings

    @property
    def relatingsystem(self):
        return self._relatingsystem

    @relatingsystem.setter
    def relatingsystem(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsystem):
            self._relatingsystem = ifcsystem(value)
        else:
            self._relatingsystem = value

    @property
    def relatedbuildings(self):
        return self._relatedbuildings

    @relatedbuildings.setter
    def relatedbuildings(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, SET(1, None, 'ifcspatialelement', scope=schema_scope)):
            self._relatedbuildings = SET(value)
        else:
            self._relatedbuildings = value


####################
# ENTITY ifcspace #
####################
class ifcspace(ifcspatialstructureelement):
    '''Entity ifcspace definition.

	:param predefinedtype
	:type predefinedtype:ifcspacetypeenum

	:param elevationwithflooring
	:type elevationwithflooring:ifclengthmeasure

	:param hascoverings
	:type hascoverings:SET(0,None,'ifcrelcoversspaces', scope = schema_scope)

	:param boundedby
	:type boundedby:SET(0,None,'ifcrelspaceboundary', scope = schema_scope)
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__longname,
                 inherited8__compositiontype, predefinedtype, elevationwithflooring, ):
        ifcspatialstructureelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__objecttype,
                                            inherited5__objectplacement, inherited6__representation,
                                            inherited7__longname, inherited8__compositiontype, )
        self._predefinedtype = predefinedtype
        self._elevationwithflooring = elevationwithflooring

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcspacetypeenum):
                self._predefinedtype = ifcspacetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    @property
    def elevationwithflooring(self):
        return self._elevationwithflooring

    @elevationwithflooring.setter
    def elevationwithflooring(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclengthmeasure):
                self._elevationwithflooring = ifclengthmeasure(value)
            else:
                self._elevationwithflooring = value
        else:
            self._elevationwithflooring = value

    @property
    def hascoverings(self):
        return self._hascoverings

    @hascoverings.setter
    def hascoverings(self, value):
        # INVERSE argument
        raise AssertionError('Argument hascoverings is INVERSE. It is computed and can not be set to any value')

    @property
    def boundedby(self):
        return self._boundedby

    @boundedby.setter
    def boundedby(self, value):
        # INVERSE argument
        raise AssertionError('Argument boundedby is INVERSE. It is computed and can not be set to any value')

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (
                    ((not EXISTS(self.predefinedtype)) or (self.predefinedtype != ifcspacetypeenum.userdefined)) or (
                        (self.predefinedtype == ifcspacetypeenum.userdefined) and EXISTS(
                    self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCSPACETYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcwallstandardcase #
####################
class ifcwallstandardcase(ifcwall):
    '''Entity ifcwallstandardcase definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__predefinedtype, ):
        ifcwall.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                         inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                         inherited6__representation, inherited7__tag, inherited8__predefinedtype, )

    def hasmateriallayersetusage(self):
        eval_hasmateriallayersetusage_wr = (SIZEOF(None) == 1)
        if not eval_hasmateriallayersetusage_wr:
            raise AssertionError('Rule hasmateriallayersetusage violated')
        else:
            return eval_hasmateriallayersetusage_wr


####################
# ENTITY ifcpredefinedtextfont #
####################
class ifcpredefinedtextfont(ifcpredefineditem):
    '''Entity ifcpredefinedtextfont definition.
	'''

    def __init__(self, inherited0__name, ):
        ifcpredefineditem.__init__(self, inherited0__name, )


####################
# ENTITY ifcaudiovisualappliancetype #
####################
class ifcaudiovisualappliancetype(ifcflowterminaltype):
    '''Entity ifcaudiovisualappliancetype definition.

	:param predefinedtype
	:type predefinedtype:ifcaudiovisualappliancetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowterminaltype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__applicableoccurrence,
                                     inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                     inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcaudiovisualappliancetypeenum):
            self._predefinedtype = ifcaudiovisualappliancetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcaudiovisualappliancetypeenum.userdefined) or (
                    (self.predefinedtype == ifcaudiovisualappliancetypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcconstructionproductresource #
####################
class ifcconstructionproductresource(ifcconstructionresource):
    '''Entity ifcconstructionproductresource definition.

	:param predefinedtype
	:type predefinedtype:ifcconstructionproductresourcetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__identification, inherited6__longdescription, inherited7__usage,
                 inherited8__basecosts, inherited9__basequantity, predefinedtype, ):
        ifcconstructionresource.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__objecttype, inherited5__identification,
                                         inherited6__longdescription, inherited7__usage, inherited8__basecosts,
                                         inherited9__basequantity, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcconstructionproductresourcetypeenum):
                self._predefinedtype = ifcconstructionproductresourcetypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcconstructionproductresourcetypeenum.userdefined)) or ((
                                                                                                                self.predefinedtype == ifcconstructionproductresourcetypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcboxedhalfspace #
####################
class ifcboxedhalfspace(ifchalfspacesolid):
    '''Entity ifcboxedhalfspace definition.

	:param enclosure
	:type enclosure:ifcboundingbox
	'''

    def __init__(self, inherited0__basesurface, inherited1__agreementflag, enclosure, ):
        ifchalfspacesolid.__init__(self, inherited0__basesurface, inherited1__agreementflag, )
        self._enclosure = enclosure

    @property
    def enclosure(self):
        return self._enclosure

    @enclosure.setter
    def enclosure(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboundingbox):
            self._enclosure = ifcboundingbox(value)
        else:
            self._enclosure = value

    def unboundedsurface(self):
        eval_unboundedsurface_wr = (
            not ('IFC4X2.IFCCURVEBOUNDEDPLANE' == TYPEOF(self.self.ifchalfspacesolid.self.basesurface)))
        if not eval_unboundedsurface_wr:
            raise AssertionError('Rule unboundedsurface violated')
        else:
            return eval_unboundedsurface_wr


####################
# ENTITY ifcedgecurve #
####################
class ifcedgecurve(ifcedge):
    '''Entity ifcedgecurve definition.

	:param edgegeometry
	:type edgegeometry:ifccurve

	:param samesense
	:type samesense:ifcboolean
	'''

    def __init__(self, inherited0__edgestart, inherited1__edgeend, edgegeometry, samesense, ):
        ifcedge.__init__(self, inherited0__edgestart, inherited1__edgeend, )
        self._edgegeometry = edgegeometry
        self._samesense = samesense

    @property
    def edgegeometry(self):
        return self._edgegeometry

    @edgegeometry.setter
    def edgegeometry(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccurve):
            self._edgegeometry = ifccurve(value)
        else:
            self._edgegeometry = value

    @property
    def samesense(self):
        return self._samesense

    @samesense.setter
    def samesense(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._samesense = ifcboolean(value)
        else:
            self._samesense = value


####################
# ENTITY ifclightsourcegoniometric #
####################
class ifclightsourcegoniometric(ifclightsource):
    '''Entity ifclightsourcegoniometric definition.

	:param position
	:type position:ifcaxis2placement3d

	:param colourappearance
	:type colourappearance:ifccolourrgb

	:param colourtemperature
	:type colourtemperature:ifcthermodynamictemperaturemeasure

	:param luminousflux
	:type luminousflux:ifcluminousfluxmeasure

	:param lightemissionsource
	:type lightemissionsource:ifclightemissionsourceenum

	:param lightdistributiondatasource
	:type lightdistributiondatasource:ifclightdistributiondatasourceselect
	'''

    def __init__(self, inherited0__name, inherited1__lightcolour, inherited2__ambientintensity, inherited3__intensity,
                 position, colourappearance, colourtemperature, luminousflux, lightemissionsource,
                 lightdistributiondatasource, ):
        ifclightsource.__init__(self, inherited0__name, inherited1__lightcolour, inherited2__ambientintensity,
                                inherited3__intensity, )
        self._position = position
        self._colourappearance = colourappearance
        self._colourtemperature = colourtemperature
        self._luminousflux = luminousflux
        self._lightemissionsource = lightemissionsource
        self._lightdistributiondatasource = lightdistributiondatasource

    @property
    def position(self):
        return self._position

    @position.setter
    def position(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcaxis2placement3d):
            self._position = ifcaxis2placement3d(value)
        else:
            self._position = value

    @property
    def colourappearance(self):
        return self._colourappearance

    @colourappearance.setter
    def colourappearance(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccolourrgb):
                self._colourappearance = ifccolourrgb(value)
            else:
                self._colourappearance = value
        else:
            self._colourappearance = value

    @property
    def colourtemperature(self):
        return self._colourtemperature

    @colourtemperature.setter
    def colourtemperature(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcthermodynamictemperaturemeasure):
            self._colourtemperature = ifcthermodynamictemperaturemeasure(value)
        else:
            self._colourtemperature = value

    @property
    def luminousflux(self):
        return self._luminousflux

    @luminousflux.setter
    def luminousflux(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcluminousfluxmeasure):
            self._luminousflux = ifcluminousfluxmeasure(value)
        else:
            self._luminousflux = value

    @property
    def lightemissionsource(self):
        return self._lightemissionsource

    @lightemissionsource.setter
    def lightemissionsource(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclightemissionsourceenum):
            self._lightemissionsource = ifclightemissionsourceenum(value)
        else:
            self._lightemissionsource = value

    @property
    def lightdistributiondatasource(self):
        return self._lightdistributiondatasource

    @lightdistributiondatasource.setter
    def lightdistributiondatasource(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclightdistributiondatasourceselect):
            self._lightdistributiondatasource = ifclightdistributiondatasourceselect(value)
        else:
            self._lightdistributiondatasource = value


####################
# ENTITY ifcevaporativecooler #
####################
class ifcevaporativecooler(ifcenergyconversiondevice):
    '''Entity ifcevaporativecooler definition.

	:param predefinedtype
	:type predefinedtype:ifcevaporativecoolertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcenergyconversiondevice.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                           inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                           inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcevaporativecoolertypeenum):
                self._predefinedtype = ifcevaporativecoolertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcevaporativecoolertypeenum.userdefined)) or ((
                                                                                                      self.predefinedtype == ifcevaporativecoolertypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or ('IFC4X2.IFCEVAPORATIVECOOLERTYPE' == TYPEOF(
            self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcairterminal #
####################
class ifcairterminal(ifcflowterminal):
    '''Entity ifcairterminal definition.

	:param predefinedtype
	:type predefinedtype:ifcairterminaltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcflowterminal.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                 inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                 inherited6__representation, inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcairterminaltypeenum):
                self._predefinedtype = ifcairterminaltypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifcairterminaltypeenum.userdefined)) or ((
                                                                                                self.predefinedtype == ifcairterminaltypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCAIRTERMINALTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifcclosedshell #
####################
class ifcclosedshell(ifcconnectedfaceset):
    '''Entity ifcclosedshell definition.
	'''

    def __init__(self, inherited0__cfsfaces, ):
        ifcconnectedfaceset.__init__(self, inherited0__cfsfaces, )


####################
# ENTITY ifcelectrictimecontroltype #
####################
class ifcelectrictimecontroltype(ifcflowcontrollertype):
    '''Entity ifcelectrictimecontroltype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectrictimecontroltypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowcontrollertype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__applicableoccurrence,
                                       inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                       inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcelectrictimecontroltypeenum):
            self._predefinedtype = ifcelectrictimecontroltypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcelectrictimecontroltypeenum.userdefined) or (
                    (self.predefinedtype == ifcelectrictimecontroltypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcmedicaldevicetype #
####################
class ifcmedicaldevicetype(ifcflowterminaltype):
    '''Entity ifcmedicaldevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcmedicaldevicetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowterminaltype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                     inherited3__description, inherited4__applicableoccurrence,
                                     inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                     inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcmedicaldevicetypeenum):
            self._predefinedtype = ifcmedicaldevicetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcmedicaldevicetypeenum.userdefined) or (
                    (self.predefinedtype == ifcmedicaldevicetypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcshadingdevicetype #
####################
class ifcshadingdevicetype(ifcbuildingelementtype):
    '''Entity ifcshadingdevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcshadingdevicetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcshadingdevicetypeenum):
            self._predefinedtype = ifcshadingdevicetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcshadingdevicetypeenum.userdefined) or (
                    (self.predefinedtype == ifcshadingdevicetypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcgrid #
####################
class ifcgrid(ifcpositioningelement):
    '''Entity ifcgrid definition.

	:param uaxes
	:type uaxes:LIST(1,None,'ifcgridaxis', scope = schema_scope)

	:param vaxes
	:type vaxes:LIST(1,None,'ifcgridaxis', scope = schema_scope)

	:param waxes
	:type waxes:LIST(1,None,'ifcgridaxis', scope = schema_scope)

	:param predefinedtype
	:type predefinedtype:ifcgridtypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, uaxes, vaxes, waxes,
                 predefinedtype, ):
        ifcpositioningelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                       inherited6__representation, )
        self._uaxes = uaxes
        self._vaxes = vaxes
        self._waxes = waxes
        self._predefinedtype = predefinedtype

    @property
    def uaxes(self):
        return self._uaxes

    @uaxes.setter
    def uaxes(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcgridaxis', scope=schema_scope)):
            self._uaxes = LIST(value)
        else:
            self._uaxes = value

    @property
    def vaxes(self):
        return self._vaxes

    @vaxes.setter
    def vaxes(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'ifcgridaxis', scope=schema_scope)):
            self._vaxes = LIST(value)
        else:
            self._vaxes = value

    @property
    def waxes(self):
        return self._waxes

    @waxes.setter
    def waxes(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, LIST(1, None, 'ifcgridaxis', scope=schema_scope)):
                self._waxes = LIST(value)
            else:
                self._waxes = value
        else:
            self._waxes = value

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcgridtypeenum):
                self._predefinedtype = ifcgridtypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value


####################
# ENTITY ifclaborresourcetype #
####################
class ifclaborresourcetype(ifcconstructionresourcetype):
    '''Entity ifclaborresourcetype definition.

	:param predefinedtype
	:type predefinedtype:ifclaborresourcetypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__identification,
                 inherited7__longdescription, inherited8__resourcetype, inherited9__basecosts,
                 inherited10__basequantity, predefinedtype, ):
        ifcconstructionresourcetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                             inherited3__description, inherited4__applicableoccurrence,
                                             inherited5__haspropertysets, inherited6__identification,
                                             inherited7__longdescription, inherited8__resourcetype,
                                             inherited9__basecosts, inherited10__basequantity, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclaborresourcetypeenum):
            self._predefinedtype = ifclaborresourcetypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifclaborresourcetypeenum.userdefined) or (
                    (self.predefinedtype == ifclaborresourcetypeenum.userdefined) and EXISTS(
                self.self.ifctyperesource.self.resourcetype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcstructuralsurfacereaction #
####################
class ifcstructuralsurfacereaction(ifcstructuralreaction):
    '''Entity ifcstructuralsurfacereaction definition.

	:param predefinedtype
	:type predefinedtype:ifcstructuralsurfaceactivitytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation,
                 inherited7__appliedload, inherited8__globalorlocal, predefinedtype, ):
        ifcstructuralreaction.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                       inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                                       inherited6__representation, inherited7__appliedload, inherited8__globalorlocal, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcstructuralsurfaceactivitytypeenum):
            self._predefinedtype = ifcstructuralsurfaceactivitytypeenum(value)
        else:
            self._predefinedtype = value

    def haspredefinedtype(self):
        eval_haspredefinedtype_wr = (
                    (self.predefinedtype != ifcstructuralsurfaceactivitytypeenum.userdefined) or EXISTS(
                self.self.ifcobject.self.objecttype))
        if not eval_haspredefinedtype_wr:
            raise AssertionError('Rule haspredefinedtype violated')
        else:
            return eval_haspredefinedtype_wr


####################
# ENTITY ifctextstylefontmodel #
####################
class ifctextstylefontmodel(ifcpredefinedtextfont):
    '''Entity ifctextstylefontmodel definition.

	:param fontfamily
	:type fontfamily:LIST(1,None,'STRING', scope = schema_scope)

	:param fontstyle
	:type fontstyle:ifcfontstyle

	:param fontvariant
	:type fontvariant:ifcfontvariant

	:param fontweight
	:type fontweight:ifcfontweight

	:param fontsize
	:type fontsize:ifcsizeselect
	'''

    def __init__(self, inherited0__name, fontfamily, fontstyle, fontvariant, fontweight, fontsize, ):
        ifcpredefinedtextfont.__init__(self, inherited0__name, )
        self._fontfamily = fontfamily
        self._fontstyle = fontstyle
        self._fontvariant = fontvariant
        self._fontweight = fontweight
        self._fontsize = fontsize

    @property
    def fontfamily(self):
        return self._fontfamily

    @fontfamily.setter
    def fontfamily(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, LIST(1, None, 'STRING', scope=schema_scope)):
            self._fontfamily = LIST(value)
        else:
            self._fontfamily = value

    @property
    def fontstyle(self):
        return self._fontstyle

    @fontstyle.setter
    def fontstyle(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcfontstyle):
                self._fontstyle = ifcfontstyle(value)
            else:
                self._fontstyle = value
        else:
            self._fontstyle = value

    @property
    def fontvariant(self):
        return self._fontvariant

    @fontvariant.setter
    def fontvariant(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcfontvariant):
                self._fontvariant = ifcfontvariant(value)
            else:
                self._fontvariant = value
        else:
            self._fontvariant = value

    @property
    def fontweight(self):
        return self._fontweight

    @fontweight.setter
    def fontweight(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcfontweight):
                self._fontweight = ifcfontweight(value)
            else:
                self._fontweight = value
        else:
            self._fontweight = value

    @property
    def fontsize(self):
        return self._fontsize

    @fontsize.setter
    def fontsize(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsizeselect):
            self._fontsize = ifcsizeselect(value)
        else:
            self._fontsize = value

    def measureoffontsize(self):
        eval_measureoffontsize_wr = (
                    ('IFC4X2.IFCLENGTHMEASURE' == TYPEOF(self.self.fontsize)) and (self.self.fontsize > 0))
        if not eval_measureoffontsize_wr:
            raise AssertionError('Rule measureoffontsize violated')
        else:
            return eval_measureoffontsize_wr


####################
# ENTITY ifcoccupant #
####################
class ifcoccupant(ifcactor):
    '''Entity ifcoccupant definition.

	:param predefinedtype
	:type predefinedtype:ifcoccupanttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__theactor, predefinedtype, ):
        ifcactor.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                          inherited3__description, inherited4__objecttype, inherited5__theactor, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcoccupanttypeenum):
                self._predefinedtype = ifcoccupanttypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def wr31(self):
        eval_wr31_wr = ((not (self.predefinedtype == ifcoccupanttypeenum.userdefined)) or EXISTS(
            self.self.ifcobject.self.objecttype))
        if not eval_wr31_wr:
            raise AssertionError('Rule wr31 violated')
        else:
            return eval_wr31_wr


####################
# ENTITY ifcapplication #
####################
class ifcapplication(BaseEntityClass):
    '''Entity ifcapplication definition.

	:param applicationdeveloper
	:type applicationdeveloper:ifcorganization

	:param version
	:type version:ifclabel

	:param applicationfullname
	:type applicationfullname:ifclabel

	:param applicationidentifier
	:type applicationidentifier:ifcidentifier
	'''

    def __init__(self, applicationdeveloper, version, applicationfullname, applicationidentifier, ):
        self._applicationdeveloper = applicationdeveloper
        self._version = version
        self._applicationfullname = applicationfullname
        self._applicationidentifier = applicationidentifier

    @property
    def applicationdeveloper(self):
        return self._applicationdeveloper

    @applicationdeveloper.setter
    def applicationdeveloper(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcorganization):
            self._applicationdeveloper = ifcorganization(value)
        else:
            self._applicationdeveloper = value

    @property
    def version(self):
        return self._version

    @version.setter
    def version(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._version = ifclabel(value)
        else:
            self._version = value

    @property
    def applicationfullname(self):
        return self._applicationfullname

    @applicationfullname.setter
    def applicationfullname(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifclabel):
            self._applicationfullname = ifclabel(value)
        else:
            self._applicationfullname = value

    @property
    def applicationidentifier(self):
        return self._applicationidentifier

    @applicationidentifier.setter
    def applicationidentifier(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcidentifier):
            self._applicationidentifier = ifcidentifier(value)
        else:
            self._applicationidentifier = value


####################
# ENTITY ifcfiltertype #
####################
class ifcfiltertype(ifcflowtreatmentdevicetype):
    '''Entity ifcfiltertype definition.

	:param predefinedtype
	:type predefinedtype:ifcfiltertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowtreatmentdevicetype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                            inherited3__description, inherited4__applicableoccurrence,
                                            inherited5__haspropertysets, inherited6__representationmaps,
                                            inherited7__tag, inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcfiltertypeenum):
            self._predefinedtype = ifcfiltertypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcfiltertypeenum.userdefined) or (
                    (self.predefinedtype == ifcfiltertypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcrectangulartrimmedsurface #
####################
class ifcrectangulartrimmedsurface(ifcboundedsurface):
    '''Entity ifcrectangulartrimmedsurface definition.

	:param basissurface
	:type basissurface:ifcsurface

	:param u1
	:type u1:ifcparametervalue

	:param v1
	:type v1:ifcparametervalue

	:param u2
	:type u2:ifcparametervalue

	:param v2
	:type v2:ifcparametervalue

	:param usense
	:type usense:ifcboolean

	:param vsense
	:type vsense:ifcboolean
	'''

    def __init__(self, basissurface, u1, v1, u2, v2, usense, vsense, ):
        ifcboundedsurface.__init__(self, )
        self._basissurface = basissurface
        self._u1 = u1
        self._v1 = v1
        self._u2 = u2
        self._v2 = v2
        self._usense = usense
        self._vsense = vsense

    @property
    def basissurface(self):
        return self._basissurface

    @basissurface.setter
    def basissurface(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcsurface):
            self._basissurface = ifcsurface(value)
        else:
            self._basissurface = value

    @property
    def u1(self):
        return self._u1

    @u1.setter
    def u1(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcparametervalue):
            self._u1 = ifcparametervalue(value)
        else:
            self._u1 = value

    @property
    def v1(self):
        return self._v1

    @v1.setter
    def v1(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcparametervalue):
            self._v1 = ifcparametervalue(value)
        else:
            self._v1 = value

    @property
    def u2(self):
        return self._u2

    @u2.setter
    def u2(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcparametervalue):
            self._u2 = ifcparametervalue(value)
        else:
            self._u2 = value

    @property
    def v2(self):
        return self._v2

    @v2.setter
    def v2(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcparametervalue):
            self._v2 = ifcparametervalue(value)
        else:
            self._v2 = value

    @property
    def usense(self):
        return self._usense

    @usense.setter
    def usense(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._usense = ifcboolean(value)
        else:
            self._usense = value

    @property
    def vsense(self):
        return self._vsense

    @vsense.setter
    def vsense(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcboolean):
            self._vsense = ifcboolean(value)
        else:
            self._vsense = value

    def u1andu2different(self):
        eval_u1andu2different_wr = (self.u1 != self.u2)
        if not eval_u1andu2different_wr:
            raise AssertionError('Rule u1andu2different violated')
        else:
            return eval_u1andu2different_wr

    def v1andv2different(self):
        eval_v1andv2different_wr = (self.v1 != self.v2)
        if not eval_v1andv2different_wr:
            raise AssertionError('Rule v1andv2different violated')
        else:
            return eval_v1andv2different_wr

    def usensecompatible(self):
        eval_usensecompatible_wr = (((('IFC4X2.IFCELEMENTARYSURFACE' == TYPEOF(self.basissurface)) and (
            not ('IFC4X2.IFCPLANE' == TYPEOF(self.basissurface)))) or (
                                                 'IFC4X2.IFCSURFACEOFREVOLUTION' == TYPEOF(self.basissurface))) or (
                                                self.usense == (self.u2 > self.u1)))
        if not eval_usensecompatible_wr:
            raise AssertionError('Rule usensecompatible violated')
        else:
            return eval_usensecompatible_wr

    def vsensecompatible(self):
        eval_vsensecompatible_wr = (self.vsense == (self.v2 > self.v1))
        if not eval_vsensecompatible_wr:
            raise AssertionError('Rule vsensecompatible violated')
        else:
            return eval_vsensecompatible_wr


####################
# ENTITY ifccontroller #
####################
class ifccontroller(ifcdistributioncontrolelement):
    '''Entity ifccontroller definition.

	:param predefinedtype
	:type predefinedtype:ifccontrollertypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 predefinedtype, ):
        ifcdistributioncontrolelement.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                               inherited3__description, inherited4__objecttype,
                                               inherited5__objectplacement, inherited6__representation,
                                               inherited7__tag, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifccontrollertypeenum):
                self._predefinedtype = ifccontrollertypeenum(value)
            else:
                self._predefinedtype = value
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = (((not EXISTS(self.predefinedtype)) or (
                    self.predefinedtype != ifccontrollertypeenum.userdefined)) or ((
                                                                                               self.predefinedtype == ifccontrollertypeenum.userdefined) and EXISTS(
            self.self.ifcobject.self.objecttype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr

    def correcttypeassigned(self):
        eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby) == 0) or (
                    'IFC4X2.IFCCONTROLLERTYPE' == TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
        if not eval_correcttypeassigned_wr:
            raise AssertionError('Rule correcttypeassigned violated')
        else:
            return eval_correcttypeassigned_wr


####################
# ENTITY ifccablecarriersegmenttype #
####################
class ifccablecarriersegmenttype(ifcflowsegmenttype):
    '''Entity ifccablecarriersegmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifccablecarriersegmenttypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcflowsegmenttype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                    inherited3__description, inherited4__applicableoccurrence,
                                    inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                    inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifccablecarriersegmenttypeenum):
            self._predefinedtype = ifccablecarriersegmenttypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifccablecarriersegmenttypeenum.userdefined) or (
                    (self.predefinedtype == ifccablecarriersegmenttypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcdiscreteaccessorytype #
####################
class ifcdiscreteaccessorytype(ifcelementcomponenttype):
    '''Entity ifcdiscreteaccessorytype definition.

	:param predefinedtype
	:type predefinedtype:ifcdiscreteaccessorytypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcelementcomponenttype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                         inherited3__description, inherited4__applicableoccurrence,
                                         inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                         inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcdiscreteaccessorytypeenum):
            self._predefinedtype = ifcdiscreteaccessorytypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcdiscreteaccessorytypeenum.userdefined) or (
                    (self.predefinedtype == ifcdiscreteaccessorytypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# ENTITY ifcslabstandardcase #
####################
class ifcslabstandardcase(ifcslab):
    '''Entity ifcslabstandardcase definition.
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__objecttype, inherited5__objectplacement, inherited6__representation, inherited7__tag,
                 inherited8__predefinedtype, ):
        ifcslab.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                         inherited3__description, inherited4__objecttype, inherited5__objectplacement,
                         inherited6__representation, inherited7__tag, inherited8__predefinedtype, )

    def hasmateriallayersetusage(self):
        eval_hasmateriallayersetusage_wr = (SIZEOF(None) == 1)
        if not eval_hasmateriallayersetusage_wr:
            raise AssertionError('Rule hasmateriallayersetusage violated')
        else:
            return eval_hasmateriallayersetusage_wr


####################
# ENTITY ifcmetric #
####################
class ifcmetric(ifcconstraint):
    '''Entity ifcmetric definition.

	:param benchmark
	:type benchmark:ifcbenchmarkenum

	:param valuesource
	:type valuesource:ifclabel

	:param datavalue
	:type datavalue:ifcmetricvalueselect

	:param referencepath
	:type referencepath:ifcreference
	'''

    def __init__(self, inherited0__name, inherited1__description, inherited2__constraintgrade,
                 inherited3__constraintsource, inherited4__creatingactor, inherited5__creationtime,
                 inherited6__userdefinedgrade, benchmark, valuesource, datavalue, referencepath, ):
        ifcconstraint.__init__(self, inherited0__name, inherited1__description, inherited2__constraintgrade,
                               inherited3__constraintsource, inherited4__creatingactor, inherited5__creationtime,
                               inherited6__userdefinedgrade, )
        self._benchmark = benchmark
        self._valuesource = valuesource
        self._datavalue = datavalue
        self._referencepath = referencepath

    @property
    def benchmark(self):
        return self._benchmark

    @benchmark.setter
    def benchmark(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcbenchmarkenum):
            self._benchmark = ifcbenchmarkenum(value)
        else:
            self._benchmark = value

    @property
    def valuesource(self):
        return self._valuesource

    @valuesource.setter
    def valuesource(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifclabel):
                self._valuesource = ifclabel(value)
            else:
                self._valuesource = value
        else:
            self._valuesource = value

    @property
    def datavalue(self):
        return self._datavalue

    @datavalue.setter
    def datavalue(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcmetricvalueselect):
                self._datavalue = ifcmetricvalueselect(value)
            else:
                self._datavalue = value
        else:
            self._datavalue = value

    @property
    def referencepath(self):
        return self._referencepath

    @referencepath.setter
    def referencepath(self, value):
        if value != None:  # OPTIONAL attribute
            if not check_type(value, ifcreference):
                self._referencepath = ifcreference(value)
            else:
                self._referencepath = value
        else:
            self._referencepath = value


####################
# ENTITY ifcramptype #
####################
class ifcramptype(ifcbuildingelementtype):
    '''Entity ifcramptype definition.

	:param predefinedtype
	:type predefinedtype:ifcramptypeenum
	'''

    def __init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name, inherited3__description,
                 inherited4__applicableoccurrence, inherited5__haspropertysets, inherited6__representationmaps,
                 inherited7__tag, inherited8__elementtype, predefinedtype, ):
        ifcbuildingelementtype.__init__(self, inherited0__globalid, inherited1__ownerhistory, inherited2__name,
                                        inherited3__description, inherited4__applicableoccurrence,
                                        inherited5__haspropertysets, inherited6__representationmaps, inherited7__tag,
                                        inherited8__elementtype, )
        self._predefinedtype = predefinedtype

    @property
    def predefinedtype(self):
        return self._predefinedtype

    @predefinedtype.setter
    def predefinedtype(self, value):
        # Mandatory argument
        assert value != None, 'Argument "value" is mandatory and cannot be set to None'
        if not check_type(value, ifcramptypeenum):
            self._predefinedtype = ifcramptypeenum(value)
        else:
            self._predefinedtype = value

    def correctpredefinedtype(self):
        eval_correctpredefinedtype_wr = ((self.predefinedtype != ifcramptypeenum.userdefined) or (
                    (self.predefinedtype == ifcramptypeenum.userdefined) and EXISTS(
                self.self.ifcelementtype.self.elementtype)))
        if not eval_correctpredefinedtype_wr:
            raise AssertionError('Rule correctpredefinedtype violated')
        else:
            return eval_correctpredefinedtype_wr


####################
# FUNCTION ifccorrectdimensions #
####################
def ifccorrectdimensions(m, dim, ):
    '''
	:param m
	:type m:ifcunitenum
	:param dim
	:type dim:ifcdimensionalexponents
	'''
    case_selector = m
    if case_selector == ifcunitenum.lengthunit:
        if (dim == ifcdimensionalexponents(1, 0, 0, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.massunit:
        if (dim == ifcdimensionalexponents(0, 1, 0, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.timeunit:
        if (dim == ifcdimensionalexponents(0, 0, 1, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.electriccurrentunit:
        if (dim == ifcdimensionalexponents(0, 0, 0, 1, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.thermodynamictemperatureunit:
        if (dim == ifcdimensionalexponents(0, 0, 0, 0, 1, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.amountofsubstanceunit:
        if (dim == ifcdimensionalexponents(0, 0, 0, 0, 0, 1, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.luminousintensityunit:
        if (dim == ifcdimensionalexponents(0, 0, 0, 0, 0, 0, 1)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.planeangleunit:
        if (dim == ifcdimensionalexponents(0, 0, 0, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.solidangleunit:
        if (dim == ifcdimensionalexponents(0, 0, 0, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.areaunit:
        if (dim == ifcdimensionalexponents(2, 0, 0, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.volumeunit:
        if (dim == ifcdimensionalexponents(3, 0, 0, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.absorbeddoseunit:
        if (dim == ifcdimensionalexponents(2, 0, -2, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.radioactivityunit:
        if (dim == ifcdimensionalexponents(0, 0, -1, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.electriccapacitanceunit:
        if (dim == ifcdimensionalexponents(-2, -1, 4, 2, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.doseequivalentunit:
        if (dim == ifcdimensionalexponents(2, 0, -2, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.electricchargeunit:
        if (dim == ifcdimensionalexponents(0, 0, 1, 1, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.electricconductanceunit:
        if (dim == ifcdimensionalexponents(-2, -1, 3, 2, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.electricvoltageunit:
        if (dim == ifcdimensionalexponents(2, 1, -3, -1, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.electricresistanceunit:
        if (dim == ifcdimensionalexponents(2, 1, -3, -2, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.energyunit:
        if (dim == ifcdimensionalexponents(2, 1, -2, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.forceunit:
        if (dim == ifcdimensionalexponents(1, 1, -2, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.frequencyunit:
        if (dim == ifcdimensionalexponents(0, 0, -1, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.inductanceunit:
        if (dim == ifcdimensionalexponents(2, 1, -2, -2, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.illuminanceunit:
        if (dim == ifcdimensionalexponents(-2, 0, 0, 0, 0, 0, 1)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.luminousfluxunit:
        if (dim == ifcdimensionalexponents(0, 0, 0, 0, 0, 0, 1)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.magneticfluxunit:
        if (dim == ifcdimensionalexponents(2, 1, -2, -1, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.magneticfluxdensityunit:
        if (dim == ifcdimensionalexponents(0, 1, -2, -1, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.powerunit:
        if (dim == ifcdimensionalexponents(2, 1, -3, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    elif case_selector == ifcunitenum.pressureunit:
        if (dim == ifcdimensionalexponents(-1, 1, -2, 0, 0, 0, 0)):
            return TRUE
        else:
            return FALSE
    else:
        return UNKNOWN


####################
# FUNCTION ifcloopheadtotail #
####################
def ifcloopheadtotail(aloop, ):
    '''
	:param aloop
	:type aloop:ifcedgeloop
	'''
    n = SIZEOF(aloop.edgelist)
    for i in range(2, n, 1):
        p = p and (aloop.edgelist[i - 1].edgeend == aloop.edgelist[i].edgestart)
    return p


####################
# FUNCTION ifcmlstotalthickness #
####################
def ifcmlstotalthickness(layerset, ):
    '''
	:param layerset
	:type layerset:ifcmateriallayerset
	'''
    if (SIZEOF(layerset.materiallayers) > 1):
        for i in range(2, HIINDEX(layerset.materiallayers), 1):
            max = max + layerset.materiallayers[i].layerthickness
    return max


####################
# FUNCTION ifcconstraintsparambspline #
####################
def ifcconstraintsparambspline(degree, upknots, upcp, knotmult, knots, ):
    '''
	:param degree
	:type degree:Integer
	:param upknots
	:type upknots:Integer
	:param upcp
	:type upcp:Integer
	:param knotmult
	:type knotmult:(null)
	:param knots
	:type knots:(null)
	'''
    sum = knotmult[1]
    for i in range(2, upknots, 1):
        sum = sum + knotmult[i]
    if ((((degree < 1) or (upknots < 2)) or (upcp < degree)) or (sum != ((degree + upcp) + 2))):
        result = FALSE
        return result
    k = knotmult[1]
    if ((k < 1) or (k > (degree + 1))):
        result = FALSE
        return result
    for i in range(2, upknots, 1):
        if ((knotmult[i] < 1) or (knots[i] <= knots[i - 1])):
            result = FALSE
            return result
        k = knotmult[i]
        if ((i < upknots) and (k > degree)):
            result = FALSE
            return result
        if ((i == upknots) and (k > (degree + 1))):
            result = FALSE
            return result
    return result


####################
# FUNCTION ifcderivedimensionalexponents #
####################
def ifcderivedimensionalexponents(unitelements, ):
    '''
	:param unitelements
	:type unitelements:(null)
	'''
    for i in range(LOINDEX(unitelements), HIINDEX(unitelements), 1):
        result.lengthexponent = result.lengthexponent + (
                    unitelements[i].exponent * unitelements[i].unit.dimensions.lengthexponent)
        result.massexponent = result.massexponent + (
                    unitelements[i].exponent * unitelements[i].unit.dimensions.massexponent)
        result.timeexponent = result.timeexponent + (
                    unitelements[i].exponent * unitelements[i].unit.dimensions.timeexponent)
        result.electriccurrentexponent = result.electriccurrentexponent + (
                    unitelements[i].exponent * unitelements[i].unit.dimensions.electriccurrentexponent)
        result.thermodynamictemperatureexponent = result.thermodynamictemperatureexponent + (
                    unitelements[i].exponent * unitelements[i].unit.dimensions.thermodynamictemperatureexponent)
        result.amountofsubstanceexponent = result.amountofsubstanceexponent + (
                    unitelements[i].exponent * unitelements[i].unit.dimensions.amountofsubstanceexponent)
        result.luminousintensityexponent = result.luminousintensityexponent + (
                    unitelements[i].exponent * unitelements[i].unit.dimensions.luminousintensityexponent)
    return result


####################
# FUNCTION ifccorrectlocalplacement #
####################
def ifccorrectlocalplacement(axisplacement, relplacement, ):
    '''
	:param axisplacement
	:type axisplacement:ifcaxis2placement
	:param relplacement
	:type relplacement:ifcobjectplacement
	'''
    if (EXISTS(relplacement)):
        if ('IFC4X2.IFCGRIDPLACEMENT' == TYPEOF(relplacement)):
            return None
        if ('IFC4X2.IFCLOCALPLACEMENT' == TYPEOF(relplacement)):
            if ('IFC4X2.IFCAXIS2PLACEMENT2D' == TYPEOF(axisplacement)):
                return TRUE
            if ('IFC4X2.IFCAXIS2PLACEMENT3D' == TYPEOF(axisplacement)):
                if (relplacement.ifclocalplacement.relativeplacement.dim == 3):
                    return TRUE
                else:
                    return FALSE
    else:
        return TRUE
    return None


####################
# FUNCTION ifcmakearrayofarray #
####################
def ifcmakearrayofarray(lis, low1, u1, low2, u2, ):
    '''
	:param lis
	:type lis:(null)
	:param low1
	:type low1:Integer
	:param u1
	:type u1:Integer
	:param low2
	:type low2:Integer
	:param u2
	:type u2:Integer
	'''
    if (((u1 - low1) + 1) != SIZEOF(lis)):
        return None
    if (((u2 - low2) + 1) != SIZEOF(lis[1])):
        return None
    res = [ifclisttoarray(lis[1], low2, u2), 0]
    for i in range(2, HIINDEX(lis), 1):
        if (((u2 - low2) + 1) != SIZEOF(lis[i])):
            return None
        res[(low1 + i) - 1] = ifclisttoarray(lis[i], low2, u2)
    return res


####################
# FUNCTION ifcsamevalidprecision #
####################
def ifcsamevalidprecision(epsilon1, epsilon2, ):
    '''
	:param epsilon1
	:type epsilon1:Real
	:param epsilon2
	:type epsilon2:Real
	'''
    valideps1 = NVL(epsilon1, defaulteps)
    valideps2 = NVL(epsilon2, defaulteps)
    return (((0 < valideps1) and (valideps1 <= (derivationofeps * valideps2))) and (
                valideps2 <= (derivationofeps * valideps1))) and (valideps2 < uppereps)


####################
# FUNCTION ifcconsecutivesegments #
####################
def ifcconsecutivesegments(segments, ):
    '''
	:param segments
	:type segments:(null)
	'''
    for i in range(1, HIINDEX(segments) - 1, 1):
        if (segments[i][HIINDEX(segments[i])] != segments[i + 1][1]):
            # begin/end block
            result = FALSE
            break
    return result


####################
# FUNCTION ifcvectordifference #
####################
def ifcvectordifference(arg1, arg2, ):
    '''
	:param arg1
	:type arg1:ifcvectorordirection
	:param arg2
	:type arg2:ifcvectorordirection
	'''
    if (((not EXISTS(arg1)) or (not EXISTS(arg2))) or (arg1.dim != arg2.dim)):
        return None
    else:
        # begin/end block
        if ('IFC4X2.IFCVECTOR' == TYPEOF(arg1)):
            mag1 = arg1.ifcvector.magnitude
            vec1 = arg1.ifcvector.orientation
        else:
            mag1 = 1
            vec1 = arg1
        if ('IFC4X2.IFCVECTOR' == TYPEOF(arg2)):
            mag2 = arg2.ifcvector.magnitude
            vec2 = arg2.ifcvector.orientation
        else:
            mag2 = 1
            vec2 = arg2
        vec1 = ifcnormalise(vec1)
        vec2 = ifcnormalise(vec2)
        ndim = SIZEOF(vec1.directionratios)
        mag = 0
        res = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection([0, 0])
        for i in range(1, ndim, 1):
            res.directionratios[i] = (mag1 * vec1.directionratios[i]) - (mag2 * vec2.directionratios[i])
            mag = mag + (res.directionratios[i] * res.directionratios[i])
        if (mag > 0):
            result = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcvector(res, SQRT(mag))
        else:
            result = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcvector(vec1, 0)
    return result


####################
# FUNCTION ifccorrectfillareastyle #
####################
def ifccorrectfillareastyle(styles, ):
    '''
	:param styles
	:type styles:(null)
	'''
    external = SIZEOF(None)
    hatching = SIZEOF(None)
    tiles = SIZEOF(None)
    colour = SIZEOF(None)
    if (external > 1):
        return FALSE
    if ((external == 1) and (((hatching > 0) or (tiles > 0)) or (colour > 0))):
        return FALSE
    if (colour > 1):
        return FALSE
    if ((hatching > 0) and (tiles > 0)):
        return FALSE
    return TRUE


####################
# FUNCTION ifccorrectunitassignment #
####################
def ifccorrectunitassignment(units, ):
    '''
	:param units
	:type units:(null)
	'''
    namedunitnumber = SIZEOF(None)
    derivedunitnumber = SIZEOF(None)
    monetaryunitnumber = SIZEOF(None)
    for i in range(1, SIZEOF(units), 1):
        if (('IFC4X2.IFCNAMEDUNIT' == TYPEOF(units[i])) and (
        not (units[i].ifcnamedunit.unittype == ifcunitenum.ifcunitenum.userdefined))):
            namedunitnames = namedunitnames + units[i].ifcnamedunit.unittype
        if (('IFC4X2.IFCDERIVEDUNIT' == TYPEOF(units[i])) and (
        not (units[i].ifcderivedunit.unittype == ifcderivedunitenum.ifcderivedunitenum.userdefined))):
            derivedunitnames = derivedunitnames + units[i].ifcderivedunit.unittype
    return ((SIZEOF(namedunitnames) == namedunitnumber) and (SIZEOF(derivedunitnames) == derivedunitnumber)) and (
                monetaryunitnumber <= 1)


####################
# FUNCTION ifcshaperepresentationtypes #
####################
def ifcshaperepresentationtypes(reptype, items, ):
    '''
	:param reptype
	:type reptype:String
	:param items
	:type items:(null)
	'''
    case_selector = reptype
    if case_selector == 'Point':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'PointCloud':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Curve':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Curve2D':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Curve3D':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Surface':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Surface2D':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Surface3D':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'FillArea':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Text':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'AdvancedSurface':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Annotation2D':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'GeometricSet':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'GeometricCurveSet':
        # begin/end block
        count = SIZEOF(None)
        for i in range(1, HIINDEX(items), 1):
            if ('IFC4X2.IFCGEOMETRICSET' == TYPEOF(items[i])):
                if (SIZEOF(None) > 0):
                    count = count - 1
    elif case_selector == 'Tessellation':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'SurfaceOrSolidModel':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'SurfaceModel':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'SolidModel':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'SweptSolid':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'AdvancedSweptSolid':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'CSG':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Clipping':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Brep':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'AdvancedBrep':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'BoundingBox':
        # begin/end block
        count = SIZEOF(None)
        if (SIZEOF(items) > 1):
            count = 0
    elif case_selector == 'SectionedSpine':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'LightSource':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'MappedRepresentation':
        # begin/end block
        count = SIZEOF(None)
    else:
        return None
    return count == SIZEOF(items)


####################
# FUNCTION ifccrossproduct #
####################
def ifccrossproduct(arg1, arg2, ):
    '''
	:param arg1
	:type arg1:ifcdirection
	:param arg2
	:type arg2:ifcdirection
	'''
    if (((not EXISTS(arg1)) or (arg1.dim == 2)) or ((not EXISTS(arg2)) or (arg2.dim == 2))):
        return None
    else:
        # begin/end block
        v1 = ifcnormalise(arg1).ifcdirection.directionratios
        v2 = ifcnormalise(arg2).ifcdirection.directionratios
        res = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection(
            [(v1[2] * v2[3]) - (v1[3] * v2[2]), (v1[3] * v2[1]) - (v1[1] * v2[3]), (v1[1] * v2[2]) - (v1[2] * v2[1])])
        mag = 0
        for i in range(1, 3, 1):
            mag = mag + (res.directionratios[i] * res.directionratios[i])
        if (mag > 0):
            result = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcvector(res, SQRT(mag))
        else:
            result = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcvector(arg1, 0)
        return result


####################
# FUNCTION ifccorrectobjectassignment #
####################
def ifccorrectobjectassignment(constraint, objects, ):
    '''
	:param constraint
	:type constraint:ifcobjecttypeenum
	:param objects
	:type objects:(null)
	'''
    if (not EXISTS(constraint)):
        return TRUE
    case_selector = constraint
    if case_selector == ifcobjecttypeenum.ifcobjecttypeenum.notdefined:
        return TRUE
    elif case_selector == ifcobjecttypeenum.ifcobjecttypeenum.product:
        # begin/end block
        count = SIZEOF(None)
        return count == 0
    elif case_selector == ifcobjecttypeenum.ifcobjecttypeenum.process:
        # begin/end block
        count = SIZEOF(None)
        return count == 0
    elif case_selector == ifcobjecttypeenum.ifcobjecttypeenum.control:
        # begin/end block
        count = SIZEOF(None)
        return count == 0
    elif case_selector == ifcobjecttypeenum.ifcobjecttypeenum.resource:
        # begin/end block
        count = SIZEOF(None)
        return count == 0
    elif case_selector == ifcobjecttypeenum.ifcobjecttypeenum.actor:
        # begin/end block
        count = SIZEOF(None)
        return count == 0
    elif case_selector == ifcobjecttypeenum.ifcobjecttypeenum.group:
        # begin/end block
        count = SIZEOF(None)
        return count == 0
    elif case_selector == ifcobjecttypeenum.ifcobjecttypeenum.project:
        # begin/end block
        count = SIZEOF(None)
        return count == 0
    else:
        return None

    ####################


# FUNCTION ifcuniquequantitynames #
####################
def ifcuniquequantitynames(properties, ):
    '''
	:param properties
	:type properties:(null)
	'''
    for i in range(1, HIINDEX(properties), 1):
        names = names + properties[i].name
    return SIZEOF(names) == SIZEOF(properties)


####################
# FUNCTION ifctaperedsweptareaprofiles #
####################
def ifctaperedsweptareaprofiles(startarea, endarea, ):
    '''
	:param startarea
	:type startarea:ifcprofiledef
	:param endarea
	:type endarea:ifcprofiledef
	'''
    if ('IFC4X2.IFCPARAMETERIZEDPROFILEDEF' == TYPEOF(startarea)):
        if ('IFC4X2.IFCDERIVEDPROFILEDEF' == TYPEOF(endarea)):
            result = startarea == endarea.ifcderivedprofiledef.parentprofile
        else:
            result = TYPEOF(startarea) == TYPEOF(endarea)
    else:
        if ('IFC4X2.IFCDERIVEDPROFILEDEF' == TYPEOF(endarea)):
            result = startarea == endarea.ifcderivedprofiledef.parentprofile
        else:
            result = FALSE
    return result


####################
# FUNCTION ifcsamevalue #
####################
def ifcsamevalue(value1, value2, epsilon, ):
    '''
	:param value1
	:type value1:Real
	:param value2
	:type value2:Real
	:param epsilon
	:type epsilon:Real
	'''
    valideps = NVL(epsilon, defaulteps)
    return ((value1 + valideps) > value2) and (value1 < (value2 + valideps))


####################
# FUNCTION ifclisttoarray #
####################
def ifclisttoarray(lis, low, u, ):
    '''
	:param lis
	:type lis:(null)
	:param low
	:type low:Integer
	:param u
	:type u:Integer
	'''
    n = SIZEOF(lis)
    if (n != ((u - low) + 1)):
        return None
    else:
        res = [lis[1], 0]
        for i in range(2, n, 1):
            res[(low + i) - 1] = lis[i]
        return res


####################
# FUNCTION ifcuniquepropertysetnames #
####################
def ifcuniquepropertysetnames(properties, ):
    '''
	:param properties
	:type properties:(null)
	'''
    for i in range(1, HIINDEX(properties), 1):
        if ('IFC4X2.IFCPROPERTYSET' == TYPEOF(properties[i])):
            names = names + properties[i].ifcroot.name
        else:
            unnamed = unnamed + 1
    return (SIZEOF(names) + unnamed) == SIZEOF(properties)


####################
# FUNCTION ifcorthogonalcomplement #
####################
def ifcorthogonalcomplement(vec, ):
    '''
	:param vec
	:type vec:ifcdirection
	'''
    if ((not EXISTS(vec)) or (vec.dim != 2)):
        return None
    else:
        result = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection(
            [-vec.directionratios[2], vec.directionratios[1]])
        return result


####################
# FUNCTION ifcuniquedefinitionnames #
####################
def ifcuniquedefinitionnames(relations, ):
    '''
	:param relations
	:type relations:(null)
	'''
    if (SIZEOF(relations) == 0):
        return TRUE
    for i in range(1, HIINDEX(relations), 1):
        definition = relations[i].relatingpropertydefinition
        if ('IFC4X2.IFCPROPERTYSETDEFINITION' == TYPEOF(definition)):
            properties = properties + definition
        else:
            if ('IFC4X2.IFCPROPERTYSETDEFINITIONSET' == TYPEOF(definition)):
                # begin/end block
                definitionset = definition
                for j in range(1, HIINDEX(definitionset), 1):
                    properties = properties + definitionset[j]
    result = ifcuniquepropertysetnames(properties)
    return result


####################
# FUNCTION ifcfirstprojaxis #
####################
def ifcfirstprojaxis(zaxis, arg, ):
    '''
	:param zaxis
	:type zaxis:ifcdirection
	:param arg
	:type arg:ifcdirection
	'''
    if (not EXISTS(zaxis)):
        return None
    else:
        z = ifcnormalise(zaxis)
        if (not EXISTS(arg)):
            if (z.directionratios != [1, 0, 0]):
                v = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection([1, 0, 0])
            else:
                v = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection([0, 1, 0])
        else:
            if (arg.dim != 3):
                return None
            if (ifccrossproduct(arg, z).magnitude == 0):
                return None
            else:
                v = ifcnormalise(arg)
        xvec = ifcscalartimesvector(ifcdotproduct(v, z), z)
        xaxis = ifcvectordifference(v, xvec).orientation
        xaxis = ifcnormalise(xaxis)
    return xaxis


####################
# FUNCTION ifcscalartimesvector #
####################
def ifcscalartimesvector(scalar, vec, ):
    '''
	:param scalar
	:type scalar:Real
	:param vec
	:type vec:ifcvectorordirection
	'''
    if ((not EXISTS(scalar)) or (not EXISTS(vec))):
        return None
    else:
        if ('IFC4X2.IFCVECTOR' == TYPEOF(vec)):
            v = vec.ifcvector.orientation
            mag = scalar * vec.ifcvector.magnitude
        else:
            v = vec
            mag = scalar
        if (mag < 0):
            for i in range(1, SIZEOF(v.directionratios), 1):
                v.directionratios[i] = -v.directionratios[i]
            mag = -mag
        result = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcvector(ifcnormalise(v), mag)
    return result


####################
# FUNCTION ifcpathheadtotail #
####################
def ifcpathheadtotail(apath, ):
    '''
	:param apath
	:type apath:ifcpath
	'''
    n = SIZEOF(apath.edgelist)
    for i in range(2, n, 1):
        p = p and (apath.edgelist[i - 1].edgeend == apath.edgelist[i].edgestart)
    return p


####################
# FUNCTION ifccurvedim #
####################
def ifccurvedim(curve, ):
    '''
	:param curve
	:type curve:ifccurve
	'''
    if ('IFC4X2.IFCLINE' == TYPEOF(curve)):
        return curve.ifcline.pnt.dim
    if ('IFC4X2.IFCCONIC' == TYPEOF(curve)):
        return curve.ifcconic.position.dim
    if ('IFC4X2.IFCPOLYLINE' == TYPEOF(curve)):
        return curve.ifcpolyline.points[1].dim
    if ('IFC4X2.IFCTRIMMEDCURVE' == TYPEOF(curve)):
        return ifccurvedim(curve.ifctrimmedcurve.basiscurve)
    if ('IFC4X2.IFCCOMPOSITECURVE' == TYPEOF(curve)):
        return curve.ifccompositecurve.segments[1].dim
    if ('IFC4X2.IFCBSPLINECURVE' == TYPEOF(curve)):
        return curve.ifcbsplinecurve.controlpointslist[1].dim
    if ('IFC4X2.IFCOFFSETCURVE2D' == TYPEOF(curve)):
        return 2
    if ('IFC4X2.IFCOFFSETCURVE3D' == TYPEOF(curve)):
        return 3
    if ('IFC4X2.IFCOFFSETCURVEBYDISTANCES' == TYPEOF(curve)):
        return 3
    if ('IFC4X2.IFCCURVESEGMENT2D' == TYPEOF(curve)):
        return 2
    if ('IFC4X2.IFCALIGNMENTCURVE' == TYPEOF(curve)):
        return 3
    if ('IFC4X2.IFCPCURVE' == TYPEOF(curve)):
        return 3
    if ('IFC4X2.IFCINDEXEDPOLYCURVE' == TYPEOF(curve)):
        return curve.ifcindexedpolycurve.points.dim
    return None


####################
# FUNCTION ifcgetbasissurface #
####################
def ifcgetbasissurface(c, ):
    '''
	:param c
	:type c:ifccurveonsurface
	'''
    surfs = []
    if ('IFC4X2.IFCPCURVE' == TYPEOF(c)):
        surfs = [c.ifcpcurve.basissurface]
    else:
        if ('IFC4X2.IFCSURFACECURVE' == TYPEOF(c)):
            n = SIZEOF(c.ifcsurfacecurve.associatedgeometry)
            for i in range(1, n, 1):
                surfs = surfs + ifcassociatedsurface(c.ifcsurfacecurve.associatedgeometry[i])
    if ('IFC4X2.IFCCOMPOSITECURVEONSURFACE' == TYPEOF(c)):
        n = SIZEOF(c.ifccompositecurve.segments)
        surfs = ifcgetbasissurface(c.ifccompositecurve.segments[1].parentcurve)
        if (n > 1):
            for i in range(2, n, 1):
                surfs = surfs * ifcgetbasissurface(c.ifccompositecurve.segments[1].parentcurve)
    return surfs


####################
# FUNCTION ifcvectorsum #
####################
def ifcvectorsum(arg1, arg2, ):
    '''
	:param arg1
	:type arg1:ifcvectorordirection
	:param arg2
	:type arg2:ifcvectorordirection
	'''
    if (((not EXISTS(arg1)) or (not EXISTS(arg2))) or (arg1.dim != arg2.dim)):
        return None
    else:
        # begin/end block
        if ('IFC4X2.IFCVECTOR' == TYPEOF(arg1)):
            mag1 = arg1.ifcvector.magnitude
            vec1 = arg1.ifcvector.orientation
        else:
            mag1 = 1
            vec1 = arg1
        if ('IFC4X2.IFCVECTOR' == TYPEOF(arg2)):
            mag2 = arg2.ifcvector.magnitude
            vec2 = arg2.ifcvector.orientation
        else:
            mag2 = 1
            vec2 = arg2
        vec1 = ifcnormalise(vec1)
        vec2 = ifcnormalise(vec2)
        ndim = SIZEOF(vec1.directionratios)
        mag = 0
        res = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection([0, 0])
        for i in range(1, ndim, 1):
            res.directionratios[i] = (mag1 * vec1.directionratios[i]) + (mag2 * vec2.directionratios[i])
            mag = mag + (res.directionratios[i] * res.directionratios[i])
        if (mag > 0):
            result = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcvector(res, SQRT(mag))
        else:
            result = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcvector(vec1, 0)
    return result


####################
# FUNCTION ifcnormalise #
####################
def ifcnormalise(arg, ):
    '''
	:param arg
	:type arg:ifcvectorordirection
	'''
    if (not EXISTS(arg)):
        return None
    else:
        if ('IFC4X2.IFCVECTOR' == TYPEOF(arg)):
            # begin/end block
            ndim = arg.ifcvector.dim
            v.directionratios = arg.ifcvector.orientation.directionratios
            vec.magnitude = arg.ifcvector.magnitude
            vec.orientation = v
            if (arg.ifcvector.magnitude == 0):
                return None
            else:
                vec.magnitude = 1
        else:
            # begin/end block
            ndim = arg.ifcdirection.dim
            v.directionratios = arg.ifcdirection.directionratios
        mag = 0
        for i in range(1, ndim, 1):
            mag = mag + (v.directionratios[i] * v.directionratios[i])
        if (mag > 0):
            mag = SQRT(mag)
            for i in range(1, ndim, 1):
                v.directionratios[i] = v.directionratios[i] / mag
            if ('IFC4X2.IFCVECTOR' == TYPEOF(arg)):
                vec.orientation = v
                result = vec
            else:
                result = v
        else:
            return None
    return result


####################
# FUNCTION ifcpointlistdim #
####################
def ifcpointlistdim(pointlist, ):
    '''
	:param pointlist
	:type pointlist:ifccartesianpointlist
	'''
    if ('IFC4X2.IFCCARTESIANPOINTLIST2D' == TYPEOF(pointlist)):
        return 2
    if ('IFC4X2.IFCCARTESIANPOINTLIST3D' == TYPEOF(pointlist)):
        return 3
    return None


####################
# FUNCTION ifcsameaxis2placement #
####################
def ifcsameaxis2placement(ap1, ap2, epsilon, ):
    '''
	:param ap1
	:type ap1:ifcaxis2placement
	:param ap2
	:type ap2:ifcaxis2placement
	:param epsilon
	:type epsilon:Real
	'''
    return (ifcsamedirection(ap1.p[1], ap2.p[1], epsilon) and ifcsamedirection(ap1.p[2], ap2.p[2],
                                                                               epsilon)) and ifcsamecartesianpoint(
        ap1.location, ap1.location, epsilon)


####################
# FUNCTION ifcsurfaceweightspositive #
####################
def ifcsurfaceweightspositive(b, ):
    '''
	:param b
	:type b:ifcrationalbsplinesurfacewithknots
	'''
    for i in range(0, b.ifcbsplinesurface.uupper, 1):
        for j in range(0, b.ifcbsplinesurface.vupper, 1):
            if (weights[i][j] <= 0):
                result = FALSE
                return result
    return result


####################
# FUNCTION ifcuniquepropertytemplatenames #
####################
def ifcuniquepropertytemplatenames(properties, ):
    '''
	:param properties
	:type properties:(null)
	'''
    for i in range(1, HIINDEX(properties), 1):
        names = names + properties[i].name
    return SIZEOF(names) == SIZEOF(properties)


####################
# FUNCTION ifcbooleanchoose #
####################
def ifcbooleanchoose(b, choice1, choice2, ):
    '''
	:param b
	:type b:BOOLEAN
	:param choice1
	:type choice1:(null)
	:param choice2
	:type choice2:(null)
	'''
    if (b):
        return choice1
    else:
        return choice2


####################
# FUNCTION ifcbuild2axes #
####################
def ifcbuild2axes(refdirection, ):
    '''
	:param refdirection
	:type refdirection:ifcdirection
	'''
    return [d, ifcorthogonalcomplement(d)]


####################
# FUNCTION ifcdimensionsforsiunit #
####################
def ifcdimensionsforsiunit(n, ):
    '''
	:param n
	:type n:ifcsiunitname
	'''
    case_selector = n
    if case_selector == ifcsiunitname.metre:
        return ifcdimensionalexponents(1, 0, 0, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.square_metre:
        return ifcdimensionalexponents(2, 0, 0, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.cubic_metre:
        return ifcdimensionalexponents(3, 0, 0, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.gram:
        return ifcdimensionalexponents(0, 1, 0, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.second:
        return ifcdimensionalexponents(0, 0, 1, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.ampere:
        return ifcdimensionalexponents(0, 0, 0, 1, 0, 0, 0)
    elif case_selector == ifcsiunitname.kelvin:
        return ifcdimensionalexponents(0, 0, 0, 0, 1, 0, 0)
    elif case_selector == ifcsiunitname.mole:
        return ifcdimensionalexponents(0, 0, 0, 0, 0, 1, 0)
    elif case_selector == ifcsiunitname.candela:
        return ifcdimensionalexponents(0, 0, 0, 0, 0, 0, 1)
    elif case_selector == ifcsiunitname.radian:
        return ifcdimensionalexponents(0, 0, 0, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.steradian:
        return ifcdimensionalexponents(0, 0, 0, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.hertz:
        return ifcdimensionalexponents(0, 0, -1, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.newton:
        return ifcdimensionalexponents(1, 1, -2, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.pascal:
        return ifcdimensionalexponents(-1, 1, -2, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.joule:
        return ifcdimensionalexponents(2, 1, -2, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.watt:
        return ifcdimensionalexponents(2, 1, -3, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.coulomb:
        return ifcdimensionalexponents(0, 0, 1, 1, 0, 0, 0)
    elif case_selector == ifcsiunitname.volt:
        return ifcdimensionalexponents(2, 1, -3, -1, 0, 0, 0)
    elif case_selector == ifcsiunitname.farad:
        return ifcdimensionalexponents(-2, -1, 4, 2, 0, 0, 0)
    elif case_selector == ifcsiunitname.ohm:
        return ifcdimensionalexponents(2, 1, -3, -2, 0, 0, 0)
    elif case_selector == ifcsiunitname.siemens:
        return ifcdimensionalexponents(-2, -1, 3, 2, 0, 0, 0)
    elif case_selector == ifcsiunitname.weber:
        return ifcdimensionalexponents(2, 1, -2, -1, 0, 0, 0)
    elif case_selector == ifcsiunitname.tesla:
        return ifcdimensionalexponents(0, 1, -2, -1, 0, 0, 0)
    elif case_selector == ifcsiunitname.henry:
        return ifcdimensionalexponents(2, 1, -2, -2, 0, 0, 0)
    elif case_selector == ifcsiunitname.degree_celsius:
        return ifcdimensionalexponents(0, 0, 0, 0, 1, 0, 0)
    elif case_selector == ifcsiunitname.lumen:
        return ifcdimensionalexponents(0, 0, 0, 0, 0, 0, 1)
    elif case_selector == ifcsiunitname.lux:
        return ifcdimensionalexponents(-2, 0, 0, 0, 0, 0, 1)
    elif case_selector == ifcsiunitname.becquerel:
        return ifcdimensionalexponents(0, 0, -1, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.gray:
        return ifcdimensionalexponents(2, 0, -2, 0, 0, 0, 0)
    elif case_selector == ifcsiunitname.sievert:
        return ifcdimensionalexponents(2, 0, -2, 0, 0, 0, 0)
    else:
        return ifcdimensionalexponents(0, 0, 0, 0, 0, 0, 0)


####################
# FUNCTION ifcbuildaxes #
####################
def ifcbuildaxes(axis, refdirection, ):
    '''
	:param axis
	:type axis:ifcdirection
	:param refdirection
	:type refdirection:ifcdirection
	'''
    d1 = NVL(ifcnormalise(axis),
             (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection([0, 0, 1]))
    d2 = ifcfirstprojaxis(d1, refdirection)
    return [d2, ifcnormalise(ifccrossproduct(d1, d2)).ifcvector.orientation, d1]


####################
# FUNCTION ifccurveweightspositive #
####################
def ifccurveweightspositive(b, ):
    '''
	:param b
	:type b:ifcrationalbsplinecurvewithknots
	'''
    for i in range(0, b.upperindexoncontrolpoints, 1):
        if (b.weights[i] <= 0):
            result = FALSE
            return result
    return result


####################
# FUNCTION ifctopologyrepresentationtypes #
####################
def ifctopologyrepresentationtypes(reptype, items, ):
    '''
	:param reptype
	:type reptype:String
	:param items
	:type items:(null)
	'''
    case_selector = reptype
    if case_selector == 'Vertex':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Edge':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Path':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Face':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Shell':
        # begin/end block
        count = SIZEOF(None)
    elif case_selector == 'Undefined':
        return TRUE
    else:
        return None
    return count == SIZEOF(items)


####################
# FUNCTION ifcassociatedsurface #
####################
def ifcassociatedsurface(arg, ):
    '''
	:param arg
	:type arg:ifcpcurve
	'''
    surf = arg.ifcpcurve.basissurface
    return surf


####################
# FUNCTION ifcconvertdirectioninto2d #
####################
def ifcconvertdirectioninto2d(direction, ):
    '''
	:param direction
	:type direction:ifcdirection
	'''
    direction2d.directionratios[1] = direction.directionratios[1]
    direction2d.directionratios[2] = direction.directionratios[2]
    return direction2d


####################
# FUNCTION ifcbaseaxis #
####################
def ifcbaseaxis(dim, axis1, axis2, axis3, ):
    '''
	:param dim
	:type dim:Integer
	:param axis1
	:type axis1:ifcdirection
	:param axis2
	:type axis2:ifcdirection
	:param axis3
	:type axis3:ifcdirection
	'''
    if (dim == 3):
        d1 = NVL(ifcnormalise(axis3),
                 (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection([0, 0, 1]))
        d2 = ifcfirstprojaxis(d1, axis1)
        u = [d2, ifcsecondprojaxis(d1, d2, axis2), d1]
    else:
        if (EXISTS(axis1)):
            d1 = ifcnormalise(axis1)
            u = [d1, ifcorthogonalcomplement(d1)]
            if (EXISTS(axis2)):
                factor = ifcdotproduct(axis2, u[2])
                if (factor < 0):
                    u[2].directionratios[1] = -u[2].directionratios[1]
                    u[2].directionratios[2] = -u[2].directionratios[2]
        else:
            if (EXISTS(axis2)):
                d1 = ifcnormalise(axis2)
                u = [ifcorthogonalcomplement(d1), d1]
                u[1].directionratios[1] = -u[1].directionratios[1]
                u[1].directionratios[2] = -u[1].directionratios[2]
            else:
                u = [(ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection([1, 0]),
                     (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection([0, 1])]
    return u


####################
# FUNCTION ifcdotproduct #
####################
def ifcdotproduct(arg1, arg2, ):
    '''
	:param arg1
	:type arg1:ifcdirection
	:param arg2
	:type arg2:ifcdirection
	'''
    if ((not EXISTS(arg1)) or (not EXISTS(arg2))):
        scalar = None
    else:
        if (arg1.dim != arg2.dim):
            scalar = None
        else:
            # begin/end block
            vec1 = ifcnormalise(arg1)
            vec2 = ifcnormalise(arg2)
            ndim = arg1.dim
            scalar = 0
            for i in range(1, ndim, 1):
                scalar = scalar + (vec1.directionratios[i] * vec2.directionratios[i])
    return scalar


####################
# FUNCTION ifcsamedirection #
####################
def ifcsamedirection(dir1, dir2, epsilon, ):
    '''
	:param dir1
	:type dir1:ifcdirection
	:param dir2
	:type dir2:ifcdirection
	:param epsilon
	:type epsilon:Real
	'''
    if (SIZEOF(dir1.directionratios) > 2):
        dir1z = dir1.directionratios[3]
    if (SIZEOF(dir2.directionratios) > 2):
        dir2z = dir2.directionratios[3]
    return (ifcsamevalue(dir1.x, dir2.x, epsilon) and ifcsamevalue(dir1y, dir2y, epsilon)) and ifcsamevalue(dir1z, dir2z,
                                                                                                          epsilon)


####################
# FUNCTION ifcsecondprojaxis #
####################
def ifcsecondprojaxis(zaxis, xaxis, arg, ):
    '''
	:param zaxis
	:type zaxis:ifcdirection
	:param xaxis
	:type xaxis:ifcdirection
	:param arg
	:type arg:ifcdirection
	'''
    if (not EXISTS(arg)):
        v = (ifcrepresentationitem() == ifcgeometricrepresentationitem()) == ifcdirection([0, 1, 0])
    else:
        v = arg
    temp = ifcscalartimesvector(ifcdotproduct(v, zaxis), zaxis)
    yaxis = ifcvectordifference(v, temp)
    temp = ifcscalartimesvector(ifcdotproduct(v, xaxis), xaxis)
    yaxis = ifcvectordifference(yaxis, temp)
    yaxis = ifcnormalise(yaxis)
    return yaxis.orientation


####################
# FUNCTION ifcuniquepropertyname #
####################
def ifcuniquepropertyname(properties, ):
    '''
	:param properties
	:type properties:(null)
	'''
    for i in range(1, HIINDEX(properties), 1):
        names = names + properties[i].name
    return SIZEOF(names) == SIZEOF(properties)


####################
# FUNCTION ifcsamecartesianpoint #
####################
def ifcsamecartesianpoint(cp1, cp2, epsilon, ):
    '''
	:param cp1
	:type cp1:ifccartesianpoint
	:param cp2
	:type cp2:ifccartesianpoint
	:param epsilon
	:type epsilon:Real
	'''
    if (SIZEOF(cp1.coordinates) > 2):
        cp1z = cp1.coordinates[3]
    if (SIZEOF(cp2.coordinates) > 2):
        cp2z = cp2.coordinates[3]
    return (ifcsamevalue(cp1x, cp2x, epsilon) and ifcsamevalue(cp1y, cp2y, epsilon)) and ifcsamevalue(cp1z, cp2z,
                                                                                                      epsilon)


####################
# RULE ifcrepresentationcontextsamewcs #
####################
ifcrepresentationcontextsamewcs = Rule()

####################
# RULE ifcsingleprojectinstance #
####################
ifcsingleprojectinstance = Rule()
