{"version":3,"sources":["VTKStreamlit.tsx","index.tsx"],"names":["VTKStreamlit","renderData","useStreamlit","viewerRef","useRef","sceneRef","clearRef","React","useState","viewerState","setViewerState","actionStackRef","undefined","file","setFile","dispatchActionStack","useCallback","current","dispatch","length","findIndex","a","type","handleScreenshot","actions","reverse","filter","action","i","array","ids","useEffect","args","currFile","isequal","loadFile","config","Blob","toolbar","useMemo","sider","cssStyle","height","includes","Streamlit","setFrameHeight","parseInt","replace","border","borderRadius","setComponentValue","scene","style","backgroundColor","width","display","flexDirection","Content","ref","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.a06cd207.chunk.js","sourcesContent":["import React, { useCallback, useEffect, useMemo, useRef } from \"react\"\n\nimport { Streamlit } from \"streamlit-component-lib\"\nimport { useStreamlit } from \"streamlit-component-lib-react-hooks\"\n\nimport { VTKViewer, VTKViewerDrawer, VTKFloatingToolbar } from \"lavender-vtkjs\"\n\nimport { Layout } from \"antd\"\n\nimport './VTKStreamlit.css'\n\nimport isequal from \"lodash.isequal\"\n\nconst VTKStreamlit: React.FunctionComponent = () => {\n  // \"props\" aka args coming from Streamlit\n  const renderData = useStreamlit()\n\n  // viewerRef contains the reference to the vtkjs viewer api\n  const viewerRef = useRef<any>(null)\n  // maintain reference to scene state\n  const sceneRef = useRef<any[]>()\n  const clearRef = useRef<boolean>(true)\n\n  // state returned to streamlit\n  const [viewerState, setViewerState] = React.useState<any>({})\n\n  // stack of actions to dispatch via vtkjs\n  const actionStackRef = useRef<any[]>([])\n\n  // file to be loaded\n  const [file, setFile] = React.useState<Uint8Array | undefined>(undefined)\n\n  // designed to be able to aggreate and dispatch actions on a debounced interval\n  // implemented as a standalone function at this point\n  const dispatchActionStack = useCallback(() => {\n    if (viewerRef.current && viewerRef.current.dispatch &&\n      actionStackRef.current && actionStackRef.current.length > 0) {\n\n      // handles screenshot as a special case\n      const screenshotIndex = actionStackRef.current.findIndex(a => a.type === \"streamlit-screenshot\")\n      if (screenshotIndex !== -1) handleScreenshot()\n\n      // filters type === \"strealit-screenshot\", and actions with duplicate types\n      // any action with ids [] will be dispatched\n      const actions = [...actionStackRef.current].reverse()\n        .filter((action, i, array) =>\n          (action.type !== \"streamlit-screenshot\" &&\n            typeof action.ids !== 'undefined') ||\n          array.findIndex(a => a.type === action.type) === i\n        )\n\n      viewerRef.current.dispatch(actions)\n      actionStackRef.current = []\n    }\n  }, [])\n\n  useEffect(() => {\n    if (renderData && typeof renderData.args[\"clear\"] !== undefined) {\n      clearRef.current = renderData.args[\"clear\"]\n    }\n  }, [renderData])\n\n  useEffect(() => {\n    if (renderData && renderData.args[\"file\"]) {\n      setFile(currFile => {\n        if (!currFile) return renderData.args[\"file\"]\n        const equal = isequal(renderData.args[\"file\"], currFile)\n        return equal ? currFile : renderData.args[\"file\"]\n      })\n    }\n  }, [renderData])\n\n  useEffect(() => {\n    if (renderData && typeof renderData.args[\"action_stack\"] !== undefined\n      && viewerRef.current && viewerRef.current.dispatch) {\n      actionStackRef.current = [\n        ...actionStackRef.current,\n        ...renderData.args[\"action_stack\"]\n      ]\n      if (actionStackRef.current.length > 0) {\n        dispatchActionStack()\n      }\n    }\n  }, [renderData, dispatchActionStack])\n\n  useEffect(() => {\n    if (!file) return\n    if (viewerRef.current && viewerRef.current.dispatch && viewerRef.current.loadFile) {\n      if (clearRef.current) viewerRef.current.dispatch({ type: 'remove-all' }, true)\n      const config = clearRef.current ? undefined : viewerState\n      viewerRef.current.loadFile(new Blob([file]), 'vtkjs', config)\n    }\n    // intentionally leaving out viewerState\n  }, [file])\n\n  // defaults to true\n  const toolbar = useMemo(() => {\n    if (renderData && typeof renderData.args[\"toolbar\"] !== 'undefined') {\n      return renderData.args[\"toolbar\"]\n    }\n    else {\n      return true\n    }\n  }, [renderData])\n\n  // defaults to true\n  const sider = useMemo(() => {\n    if (renderData && typeof renderData.args[\"sider\"] !== 'undefined') {\n      return renderData.args[\"sider\"]\n    }\n    else {\n      return true\n    }\n  }, [renderData])\n\n  const cssStyle = useMemo(() => {\n    if (renderData && typeof renderData.args[\"style\"] !== 'undefined') {\n      if (renderData.args[\"style\"].height && renderData.args[\"style\"].height.includes('px')) {\n        Streamlit.setFrameHeight(parseInt(renderData.args[\"style\"].height.replace('px', '')))\n      }\n      return renderData.args[\"style\"]\n    }\n    else {\n      return { border: \"1px solid #d0d7de\", borderRadius: \"2px\" }\n    }\n  }, [renderData])\n\n  // initial state of streamlit component\n  useEffect(() => {\n    Streamlit.setComponentValue({})\n  }, [])\n\n  useEffect(() => {\n    // update if we're subscribed\n    // this is camera and everything else\n    if (renderData && renderData.args[\"subscribe\"]) {\n      Streamlit.setComponentValue(viewerState)\n    } else if (viewerState.scene && viewerState.scene.length > 0) {\n      const scene = [...viewerState.scene]\n\n      if (isequal(scene, sceneRef.current)) return\n      sceneRef.current = scene\n\n      Streamlit.setComponentValue({\n        scene\n      })\n    }\n  }, [viewerState, renderData])\n\n  const handleScreenshot = () => {\n    if (!viewerRef.current) return\n    viewerRef.current.handleScreenshot('VTKJSStreamlit', false)\n  }\n\n  if (renderData == null) {\n    return (\n      <div style={{\n        height: \"400px\",\n        border: \"1px solid #d0d7de\",\n        borderRadius: \"2px\",\n        backgroundColor: \"#f0f2f5\",\n      }} />\n    )\n  }\n\n  return (\n    <div style={{ width: '100%', height: '100%', border: \"1px solid #d0d7de\", borderRadius: \"2px\", ...cssStyle, display: 'flex' }}>\n      <Layout style={{ flexDirection: 'row' }}>\n        {sider &&\n          <VTKViewerDrawer dispatch={viewerRef.current?.dispatch} viewerState={viewerState} handleScreenshot={handleScreenshot} />\n        }\n        <Layout>\n          {toolbar &&\n            <VTKFloatingToolbar dispatch={viewerRef.current?.dispatch} viewerState={viewerState} handleScreenshot={handleScreenshot} />\n          }\n          <Layout.Content style={{ display: 'flex', flexDirection: 'column' }}>\n            <VTKViewer setViewerState={setViewerState} ref={viewerRef} />\n          </Layout.Content>\n        </Layout>\n      </Layout>\n    </div>\n  )\n}\n\nexport default VTKStreamlit","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport { ErrorBoundary } from \"streamlit-component-lib-react-hooks\"\nimport VTKStreamlit from \"./VTKStreamlit\"\n\nimport 'antd/dist/antd.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <ErrorBoundary>\n      <VTKStreamlit />\n    </ErrorBoundary>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}